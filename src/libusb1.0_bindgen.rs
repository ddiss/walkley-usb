/* automatically generated by rust-bindgen 0.57.0 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _SYS_TIME_H: u32 = 1;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const LIBUSB_API_VERSION: u32 = 16777477;
pub const LIBUSBX_API_VERSION: u32 = 16777477;
pub const LIBUSB_DT_DEVICE_SIZE: u32 = 18;
pub const LIBUSB_DT_CONFIG_SIZE: u32 = 9;
pub const LIBUSB_DT_INTERFACE_SIZE: u32 = 9;
pub const LIBUSB_DT_ENDPOINT_SIZE: u32 = 7;
pub const LIBUSB_DT_ENDPOINT_AUDIO_SIZE: u32 = 9;
pub const LIBUSB_DT_HUB_NONVAR_SIZE: u32 = 7;
pub const LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE: u32 = 6;
pub const LIBUSB_DT_BOS_SIZE: u32 = 5;
pub const LIBUSB_DT_DEVICE_CAPABILITY_SIZE: u32 = 3;
pub const LIBUSB_BT_USB_2_0_EXTENSION_SIZE: u32 = 7;
pub const LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE: u32 = 10;
pub const LIBUSB_BT_CONTAINER_ID_SIZE: u32 = 20;
pub const LIBUSB_DT_BOS_MAX_SIZE: u32 = 42;
pub const LIBUSB_ENDPOINT_ADDRESS_MASK: u32 = 15;
pub const LIBUSB_ENDPOINT_DIR_MASK: u32 = 128;
pub const LIBUSB_TRANSFER_TYPE_MASK: u32 = 3;
pub const LIBUSB_ISO_SYNC_TYPE_MASK: u32 = 12;
pub const LIBUSB_ISO_USAGE_TYPE_MASK: u32 = 48;
pub const LIBUSB_ERROR_COUNT: u32 = 14;
pub const LIBUSB_HOTPLUG_MATCH_ANY: i32 = -1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " In the context of a \\ref libusb_device_descriptor \"device descriptor\","]
#[doc = " this bDeviceClass value indicates that each interface specifies its"]
#[doc = " own class information and all interfaces operate independently."]
pub const libusb_class_code_LIBUSB_CLASS_PER_INTERFACE: libusb_class_code = 0;
#[doc = " Audio class"]
pub const libusb_class_code_LIBUSB_CLASS_AUDIO: libusb_class_code = 1;
#[doc = " Communications class"]
pub const libusb_class_code_LIBUSB_CLASS_COMM: libusb_class_code = 2;
#[doc = " Human Interface Device class"]
pub const libusb_class_code_LIBUSB_CLASS_HID: libusb_class_code = 3;
#[doc = " Physical"]
pub const libusb_class_code_LIBUSB_CLASS_PHYSICAL: libusb_class_code = 5;
#[doc = " Printer class"]
pub const libusb_class_code_LIBUSB_CLASS_PRINTER: libusb_class_code = 7;
#[doc = " Image class"]
pub const libusb_class_code_LIBUSB_CLASS_PTP: libusb_class_code = 6;
#[doc = " Image class"]
pub const libusb_class_code_LIBUSB_CLASS_IMAGE: libusb_class_code = 6;
#[doc = " Mass storage class"]
pub const libusb_class_code_LIBUSB_CLASS_MASS_STORAGE: libusb_class_code = 8;
#[doc = " Hub class"]
pub const libusb_class_code_LIBUSB_CLASS_HUB: libusb_class_code = 9;
#[doc = " Data class"]
pub const libusb_class_code_LIBUSB_CLASS_DATA: libusb_class_code = 10;
#[doc = " Smart Card"]
pub const libusb_class_code_LIBUSB_CLASS_SMART_CARD: libusb_class_code = 11;
#[doc = " Content Security"]
pub const libusb_class_code_LIBUSB_CLASS_CONTENT_SECURITY: libusb_class_code = 13;
#[doc = " Video"]
pub const libusb_class_code_LIBUSB_CLASS_VIDEO: libusb_class_code = 14;
#[doc = " Personal Healthcare"]
pub const libusb_class_code_LIBUSB_CLASS_PERSONAL_HEALTHCARE: libusb_class_code = 15;
#[doc = " Diagnostic Device"]
pub const libusb_class_code_LIBUSB_CLASS_DIAGNOSTIC_DEVICE: libusb_class_code = 220;
#[doc = " Wireless class"]
pub const libusb_class_code_LIBUSB_CLASS_WIRELESS: libusb_class_code = 224;
#[doc = " Application class"]
pub const libusb_class_code_LIBUSB_CLASS_APPLICATION: libusb_class_code = 254;
#[doc = " Class is vendor-specific"]
pub const libusb_class_code_LIBUSB_CLASS_VENDOR_SPEC: libusb_class_code = 255;
#[doc = " \\ingroup libusb_desc"]
#[doc = " Device and/or Interface Class codes"]
pub type libusb_class_code = ::std::os::raw::c_uint;
#[doc = " Device descriptor. See libusb_device_descriptor."]
pub const libusb_descriptor_type_LIBUSB_DT_DEVICE: libusb_descriptor_type = 1;
#[doc = " Configuration descriptor. See libusb_config_descriptor."]
pub const libusb_descriptor_type_LIBUSB_DT_CONFIG: libusb_descriptor_type = 2;
#[doc = " String descriptor"]
pub const libusb_descriptor_type_LIBUSB_DT_STRING: libusb_descriptor_type = 3;
#[doc = " Interface descriptor. See libusb_interface_descriptor."]
pub const libusb_descriptor_type_LIBUSB_DT_INTERFACE: libusb_descriptor_type = 4;
#[doc = " Endpoint descriptor. See libusb_endpoint_descriptor."]
pub const libusb_descriptor_type_LIBUSB_DT_ENDPOINT: libusb_descriptor_type = 5;
#[doc = " BOS descriptor"]
pub const libusb_descriptor_type_LIBUSB_DT_BOS: libusb_descriptor_type = 15;
#[doc = " Device Capability descriptor"]
pub const libusb_descriptor_type_LIBUSB_DT_DEVICE_CAPABILITY: libusb_descriptor_type = 16;
#[doc = " HID descriptor"]
pub const libusb_descriptor_type_LIBUSB_DT_HID: libusb_descriptor_type = 33;
#[doc = " HID report descriptor"]
pub const libusb_descriptor_type_LIBUSB_DT_REPORT: libusb_descriptor_type = 34;
#[doc = " Physical descriptor"]
pub const libusb_descriptor_type_LIBUSB_DT_PHYSICAL: libusb_descriptor_type = 35;
#[doc = " Hub descriptor"]
pub const libusb_descriptor_type_LIBUSB_DT_HUB: libusb_descriptor_type = 41;
#[doc = " SuperSpeed Hub descriptor"]
pub const libusb_descriptor_type_LIBUSB_DT_SUPERSPEED_HUB: libusb_descriptor_type = 42;
#[doc = " SuperSpeed Endpoint Companion descriptor"]
pub const libusb_descriptor_type_LIBUSB_DT_SS_ENDPOINT_COMPANION: libusb_descriptor_type = 48;
#[doc = " \\ingroup libusb_desc"]
#[doc = " Descriptor types as defined by the USB specification."]
pub type libusb_descriptor_type = ::std::os::raw::c_uint;
#[doc = " In: device-to-host"]
pub const libusb_endpoint_direction_LIBUSB_ENDPOINT_IN: libusb_endpoint_direction = 128;
#[doc = " Out: host-to-device"]
pub const libusb_endpoint_direction_LIBUSB_ENDPOINT_OUT: libusb_endpoint_direction = 0;
#[doc = " \\ingroup libusb_desc"]
#[doc = " Endpoint direction. Values for bit 7 of the"]
#[doc = " \\ref libusb_endpoint_descriptor::bEndpointAddress \"endpoint address\" scheme."]
pub type libusb_endpoint_direction = ::std::os::raw::c_uint;
#[doc = " Control endpoint"]
pub const libusb_transfer_type_LIBUSB_TRANSFER_TYPE_CONTROL: libusb_transfer_type = 0;
#[doc = " Isochronous endpoint"]
pub const libusb_transfer_type_LIBUSB_TRANSFER_TYPE_ISOCHRONOUS: libusb_transfer_type = 1;
#[doc = " Bulk endpoint"]
pub const libusb_transfer_type_LIBUSB_TRANSFER_TYPE_BULK: libusb_transfer_type = 2;
#[doc = " Interrupt endpoint"]
pub const libusb_transfer_type_LIBUSB_TRANSFER_TYPE_INTERRUPT: libusb_transfer_type = 3;
#[doc = " Stream endpoint"]
pub const libusb_transfer_type_LIBUSB_TRANSFER_TYPE_BULK_STREAM: libusb_transfer_type = 4;
#[doc = " \\ingroup libusb_desc"]
#[doc = " Endpoint transfer type. Values for bits 0:1 of the"]
#[doc = " \\ref libusb_endpoint_descriptor::bmAttributes \"endpoint attributes\" field."]
pub type libusb_transfer_type = ::std::os::raw::c_uint;
#[doc = " Request status of the specific recipient"]
pub const libusb_standard_request_LIBUSB_REQUEST_GET_STATUS: libusb_standard_request = 0;
#[doc = " Clear or disable a specific feature"]
pub const libusb_standard_request_LIBUSB_REQUEST_CLEAR_FEATURE: libusb_standard_request = 1;
#[doc = " Set or enable a specific feature"]
pub const libusb_standard_request_LIBUSB_REQUEST_SET_FEATURE: libusb_standard_request = 3;
#[doc = " Set device address for all future accesses"]
pub const libusb_standard_request_LIBUSB_REQUEST_SET_ADDRESS: libusb_standard_request = 5;
#[doc = " Get the specified descriptor"]
pub const libusb_standard_request_LIBUSB_REQUEST_GET_DESCRIPTOR: libusb_standard_request = 6;
#[doc = " Used to update existing descriptors or add new descriptors"]
pub const libusb_standard_request_LIBUSB_REQUEST_SET_DESCRIPTOR: libusb_standard_request = 7;
#[doc = " Get the current device configuration value"]
pub const libusb_standard_request_LIBUSB_REQUEST_GET_CONFIGURATION: libusb_standard_request = 8;
#[doc = " Set device configuration"]
pub const libusb_standard_request_LIBUSB_REQUEST_SET_CONFIGURATION: libusb_standard_request = 9;
#[doc = " Return the selected alternate setting for the specified interface"]
pub const libusb_standard_request_LIBUSB_REQUEST_GET_INTERFACE: libusb_standard_request = 10;
#[doc = " Select an alternate interface for the specified interface"]
pub const libusb_standard_request_LIBUSB_REQUEST_SET_INTERFACE: libusb_standard_request = 11;
#[doc = " Set then report an endpoint's synchronization frame"]
pub const libusb_standard_request_LIBUSB_REQUEST_SYNCH_FRAME: libusb_standard_request = 12;
#[doc = " Sets both the U1 and U2 Exit Latency"]
pub const libusb_standard_request_LIBUSB_REQUEST_SET_SEL: libusb_standard_request = 48;
#[doc = " Delay from the time a host transmits a packet to the time it is"]
#[doc = " received by the device."]
pub const libusb_standard_request_LIBUSB_SET_ISOCH_DELAY: libusb_standard_request = 49;
#[doc = " \\ingroup libusb_misc"]
#[doc = " Standard requests, as defined in table 9-5 of the USB 3.0 specifications"]
pub type libusb_standard_request = ::std::os::raw::c_uint;
#[doc = " Standard"]
pub const libusb_request_type_LIBUSB_REQUEST_TYPE_STANDARD: libusb_request_type = 0;
#[doc = " Class"]
pub const libusb_request_type_LIBUSB_REQUEST_TYPE_CLASS: libusb_request_type = 32;
#[doc = " Vendor"]
pub const libusb_request_type_LIBUSB_REQUEST_TYPE_VENDOR: libusb_request_type = 64;
#[doc = " Reserved"]
pub const libusb_request_type_LIBUSB_REQUEST_TYPE_RESERVED: libusb_request_type = 96;
#[doc = " \\ingroup libusb_misc"]
#[doc = " Request type bits of the"]
#[doc = " \\ref libusb_control_setup::bmRequestType \"bmRequestType\" field in control"]
#[doc = " transfers."]
pub type libusb_request_type = ::std::os::raw::c_uint;
#[doc = " Device"]
pub const libusb_request_recipient_LIBUSB_RECIPIENT_DEVICE: libusb_request_recipient = 0;
#[doc = " Interface"]
pub const libusb_request_recipient_LIBUSB_RECIPIENT_INTERFACE: libusb_request_recipient = 1;
#[doc = " Endpoint"]
pub const libusb_request_recipient_LIBUSB_RECIPIENT_ENDPOINT: libusb_request_recipient = 2;
#[doc = " Other"]
pub const libusb_request_recipient_LIBUSB_RECIPIENT_OTHER: libusb_request_recipient = 3;
#[doc = " \\ingroup libusb_misc"]
#[doc = " Recipient bits of the"]
#[doc = " \\ref libusb_control_setup::bmRequestType \"bmRequestType\" field in control"]
#[doc = " transfers. Values 4 through 31 are reserved."]
pub type libusb_request_recipient = ::std::os::raw::c_uint;
#[doc = " No synchronization"]
pub const libusb_iso_sync_type_LIBUSB_ISO_SYNC_TYPE_NONE: libusb_iso_sync_type = 0;
#[doc = " Asynchronous"]
pub const libusb_iso_sync_type_LIBUSB_ISO_SYNC_TYPE_ASYNC: libusb_iso_sync_type = 1;
#[doc = " Adaptive"]
pub const libusb_iso_sync_type_LIBUSB_ISO_SYNC_TYPE_ADAPTIVE: libusb_iso_sync_type = 2;
#[doc = " Synchronous"]
pub const libusb_iso_sync_type_LIBUSB_ISO_SYNC_TYPE_SYNC: libusb_iso_sync_type = 3;
#[doc = " \\ingroup libusb_desc"]
#[doc = " Synchronization type for isochronous endpoints. Values for bits 2:3 of the"]
#[doc = " \\ref libusb_endpoint_descriptor::bmAttributes \"bmAttributes\" field in"]
#[doc = " libusb_endpoint_descriptor."]
pub type libusb_iso_sync_type = ::std::os::raw::c_uint;
#[doc = " Data endpoint"]
pub const libusb_iso_usage_type_LIBUSB_ISO_USAGE_TYPE_DATA: libusb_iso_usage_type = 0;
#[doc = " Feedback endpoint"]
pub const libusb_iso_usage_type_LIBUSB_ISO_USAGE_TYPE_FEEDBACK: libusb_iso_usage_type = 1;
#[doc = " Implicit feedback Data endpoint"]
pub const libusb_iso_usage_type_LIBUSB_ISO_USAGE_TYPE_IMPLICIT: libusb_iso_usage_type = 2;
#[doc = " \\ingroup libusb_desc"]
#[doc = " Usage type for isochronous endpoints. Values for bits 4:5 of the"]
#[doc = " \\ref libusb_endpoint_descriptor::bmAttributes \"bmAttributes\" field in"]
#[doc = " libusb_endpoint_descriptor."]
pub type libusb_iso_usage_type = ::std::os::raw::c_uint;
#[doc = " \\ingroup libusb_desc"]
#[doc = " A structure representing the standard USB device descriptor. This"]
#[doc = " descriptor is documented in section 9.6.1 of the USB 3.0 specification."]
#[doc = " All multiple-byte fields are represented in host-endian format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_device_descriptor {
    #[doc = " Size of this descriptor (in bytes)"]
    pub bLength: u8,
    #[doc = " Descriptor type. Will have value"]
    #[doc = " \\ref libusb_descriptor_type::LIBUSB_DT_DEVICE LIBUSB_DT_DEVICE in this"]
    #[doc = " context."]
    pub bDescriptorType: u8,
    #[doc = " USB specification release number in binary-coded decimal. A value of"]
    #[doc = " 0x0200 indicates USB 2.0, 0x0110 indicates USB 1.1, etc."]
    pub bcdUSB: u16,
    #[doc = " USB-IF class code for the device. See \\ref libusb_class_code."]
    pub bDeviceClass: u8,
    #[doc = " USB-IF subclass code for the device, qualified by the bDeviceClass"]
    #[doc = " value"]
    pub bDeviceSubClass: u8,
    #[doc = " USB-IF protocol code for the device, qualified by the bDeviceClass and"]
    #[doc = " bDeviceSubClass values"]
    pub bDeviceProtocol: u8,
    #[doc = " Maximum packet size for endpoint 0"]
    pub bMaxPacketSize0: u8,
    #[doc = " USB-IF vendor ID"]
    pub idVendor: u16,
    #[doc = " USB-IF product ID"]
    pub idProduct: u16,
    #[doc = " Device release number in binary-coded decimal"]
    pub bcdDevice: u16,
    #[doc = " Index of string descriptor describing manufacturer"]
    pub iManufacturer: u8,
    #[doc = " Index of string descriptor describing product"]
    pub iProduct: u8,
    #[doc = " Index of string descriptor containing device serial number"]
    pub iSerialNumber: u8,
    #[doc = " Number of possible configurations"]
    pub bNumConfigurations: u8,
}
#[test]
fn bindgen_test_layout_libusb_device_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<libusb_device_descriptor>(),
        18usize,
        concat!("Size of: ", stringify!(libusb_device_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_device_descriptor>(),
        2usize,
        concat!("Alignment of ", stringify!(libusb_device_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_device_descriptor>())).bcdUSB as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(bcdUSB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).bDeviceClass as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).bDeviceSubClass as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).bDeviceProtocol as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).bMaxPacketSize0 as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(bMaxPacketSize0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).idVendor as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).idProduct as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).bcdDevice as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(bcdDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).iManufacturer as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(iManufacturer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).iProduct as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(iProduct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).iSerialNumber as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(iSerialNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_device_descriptor>())).bNumConfigurations as *const _
                as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_device_descriptor),
            "::",
            stringify!(bNumConfigurations)
        )
    );
}
#[doc = " \\ingroup libusb_desc"]
#[doc = " A structure representing the standard USB endpoint descriptor. This"]
#[doc = " descriptor is documented in section 9.6.6 of the USB 3.0 specification."]
#[doc = " All multiple-byte fields are represented in host-endian format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_endpoint_descriptor {
    #[doc = " Size of this descriptor (in bytes)"]
    pub bLength: u8,
    #[doc = " Descriptor type. Will have value"]
    #[doc = " \\ref libusb_descriptor_type::LIBUSB_DT_ENDPOINT LIBUSB_DT_ENDPOINT in"]
    #[doc = " this context."]
    pub bDescriptorType: u8,
    #[doc = " The address of the endpoint described by this descriptor. Bits 0:3 are"]
    #[doc = " the endpoint number. Bits 4:6 are reserved. Bit 7 indicates direction,"]
    #[doc = " see \\ref libusb_endpoint_direction."]
    pub bEndpointAddress: u8,
    #[doc = " Attributes which apply to the endpoint when it is configured using"]
    #[doc = " the bConfigurationValue. Bits 0:1 determine the transfer type and"]
    #[doc = " correspond to \\ref libusb_transfer_type. Bits 2:3 are only used for"]
    #[doc = " isochronous endpoints and correspond to \\ref libusb_iso_sync_type."]
    #[doc = " Bits 4:5 are also only used for isochronous endpoints and correspond to"]
    #[doc = " \\ref libusb_iso_usage_type. Bits 6:7 are reserved."]
    pub bmAttributes: u8,
    #[doc = " Maximum packet size this endpoint is capable of sending/receiving."]
    pub wMaxPacketSize: u16,
    #[doc = " Interval for polling endpoint for data transfers."]
    pub bInterval: u8,
    #[doc = " For audio devices only: the rate at which synchronization feedback"]
    #[doc = " is provided."]
    pub bRefresh: u8,
    #[doc = " For audio devices only: the address if the synch endpoint"]
    pub bSynchAddress: u8,
    #[doc = " Extra descriptors. If libusb encounters unknown endpoint descriptors,"]
    #[doc = " it will store them here, should you wish to parse them."]
    pub extra: *const ::std::os::raw::c_uchar,
    #[doc = " Length of the extra descriptors, in bytes."]
    pub extra_length: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_libusb_endpoint_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<libusb_endpoint_descriptor>(),
        32usize,
        concat!("Size of: ", stringify!(libusb_endpoint_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_endpoint_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(libusb_endpoint_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_endpoint_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_endpoint_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_endpoint_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_endpoint_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_endpoint_descriptor>())).bEndpointAddress as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_endpoint_descriptor),
            "::",
            stringify!(bEndpointAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_endpoint_descriptor>())).bmAttributes as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_endpoint_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_endpoint_descriptor>())).wMaxPacketSize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_endpoint_descriptor),
            "::",
            stringify!(wMaxPacketSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_endpoint_descriptor>())).bInterval as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_endpoint_descriptor),
            "::",
            stringify!(bInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_endpoint_descriptor>())).bRefresh as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_endpoint_descriptor),
            "::",
            stringify!(bRefresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_endpoint_descriptor>())).bSynchAddress as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_endpoint_descriptor),
            "::",
            stringify!(bSynchAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_endpoint_descriptor>())).extra as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_endpoint_descriptor),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_endpoint_descriptor>())).extra_length as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_endpoint_descriptor),
            "::",
            stringify!(extra_length)
        )
    );
}
#[doc = " \\ingroup libusb_desc"]
#[doc = " A structure representing the standard USB interface descriptor. This"]
#[doc = " descriptor is documented in section 9.6.5 of the USB 3.0 specification."]
#[doc = " All multiple-byte fields are represented in host-endian format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_interface_descriptor {
    #[doc = " Size of this descriptor (in bytes)"]
    pub bLength: u8,
    #[doc = " Descriptor type. Will have value"]
    #[doc = " \\ref libusb_descriptor_type::LIBUSB_DT_INTERFACE LIBUSB_DT_INTERFACE"]
    #[doc = " in this context."]
    pub bDescriptorType: u8,
    #[doc = " Number of this interface"]
    pub bInterfaceNumber: u8,
    #[doc = " Value used to select this alternate setting for this interface"]
    pub bAlternateSetting: u8,
    #[doc = " Number of endpoints used by this interface (excluding the control"]
    #[doc = " endpoint)."]
    pub bNumEndpoints: u8,
    #[doc = " USB-IF class code for this interface. See \\ref libusb_class_code."]
    pub bInterfaceClass: u8,
    #[doc = " USB-IF subclass code for this interface, qualified by the"]
    #[doc = " bInterfaceClass value"]
    pub bInterfaceSubClass: u8,
    #[doc = " USB-IF protocol code for this interface, qualified by the"]
    #[doc = " bInterfaceClass and bInterfaceSubClass values"]
    pub bInterfaceProtocol: u8,
    #[doc = " Index of string descriptor describing this interface"]
    pub iInterface: u8,
    #[doc = " Array of endpoint descriptors. This length of this array is determined"]
    #[doc = " by the bNumEndpoints field."]
    pub endpoint: *const libusb_endpoint_descriptor,
    #[doc = " Extra descriptors. If libusb encounters unknown interface descriptors,"]
    #[doc = " it will store them here, should you wish to parse them."]
    pub extra: *const ::std::os::raw::c_uchar,
    #[doc = " Length of the extra descriptors, in bytes."]
    pub extra_length: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_libusb_interface_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<libusb_interface_descriptor>(),
        40usize,
        concat!("Size of: ", stringify!(libusb_interface_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_interface_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(libusb_interface_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).bInterfaceNumber as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(bInterfaceNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).bAlternateSetting as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(bAlternateSetting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).bNumEndpoints as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(bNumEndpoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).bInterfaceClass as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(bInterfaceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).bInterfaceSubClass as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(bInterfaceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).bInterfaceProtocol as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(bInterfaceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).iInterface as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(iInterface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).endpoint as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).extra as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_interface_descriptor>())).extra_length as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface_descriptor),
            "::",
            stringify!(extra_length)
        )
    );
}
#[doc = " \\ingroup libusb_desc"]
#[doc = " A collection of alternate settings for a particular USB interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_interface {
    #[doc = " Array of interface descriptors. The length of this array is determined"]
    #[doc = " by the num_altsetting field."]
    pub altsetting: *const libusb_interface_descriptor,
    #[doc = " The number of alternate settings that belong to this interface"]
    pub num_altsetting: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_libusb_interface() {
    assert_eq!(
        ::std::mem::size_of::<libusb_interface>(),
        16usize,
        concat!("Size of: ", stringify!(libusb_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(libusb_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_interface>())).altsetting as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface),
            "::",
            stringify!(altsetting)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_interface>())).num_altsetting as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_interface),
            "::",
            stringify!(num_altsetting)
        )
    );
}
#[doc = " \\ingroup libusb_desc"]
#[doc = " A structure representing the standard USB configuration descriptor. This"]
#[doc = " descriptor is documented in section 9.6.3 of the USB 3.0 specification."]
#[doc = " All multiple-byte fields are represented in host-endian format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_config_descriptor {
    #[doc = " Size of this descriptor (in bytes)"]
    pub bLength: u8,
    #[doc = " Descriptor type. Will have value"]
    #[doc = " \\ref libusb_descriptor_type::LIBUSB_DT_CONFIG LIBUSB_DT_CONFIG"]
    #[doc = " in this context."]
    pub bDescriptorType: u8,
    #[doc = " Total length of data returned for this configuration"]
    pub wTotalLength: u16,
    #[doc = " Number of interfaces supported by this configuration"]
    pub bNumInterfaces: u8,
    #[doc = " Identifier value for this configuration"]
    pub bConfigurationValue: u8,
    #[doc = " Index of string descriptor describing this configuration"]
    pub iConfiguration: u8,
    #[doc = " Configuration characteristics"]
    pub bmAttributes: u8,
    #[doc = " Maximum power consumption of the USB device from this bus in this"]
    #[doc = " configuration when the device is fully operation. Expressed in units"]
    #[doc = " of 2 mA when the device is operating in high-speed mode and in units"]
    #[doc = " of 8 mA when the device is operating in super-speed mode."]
    pub MaxPower: u8,
    #[doc = " Array of interfaces supported by this configuration. The length of"]
    #[doc = " this array is determined by the bNumInterfaces field."]
    pub interface: *const libusb_interface,
    #[doc = " Extra descriptors. If libusb encounters unknown configuration"]
    #[doc = " descriptors, it will store them here, should you wish to parse them."]
    pub extra: *const ::std::os::raw::c_uchar,
    #[doc = " Length of the extra descriptors, in bytes."]
    pub extra_length: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_libusb_config_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<libusb_config_descriptor>(),
        40usize,
        concat!("Size of: ", stringify!(libusb_config_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_config_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(libusb_config_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_config_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_config_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_config_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_config_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_config_descriptor>())).wTotalLength as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_config_descriptor),
            "::",
            stringify!(wTotalLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_config_descriptor>())).bNumInterfaces as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_config_descriptor),
            "::",
            stringify!(bNumInterfaces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_config_descriptor>())).bConfigurationValue as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_config_descriptor),
            "::",
            stringify!(bConfigurationValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_config_descriptor>())).iConfiguration as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_config_descriptor),
            "::",
            stringify!(iConfiguration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_config_descriptor>())).bmAttributes as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_config_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_config_descriptor>())).MaxPower as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_config_descriptor),
            "::",
            stringify!(MaxPower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_config_descriptor>())).interface as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_config_descriptor),
            "::",
            stringify!(interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_config_descriptor>())).extra as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_config_descriptor),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_config_descriptor>())).extra_length as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_config_descriptor),
            "::",
            stringify!(extra_length)
        )
    );
}
#[doc = " \\ingroup libusb_desc"]
#[doc = " A structure representing the superspeed endpoint companion"]
#[doc = " descriptor. This descriptor is documented in section 9.6.7 of"]
#[doc = " the USB 3.0 specification. All multiple-byte fields are represented in"]
#[doc = " host-endian format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_ss_endpoint_companion_descriptor {
    #[doc = " Size of this descriptor (in bytes)"]
    pub bLength: u8,
    #[doc = " Descriptor type. Will have value"]
    #[doc = " \\ref libusb_descriptor_type::LIBUSB_DT_SS_ENDPOINT_COMPANION in"]
    #[doc = " this context."]
    pub bDescriptorType: u8,
    #[doc = " The maximum number of packets the endpoint can send or"]
    #[doc = "  receive as part of a burst."]
    pub bMaxBurst: u8,
    #[doc = " In bulk EP:\tbits 4:0 represents the\tmaximum\tnumber of"]
    #[doc = "  streams the\tEP supports. In\tisochronous EP:\tbits 1:0"]
    #[doc = "  represents the Mult\t- a zero based value that determines"]
    #[doc = "  the\tmaximum\tnumber of packets within a service interval"]
    pub bmAttributes: u8,
    #[doc = " The\ttotal number of bytes this EP will transfer every"]
    #[doc = "  service interval. valid only for periodic EPs."]
    pub wBytesPerInterval: u16,
}
#[test]
fn bindgen_test_layout_libusb_ss_endpoint_companion_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<libusb_ss_endpoint_companion_descriptor>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(libusb_ss_endpoint_companion_descriptor)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_ss_endpoint_companion_descriptor>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(libusb_ss_endpoint_companion_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_endpoint_companion_descriptor>())).bLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_endpoint_companion_descriptor>())).bDescriptorType
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_endpoint_companion_descriptor>())).bMaxBurst
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bMaxBurst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_endpoint_companion_descriptor>())).bmAttributes
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_endpoint_companion_descriptor>())).wBytesPerInterval
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(wBytesPerInterval)
        )
    );
}
#[doc = " \\ingroup libusb_desc"]
#[doc = " A generic representation of a BOS Device Capability descriptor. It is"]
#[doc = " advised to check bDevCapabilityType and call the matching"]
#[doc = " libusb_get_*_descriptor function to get a structure fully matching the type."]
#[repr(C)]
#[derive(Debug)]
pub struct libusb_bos_dev_capability_descriptor {
    #[doc = " Size of this descriptor (in bytes)"]
    pub bLength: u8,
    #[doc = " Descriptor type. Will have value"]
    #[doc = " \\ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY"]
    #[doc = " LIBUSB_DT_DEVICE_CAPABILITY in this context."]
    pub bDescriptorType: u8,
    #[doc = " Device Capability type"]
    pub bDevCapabilityType: u8,
    #[doc = " Device Capability data (bLength - 3 bytes)"]
    pub dev_capability_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_libusb_bos_dev_capability_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<libusb_bos_dev_capability_descriptor>(),
        3usize,
        concat!(
            "Size of: ",
            stringify!(libusb_bos_dev_capability_descriptor)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_bos_dev_capability_descriptor>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(libusb_bos_dev_capability_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_bos_dev_capability_descriptor>())).bLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_bos_dev_capability_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_bos_dev_capability_descriptor>())).bDescriptorType
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_bos_dev_capability_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_bos_dev_capability_descriptor>())).bDevCapabilityType
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_bos_dev_capability_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_bos_dev_capability_descriptor>())).dev_capability_data
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_bos_dev_capability_descriptor),
            "::",
            stringify!(dev_capability_data)
        )
    );
}
#[doc = " \\ingroup libusb_desc"]
#[doc = " A structure representing the Binary Device Object Store (BOS) descriptor."]
#[doc = " This descriptor is documented in section 9.6.2 of the USB 3.0 specification."]
#[doc = " All multiple-byte fields are represented in host-endian format."]
#[repr(C)]
#[derive(Debug)]
pub struct libusb_bos_descriptor {
    #[doc = " Size of this descriptor (in bytes)"]
    pub bLength: u8,
    #[doc = " Descriptor type. Will have value"]
    #[doc = " \\ref libusb_descriptor_type::LIBUSB_DT_BOS LIBUSB_DT_BOS"]
    #[doc = " in this context."]
    pub bDescriptorType: u8,
    #[doc = " Length of this descriptor and all of its sub descriptors"]
    pub wTotalLength: u16,
    #[doc = " The number of separate device capability descriptors in"]
    #[doc = " the BOS"]
    pub bNumDeviceCaps: u8,
    #[doc = " bNumDeviceCap Device Capability Descriptors"]
    pub dev_capability: __IncompleteArrayField<*mut libusb_bos_dev_capability_descriptor>,
}
#[test]
fn bindgen_test_layout_libusb_bos_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<libusb_bos_descriptor>(),
        8usize,
        concat!("Size of: ", stringify!(libusb_bos_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_bos_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(libusb_bos_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_bos_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_bos_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_bos_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_bos_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_bos_descriptor>())).wTotalLength as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_bos_descriptor),
            "::",
            stringify!(wTotalLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_bos_descriptor>())).bNumDeviceCaps as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_bos_descriptor),
            "::",
            stringify!(bNumDeviceCaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_bos_descriptor>())).dev_capability as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_bos_descriptor),
            "::",
            stringify!(dev_capability)
        )
    );
}
#[doc = " \\ingroup libusb_desc"]
#[doc = " A structure representing the USB 2.0 Extension descriptor"]
#[doc = " This descriptor is documented in section 9.6.2.1 of the USB 3.0 specification."]
#[doc = " All multiple-byte fields are represented in host-endian format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_usb_2_0_extension_descriptor {
    #[doc = " Size of this descriptor (in bytes)"]
    pub bLength: u8,
    #[doc = " Descriptor type. Will have value"]
    #[doc = " \\ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY"]
    #[doc = " LIBUSB_DT_DEVICE_CAPABILITY in this context."]
    pub bDescriptorType: u8,
    #[doc = " Capability type. Will have value"]
    #[doc = " \\ref libusb_capability_type::LIBUSB_BT_USB_2_0_EXTENSION"]
    #[doc = " LIBUSB_BT_USB_2_0_EXTENSION in this context."]
    pub bDevCapabilityType: u8,
    #[doc = " Bitmap encoding of supported device level features."]
    #[doc = " A value of one in a bit location indicates a feature is"]
    #[doc = " supported; a value of zero indicates it is not supported."]
    #[doc = " See \\ref libusb_usb_2_0_extension_attributes."]
    pub bmAttributes: u32,
}
#[test]
fn bindgen_test_layout_libusb_usb_2_0_extension_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<libusb_usb_2_0_extension_descriptor>(),
        8usize,
        concat!("Size of: ", stringify!(libusb_usb_2_0_extension_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_usb_2_0_extension_descriptor>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(libusb_usb_2_0_extension_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_usb_2_0_extension_descriptor>())).bLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_usb_2_0_extension_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_usb_2_0_extension_descriptor>())).bDescriptorType
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_usb_2_0_extension_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_usb_2_0_extension_descriptor>())).bDevCapabilityType
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_usb_2_0_extension_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_usb_2_0_extension_descriptor>())).bmAttributes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_usb_2_0_extension_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
}
#[doc = " \\ingroup libusb_desc"]
#[doc = " A structure representing the SuperSpeed USB Device Capability descriptor"]
#[doc = " This descriptor is documented in section 9.6.2.2 of the USB 3.0 specification."]
#[doc = " All multiple-byte fields are represented in host-endian format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_ss_usb_device_capability_descriptor {
    #[doc = " Size of this descriptor (in bytes)"]
    pub bLength: u8,
    #[doc = " Descriptor type. Will have value"]
    #[doc = " \\ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY"]
    #[doc = " LIBUSB_DT_DEVICE_CAPABILITY in this context."]
    pub bDescriptorType: u8,
    #[doc = " Capability type. Will have value"]
    #[doc = " \\ref libusb_capability_type::LIBUSB_BT_SS_USB_DEVICE_CAPABILITY"]
    #[doc = " LIBUSB_BT_SS_USB_DEVICE_CAPABILITY in this context."]
    pub bDevCapabilityType: u8,
    #[doc = " Bitmap encoding of supported device level features."]
    #[doc = " A value of one in a bit location indicates a feature is"]
    #[doc = " supported; a value of zero indicates it is not supported."]
    #[doc = " See \\ref libusb_ss_usb_device_capability_attributes."]
    pub bmAttributes: u8,
    #[doc = " Bitmap encoding of the speed supported by this device when"]
    #[doc = " operating in SuperSpeed mode. See \\ref libusb_supported_speed."]
    pub wSpeedSupported: u16,
    #[doc = " The lowest speed at which all the functionality supported"]
    #[doc = " by the device is available to the user. For example if the"]
    #[doc = " device supports all its functionality when connected at"]
    #[doc = " full speed and above then it sets this value to 1."]
    pub bFunctionalitySupport: u8,
    #[doc = " U1 Device Exit Latency."]
    pub bU1DevExitLat: u8,
    #[doc = " U2 Device Exit Latency."]
    pub bU2DevExitLat: u16,
}
#[test]
fn bindgen_test_layout_libusb_ss_usb_device_capability_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<libusb_ss_usb_device_capability_descriptor>(),
        10usize,
        concat!(
            "Size of: ",
            stringify!(libusb_ss_usb_device_capability_descriptor)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_ss_usb_device_capability_descriptor>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(libusb_ss_usb_device_capability_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_usb_device_capability_descriptor>())).bLength
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_usb_device_capability_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_usb_device_capability_descriptor>())).bDescriptorType
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_usb_device_capability_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_usb_device_capability_descriptor>()))
                .bDevCapabilityType as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_usb_device_capability_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_usb_device_capability_descriptor>())).bmAttributes
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_usb_device_capability_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_usb_device_capability_descriptor>())).wSpeedSupported
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_usb_device_capability_descriptor),
            "::",
            stringify!(wSpeedSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_usb_device_capability_descriptor>()))
                .bFunctionalitySupport as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_usb_device_capability_descriptor),
            "::",
            stringify!(bFunctionalitySupport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_usb_device_capability_descriptor>())).bU1DevExitLat
                as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_usb_device_capability_descriptor),
            "::",
            stringify!(bU1DevExitLat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_ss_usb_device_capability_descriptor>())).bU2DevExitLat
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_ss_usb_device_capability_descriptor),
            "::",
            stringify!(bU2DevExitLat)
        )
    );
}
#[doc = " \\ingroup libusb_desc"]
#[doc = " A structure representing the Container ID descriptor."]
#[doc = " This descriptor is documented in section 9.6.2.3 of the USB 3.0 specification."]
#[doc = " All multiple-byte fields, except UUIDs, are represented in host-endian format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_container_id_descriptor {
    #[doc = " Size of this descriptor (in bytes)"]
    pub bLength: u8,
    #[doc = " Descriptor type. Will have value"]
    #[doc = " \\ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY"]
    #[doc = " LIBUSB_DT_DEVICE_CAPABILITY in this context."]
    pub bDescriptorType: u8,
    #[doc = " Capability type. Will have value"]
    #[doc = " \\ref libusb_capability_type::LIBUSB_BT_CONTAINER_ID"]
    #[doc = " LIBUSB_BT_CONTAINER_ID in this context."]
    pub bDevCapabilityType: u8,
    #[doc = " Reserved field"]
    pub bReserved: u8,
    #[doc = " 128 bit UUID"]
    pub ContainerID: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_libusb_container_id_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<libusb_container_id_descriptor>(),
        20usize,
        concat!("Size of: ", stringify!(libusb_container_id_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_container_id_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(libusb_container_id_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_container_id_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_container_id_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_container_id_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_container_id_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_container_id_descriptor>())).bDevCapabilityType
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_container_id_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_container_id_descriptor>())).bReserved as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_container_id_descriptor),
            "::",
            stringify!(bReserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_container_id_descriptor>())).ContainerID as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_container_id_descriptor),
            "::",
            stringify!(ContainerID)
        )
    );
}
#[doc = " \\ingroup libusb_asyncio"]
#[doc = " Setup packet for control transfers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_control_setup {
    #[doc = " Request type. Bits 0:4 determine recipient, see"]
    #[doc = " \\ref libusb_request_recipient. Bits 5:6 determine type, see"]
    #[doc = " \\ref libusb_request_type. Bit 7 determines data transfer direction, see"]
    #[doc = " \\ref libusb_endpoint_direction."]
    pub bmRequestType: u8,
    #[doc = " Request. If the type bits of bmRequestType are equal to"]
    #[doc = " \\ref libusb_request_type::LIBUSB_REQUEST_TYPE_STANDARD"]
    #[doc = " \"LIBUSB_REQUEST_TYPE_STANDARD\" then this field refers to"]
    #[doc = " \\ref libusb_standard_request. For other cases, use of this field is"]
    #[doc = " application-specific."]
    pub bRequest: u8,
    #[doc = " Value. Varies according to request"]
    pub wValue: u16,
    #[doc = " Index. Varies according to request, typically used to pass an index"]
    #[doc = " or offset"]
    pub wIndex: u16,
    #[doc = " Number of bytes to transfer"]
    pub wLength: u16,
}
#[test]
fn bindgen_test_layout_libusb_control_setup() {
    assert_eq!(
        ::std::mem::size_of::<libusb_control_setup>(),
        8usize,
        concat!("Size of: ", stringify!(libusb_control_setup))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_control_setup>(),
        2usize,
        concat!("Alignment of ", stringify!(libusb_control_setup))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_control_setup>())).bmRequestType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_control_setup),
            "::",
            stringify!(bmRequestType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_control_setup>())).bRequest as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_control_setup),
            "::",
            stringify!(bRequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_control_setup>())).wValue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_control_setup),
            "::",
            stringify!(wValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_control_setup>())).wIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_control_setup),
            "::",
            stringify!(wIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_control_setup>())).wLength as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_control_setup),
            "::",
            stringify!(wLength)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_device_handle {
    _unused: [u8; 0],
}
#[doc = " \\ingroup libusb_lib"]
#[doc = " Structure providing the version of the libusb runtime"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_version {
    #[doc = " Library major version."]
    pub major: u16,
    #[doc = " Library minor version."]
    pub minor: u16,
    #[doc = " Library micro version."]
    pub micro: u16,
    #[doc = " Library nano version."]
    pub nano: u16,
    #[doc = " Library release candidate suffix string, e.g. \"-rc4\"."]
    pub rc: *const ::std::os::raw::c_char,
    #[doc = " For ABI compatibility only."]
    pub describe: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_libusb_version() {
    assert_eq!(
        ::std::mem::size_of::<libusb_version>(),
        24usize,
        concat!("Size of: ", stringify!(libusb_version))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_version>(),
        8usize,
        concat!("Alignment of ", stringify!(libusb_version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_version>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_version>())).minor as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_version>())).micro as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_version),
            "::",
            stringify!(micro)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_version>())).nano as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_version),
            "::",
            stringify!(nano)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_version>())).rc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_version),
            "::",
            stringify!(rc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_version>())).describe as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_version),
            "::",
            stringify!(describe)
        )
    );
}
#[doc = " The OS doesn't report or know the device speed."]
pub const libusb_speed_LIBUSB_SPEED_UNKNOWN: libusb_speed = 0;
#[doc = " The device is operating at low speed (1.5MBit/s)."]
pub const libusb_speed_LIBUSB_SPEED_LOW: libusb_speed = 1;
#[doc = " The device is operating at full speed (12MBit/s)."]
pub const libusb_speed_LIBUSB_SPEED_FULL: libusb_speed = 2;
#[doc = " The device is operating at high speed (480MBit/s)."]
pub const libusb_speed_LIBUSB_SPEED_HIGH: libusb_speed = 3;
#[doc = " The device is operating at super speed (5000MBit/s)."]
pub const libusb_speed_LIBUSB_SPEED_SUPER: libusb_speed = 4;
#[doc = " \\ingroup libusb_dev"]
#[doc = " Speed codes. Indicates the speed at which the device is operating."]
pub type libusb_speed = ::std::os::raw::c_uint;
#[doc = " Low speed operation supported (1.5MBit/s)."]
pub const libusb_supported_speed_LIBUSB_LOW_SPEED_OPERATION: libusb_supported_speed = 1;
#[doc = " Full speed operation supported (12MBit/s)."]
pub const libusb_supported_speed_LIBUSB_FULL_SPEED_OPERATION: libusb_supported_speed = 2;
#[doc = " High speed operation supported (480MBit/s)."]
pub const libusb_supported_speed_LIBUSB_HIGH_SPEED_OPERATION: libusb_supported_speed = 4;
#[doc = " Superspeed operation supported (5000MBit/s)."]
pub const libusb_supported_speed_LIBUSB_SUPER_SPEED_OPERATION: libusb_supported_speed = 8;
#[doc = " \\ingroup libusb_dev"]
#[doc = " Supported speeds (wSpeedSupported) bitfield. Indicates what"]
#[doc = " speeds the device supports."]
pub type libusb_supported_speed = ::std::os::raw::c_uint;
#[doc = " Supports Link Power Management (LPM)"]
pub const libusb_usb_2_0_extension_attributes_LIBUSB_BM_LPM_SUPPORT:
    libusb_usb_2_0_extension_attributes = 2;
#[doc = " \\ingroup libusb_dev"]
#[doc = " Masks for the bits of the"]
#[doc = " \\ref libusb_usb_2_0_extension_descriptor::bmAttributes \"bmAttributes\" field"]
#[doc = " of the USB 2.0 Extension descriptor."]
pub type libusb_usb_2_0_extension_attributes = ::std::os::raw::c_uint;
#[doc = " Supports Latency Tolerance Messages (LTM)"]
pub const libusb_ss_usb_device_capability_attributes_LIBUSB_BM_LTM_SUPPORT:
    libusb_ss_usb_device_capability_attributes = 2;
#[doc = " \\ingroup libusb_dev"]
#[doc = " Masks for the bits of the"]
#[doc = " \\ref libusb_ss_usb_device_capability_descriptor::bmAttributes \"bmAttributes\" field"]
#[doc = " field of the SuperSpeed USB Device Capability descriptor."]
pub type libusb_ss_usb_device_capability_attributes = ::std::os::raw::c_uint;
#[doc = " Wireless USB device capability"]
pub const libusb_bos_type_LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY: libusb_bos_type = 1;
#[doc = " USB 2.0 extensions"]
pub const libusb_bos_type_LIBUSB_BT_USB_2_0_EXTENSION: libusb_bos_type = 2;
#[doc = " SuperSpeed USB device capability"]
pub const libusb_bos_type_LIBUSB_BT_SS_USB_DEVICE_CAPABILITY: libusb_bos_type = 3;
#[doc = " Container ID type"]
pub const libusb_bos_type_LIBUSB_BT_CONTAINER_ID: libusb_bos_type = 4;
#[doc = " \\ingroup libusb_dev"]
#[doc = " USB capability types"]
pub type libusb_bos_type = ::std::os::raw::c_uint;
#[doc = " Success (no error)"]
pub const libusb_error_LIBUSB_SUCCESS: libusb_error = 0;
#[doc = " Input/output error"]
pub const libusb_error_LIBUSB_ERROR_IO: libusb_error = -1;
#[doc = " Invalid parameter"]
pub const libusb_error_LIBUSB_ERROR_INVALID_PARAM: libusb_error = -2;
#[doc = " Access denied (insufficient permissions)"]
pub const libusb_error_LIBUSB_ERROR_ACCESS: libusb_error = -3;
#[doc = " No such device (it may have been disconnected)"]
pub const libusb_error_LIBUSB_ERROR_NO_DEVICE: libusb_error = -4;
#[doc = " Entity not found"]
pub const libusb_error_LIBUSB_ERROR_NOT_FOUND: libusb_error = -5;
#[doc = " Resource busy"]
pub const libusb_error_LIBUSB_ERROR_BUSY: libusb_error = -6;
#[doc = " Operation timed out"]
pub const libusb_error_LIBUSB_ERROR_TIMEOUT: libusb_error = -7;
#[doc = " Overflow"]
pub const libusb_error_LIBUSB_ERROR_OVERFLOW: libusb_error = -8;
#[doc = " Pipe error"]
pub const libusb_error_LIBUSB_ERROR_PIPE: libusb_error = -9;
#[doc = " System call interrupted (perhaps due to signal)"]
pub const libusb_error_LIBUSB_ERROR_INTERRUPTED: libusb_error = -10;
#[doc = " Insufficient memory"]
pub const libusb_error_LIBUSB_ERROR_NO_MEM: libusb_error = -11;
#[doc = " Operation not supported or unimplemented on this platform"]
pub const libusb_error_LIBUSB_ERROR_NOT_SUPPORTED: libusb_error = -12;
#[doc = " Other error"]
pub const libusb_error_LIBUSB_ERROR_OTHER: libusb_error = -99;
#[doc = " \\ingroup libusb_misc"]
#[doc = " Error codes. Most libusb functions return 0 on success or one of these"]
#[doc = " codes on failure."]
#[doc = " You can call libusb_error_name() to retrieve a string representation of an"]
#[doc = " error code or libusb_strerror() to get an end-user suitable description of"]
#[doc = " an error code."]
pub type libusb_error = ::std::os::raw::c_int;
#[doc = " Transfer completed without error. Note that this does not indicate"]
#[doc = " that the entire amount of requested data was transferred."]
pub const libusb_transfer_status_LIBUSB_TRANSFER_COMPLETED: libusb_transfer_status = 0;
#[doc = " Transfer failed"]
pub const libusb_transfer_status_LIBUSB_TRANSFER_ERROR: libusb_transfer_status = 1;
#[doc = " Transfer timed out"]
pub const libusb_transfer_status_LIBUSB_TRANSFER_TIMED_OUT: libusb_transfer_status = 2;
#[doc = " Transfer was cancelled"]
pub const libusb_transfer_status_LIBUSB_TRANSFER_CANCELLED: libusb_transfer_status = 3;
#[doc = " For bulk/interrupt endpoints: halt condition detected (endpoint"]
#[doc = " stalled). For control endpoints: control request not supported."]
pub const libusb_transfer_status_LIBUSB_TRANSFER_STALL: libusb_transfer_status = 4;
#[doc = " Device was disconnected"]
pub const libusb_transfer_status_LIBUSB_TRANSFER_NO_DEVICE: libusb_transfer_status = 5;
#[doc = " Device sent more data than requested"]
pub const libusb_transfer_status_LIBUSB_TRANSFER_OVERFLOW: libusb_transfer_status = 6;
#[doc = " \\ingroup libusb_asyncio"]
#[doc = " Transfer status codes"]
pub type libusb_transfer_status = ::std::os::raw::c_uint;
#[doc = " Report short frames as errors"]
pub const libusb_transfer_flags_LIBUSB_TRANSFER_SHORT_NOT_OK: libusb_transfer_flags = 1;
#[doc = " Automatically free() transfer buffer during libusb_free_transfer()."]
#[doc = " Note that buffers allocated with libusb_dev_mem_alloc() should not"]
#[doc = " be attempted freed in this way, since free() is not an appropriate"]
#[doc = " way to release such memory."]
pub const libusb_transfer_flags_LIBUSB_TRANSFER_FREE_BUFFER: libusb_transfer_flags = 2;
#[doc = " Automatically call libusb_free_transfer() after callback returns."]
#[doc = " If this flag is set, it is illegal to call libusb_free_transfer()"]
#[doc = " from your transfer callback, as this will result in a double-free"]
#[doc = " when this flag is acted upon."]
pub const libusb_transfer_flags_LIBUSB_TRANSFER_FREE_TRANSFER: libusb_transfer_flags = 4;
#[doc = " Terminate transfers that are a multiple of the endpoint's"]
#[doc = " wMaxPacketSize with an extra zero length packet. This is useful"]
#[doc = " when a device protocol mandates that each logical request is"]
#[doc = " terminated by an incomplete packet (i.e. the logical requests are"]
#[doc = " not separated by other means)."]
#[doc = ""]
#[doc = " This flag only affects host-to-device transfers to bulk and interrupt"]
#[doc = " endpoints. In other situations, it is ignored."]
#[doc = ""]
#[doc = " This flag only affects transfers with a length that is a multiple of"]
#[doc = " the endpoint's wMaxPacketSize. On transfers of other lengths, this"]
#[doc = " flag has no effect. Therefore, if you are working with a device that"]
#[doc = " needs a ZLP whenever the end of the logical request falls on a packet"]
#[doc = " boundary, then it is sensible to set this flag on <em>every</em>"]
#[doc = " transfer (you do not have to worry about only setting it on transfers"]
#[doc = " that end on the boundary)."]
#[doc = ""]
#[doc = " This flag is currently only supported on Linux."]
#[doc = " On other systems, libusb_submit_transfer() will return"]
#[doc = " LIBUSB_ERROR_NOT_SUPPORTED for every transfer where this flag is set."]
#[doc = ""]
#[doc = " Available since libusb-1.0.9."]
pub const libusb_transfer_flags_LIBUSB_TRANSFER_ADD_ZERO_PACKET: libusb_transfer_flags = 8;
#[doc = " \\ingroup libusb_asyncio"]
#[doc = " libusb_transfer.flags values"]
pub type libusb_transfer_flags = ::std::os::raw::c_uint;
#[doc = " \\ingroup libusb_asyncio"]
#[doc = " Isochronous packet descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_iso_packet_descriptor {
    #[doc = " Length of data to request in this packet"]
    pub length: ::std::os::raw::c_uint,
    #[doc = " Amount of data that was actually transferred"]
    pub actual_length: ::std::os::raw::c_uint,
    #[doc = " Status code for this packet"]
    pub status: libusb_transfer_status,
}
#[test]
fn bindgen_test_layout_libusb_iso_packet_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<libusb_iso_packet_descriptor>(),
        12usize,
        concat!("Size of: ", stringify!(libusb_iso_packet_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_iso_packet_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(libusb_iso_packet_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_iso_packet_descriptor>())).length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_iso_packet_descriptor),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_iso_packet_descriptor>())).actual_length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_iso_packet_descriptor),
            "::",
            stringify!(actual_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libusb_iso_packet_descriptor>())).status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_iso_packet_descriptor),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " \\ingroup libusb_asyncio"]
#[doc = " Asynchronous transfer callback function type. When submitting asynchronous"]
#[doc = " transfers, you pass a pointer to a callback function of this type via the"]
#[doc = " \\ref libusb_transfer::callback \"callback\" member of the libusb_transfer"]
#[doc = " structure. libusb will call this function later, when the transfer has"]
#[doc = " completed or failed. See \\ref libusb_asyncio for more information."]
#[doc = " \\param transfer The libusb_transfer struct the callback function is being"]
#[doc = " notified about."]
pub type libusb_transfer_cb_fn =
    ::std::option::Option<unsafe extern "C" fn(transfer: *mut libusb_transfer)>;
#[doc = " \\ingroup libusb_asyncio"]
#[doc = " The generic USB transfer structure. The user populates this structure and"]
#[doc = " then submits it in order to request a transfer. After the transfer has"]
#[doc = " completed, the library populates the transfer with the results and passes"]
#[doc = " it back to the user."]
#[repr(C)]
#[derive(Debug)]
pub struct libusb_transfer {
    #[doc = " Handle of the device that this transfer will be submitted to"]
    pub dev_handle: *mut libusb_device_handle,
    #[doc = " A bitwise OR combination of \\ref libusb_transfer_flags."]
    pub flags: u8,
    #[doc = " Address of the endpoint where this transfer will be sent."]
    pub endpoint: ::std::os::raw::c_uchar,
    #[doc = " Type of the endpoint from \\ref libusb_transfer_type"]
    pub type_: ::std::os::raw::c_uchar,
    #[doc = " Timeout for this transfer in millseconds. A value of 0 indicates no"]
    #[doc = " timeout."]
    pub timeout: ::std::os::raw::c_uint,
    #[doc = " The status of the transfer. Read-only, and only for use within"]
    #[doc = " transfer callback function."]
    #[doc = ""]
    #[doc = " If this is an isochronous transfer, this field may read COMPLETED even"]
    #[doc = " if there were errors in the frames. Use the"]
    #[doc = " \\ref libusb_iso_packet_descriptor::status \"status\" field in each packet"]
    #[doc = " to determine if errors occurred."]
    pub status: libusb_transfer_status,
    #[doc = " Length of the data buffer"]
    pub length: ::std::os::raw::c_int,
    #[doc = " Actual length of data that was transferred. Read-only, and only for"]
    #[doc = " use within transfer callback function. Not valid for isochronous"]
    #[doc = " endpoint transfers."]
    pub actual_length: ::std::os::raw::c_int,
    #[doc = " Callback function. This will be invoked when the transfer completes,"]
    #[doc = " fails, or is cancelled."]
    pub callback: libusb_transfer_cb_fn,
    #[doc = " User context data to pass to the callback function."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Data buffer"]
    pub buffer: *mut ::std::os::raw::c_uchar,
    #[doc = " Number of isochronous packets. Only used for I/O with isochronous"]
    #[doc = " endpoints."]
    pub num_iso_packets: ::std::os::raw::c_int,
    #[doc = " Isochronous packet descriptors, for isochronous transfers only."]
    pub iso_packet_desc: __IncompleteArrayField<libusb_iso_packet_descriptor>,
}
#[test]
fn bindgen_test_layout_libusb_transfer() {
    assert_eq!(
        ::std::mem::size_of::<libusb_transfer>(),
        64usize,
        concat!("Size of: ", stringify!(libusb_transfer))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_transfer>(),
        8usize,
        concat!("Alignment of ", stringify!(libusb_transfer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).dev_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(dev_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).endpoint as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).type_ as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).timeout as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).status as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).actual_length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(actual_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).callback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).user_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).buffer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).num_iso_packets as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(num_iso_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_transfer>())).iso_packet_desc as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_transfer),
            "::",
            stringify!(iso_packet_desc)
        )
    );
}
#[doc = " The libusb_has_capability() API is available."]
pub const libusb_capability_LIBUSB_CAP_HAS_CAPABILITY: libusb_capability = 0;
#[doc = " Hotplug support is available on this platform."]
pub const libusb_capability_LIBUSB_CAP_HAS_HOTPLUG: libusb_capability = 1;
#[doc = " The library can access HID devices without requiring user intervention."]
#[doc = " Note that before being able to actually access an HID device, you may"]
#[doc = " still have to call additional libusb functions such as"]
#[doc = " \\ref libusb_detach_kernel_driver()."]
pub const libusb_capability_LIBUSB_CAP_HAS_HID_ACCESS: libusb_capability = 256;
#[doc = " The library supports detaching of the default USB driver, using"]
#[doc = " \\ref libusb_detach_kernel_driver(), if one is set by the OS kernel"]
pub const libusb_capability_LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER: libusb_capability = 257;
#[doc = " \\ingroup libusb_misc"]
#[doc = " Capabilities supported by an instance of libusb on the current running"]
#[doc = " platform. Test if the loaded library supports a given capability by calling"]
#[doc = " \\ref libusb_has_capability()."]
pub type libusb_capability = ::std::os::raw::c_uint;
pub const libusb_log_level_LIBUSB_LOG_LEVEL_NONE: libusb_log_level = 0;
pub const libusb_log_level_LIBUSB_LOG_LEVEL_ERROR: libusb_log_level = 1;
pub const libusb_log_level_LIBUSB_LOG_LEVEL_WARNING: libusb_log_level = 2;
pub const libusb_log_level_LIBUSB_LOG_LEVEL_INFO: libusb_log_level = 3;
pub const libusb_log_level_LIBUSB_LOG_LEVEL_DEBUG: libusb_log_level = 4;
#[doc = " \\ingroup libusb_lib"]
#[doc = "  Log message levels."]
#[doc = "  - LIBUSB_LOG_LEVEL_NONE (0)    : no messages ever printed by the library (default)"]
#[doc = "  - LIBUSB_LOG_LEVEL_ERROR (1)   : error messages are printed to stderr"]
#[doc = "  - LIBUSB_LOG_LEVEL_WARNING (2) : warning and error messages are printed to stderr"]
#[doc = "  - LIBUSB_LOG_LEVEL_INFO (3)    : informational messages are printed to stdout, warning"]
#[doc = "    and error messages are printed to stderr"]
#[doc = "  - LIBUSB_LOG_LEVEL_DEBUG (4)   : debug and informational messages are printed to stdout,"]
#[doc = "    warnings and errors to stderr"]
pub type libusb_log_level = ::std::os::raw::c_uint;
extern "C" {
    pub fn libusb_init(ctx: *mut *mut libusb_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_exit(ctx: *mut libusb_context);
}
extern "C" {
    pub fn libusb_set_debug(ctx: *mut libusb_context, level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn libusb_get_version() -> *const libusb_version;
}
extern "C" {
    pub fn libusb_has_capability(capability: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_error_name(errcode: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn libusb_setlocale(locale: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_strerror(errcode: libusb_error) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn libusb_get_device_list(
        ctx: *mut libusb_context,
        list: *mut *mut *mut libusb_device,
    ) -> ssize_t;
}
extern "C" {
    pub fn libusb_free_device_list(
        list: *mut *mut libusb_device,
        unref_devices: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn libusb_ref_device(dev: *mut libusb_device) -> *mut libusb_device;
}
extern "C" {
    pub fn libusb_unref_device(dev: *mut libusb_device);
}
extern "C" {
    pub fn libusb_get_configuration(
        dev: *mut libusb_device_handle,
        config: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_get_device_descriptor(
        dev: *mut libusb_device,
        desc: *mut libusb_device_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_get_active_config_descriptor(
        dev: *mut libusb_device,
        config: *mut *mut libusb_config_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_get_config_descriptor(
        dev: *mut libusb_device,
        config_index: u8,
        config: *mut *mut libusb_config_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_get_config_descriptor_by_value(
        dev: *mut libusb_device,
        bConfigurationValue: u8,
        config: *mut *mut libusb_config_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_free_config_descriptor(config: *mut libusb_config_descriptor);
}
extern "C" {
    pub fn libusb_get_ss_endpoint_companion_descriptor(
        ctx: *mut libusb_context,
        endpoint: *const libusb_endpoint_descriptor,
        ep_comp: *mut *mut libusb_ss_endpoint_companion_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_free_ss_endpoint_companion_descriptor(
        ep_comp: *mut libusb_ss_endpoint_companion_descriptor,
    );
}
extern "C" {
    pub fn libusb_get_bos_descriptor(
        dev_handle: *mut libusb_device_handle,
        bos: *mut *mut libusb_bos_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_free_bos_descriptor(bos: *mut libusb_bos_descriptor);
}
extern "C" {
    pub fn libusb_get_usb_2_0_extension_descriptor(
        ctx: *mut libusb_context,
        dev_cap: *mut libusb_bos_dev_capability_descriptor,
        usb_2_0_extension: *mut *mut libusb_usb_2_0_extension_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_free_usb_2_0_extension_descriptor(
        usb_2_0_extension: *mut libusb_usb_2_0_extension_descriptor,
    );
}
extern "C" {
    pub fn libusb_get_ss_usb_device_capability_descriptor(
        ctx: *mut libusb_context,
        dev_cap: *mut libusb_bos_dev_capability_descriptor,
        ss_usb_device_cap: *mut *mut libusb_ss_usb_device_capability_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_free_ss_usb_device_capability_descriptor(
        ss_usb_device_cap: *mut libusb_ss_usb_device_capability_descriptor,
    );
}
extern "C" {
    pub fn libusb_get_container_id_descriptor(
        ctx: *mut libusb_context,
        dev_cap: *mut libusb_bos_dev_capability_descriptor,
        container_id: *mut *mut libusb_container_id_descriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_free_container_id_descriptor(container_id: *mut libusb_container_id_descriptor);
}
extern "C" {
    pub fn libusb_get_bus_number(dev: *mut libusb_device) -> u8;
}
extern "C" {
    pub fn libusb_get_port_number(dev: *mut libusb_device) -> u8;
}
extern "C" {
    pub fn libusb_get_port_numbers(
        dev: *mut libusb_device,
        port_numbers: *mut u8,
        port_numbers_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_get_port_path(
        ctx: *mut libusb_context,
        dev: *mut libusb_device,
        path: *mut u8,
        path_length: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_get_parent(dev: *mut libusb_device) -> *mut libusb_device;
}
extern "C" {
    pub fn libusb_get_device_address(dev: *mut libusb_device) -> u8;
}
extern "C" {
    pub fn libusb_get_device_speed(dev: *mut libusb_device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_get_max_packet_size(
        dev: *mut libusb_device,
        endpoint: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_get_max_iso_packet_size(
        dev: *mut libusb_device,
        endpoint: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_open(
        dev: *mut libusb_device,
        dev_handle: *mut *mut libusb_device_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_close(dev_handle: *mut libusb_device_handle);
}
extern "C" {
    pub fn libusb_get_device(dev_handle: *mut libusb_device_handle) -> *mut libusb_device;
}
extern "C" {
    pub fn libusb_set_configuration(
        dev_handle: *mut libusb_device_handle,
        configuration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_claim_interface(
        dev_handle: *mut libusb_device_handle,
        interface_number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_release_interface(
        dev_handle: *mut libusb_device_handle,
        interface_number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_open_device_with_vid_pid(
        ctx: *mut libusb_context,
        vendor_id: u16,
        product_id: u16,
    ) -> *mut libusb_device_handle;
}
extern "C" {
    pub fn libusb_set_interface_alt_setting(
        dev_handle: *mut libusb_device_handle,
        interface_number: ::std::os::raw::c_int,
        alternate_setting: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_clear_halt(
        dev_handle: *mut libusb_device_handle,
        endpoint: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_reset_device(dev_handle: *mut libusb_device_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_alloc_streams(
        dev_handle: *mut libusb_device_handle,
        num_streams: u32,
        endpoints: *mut ::std::os::raw::c_uchar,
        num_endpoints: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_free_streams(
        dev_handle: *mut libusb_device_handle,
        endpoints: *mut ::std::os::raw::c_uchar,
        num_endpoints: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_dev_mem_alloc(
        dev_handle: *mut libusb_device_handle,
        length: size_t,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn libusb_dev_mem_free(
        dev_handle: *mut libusb_device_handle,
        buffer: *mut ::std::os::raw::c_uchar,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_kernel_driver_active(
        dev_handle: *mut libusb_device_handle,
        interface_number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_detach_kernel_driver(
        dev_handle: *mut libusb_device_handle,
        interface_number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_attach_kernel_driver(
        dev_handle: *mut libusb_device_handle,
        interface_number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_set_auto_detach_kernel_driver(
        dev_handle: *mut libusb_device_handle,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_alloc_transfer(iso_packets: ::std::os::raw::c_int) -> *mut libusb_transfer;
}
extern "C" {
    pub fn libusb_submit_transfer(transfer: *mut libusb_transfer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_cancel_transfer(transfer: *mut libusb_transfer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_free_transfer(transfer: *mut libusb_transfer);
}
extern "C" {
    pub fn libusb_transfer_set_stream_id(transfer: *mut libusb_transfer, stream_id: u32);
}
extern "C" {
    pub fn libusb_transfer_get_stream_id(transfer: *mut libusb_transfer) -> u32;
}
extern "C" {
    pub fn libusb_control_transfer(
        dev_handle: *mut libusb_device_handle,
        request_type: u8,
        bRequest: u8,
        wValue: u16,
        wIndex: u16,
        data: *mut ::std::os::raw::c_uchar,
        wLength: u16,
        timeout: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_bulk_transfer(
        dev_handle: *mut libusb_device_handle,
        endpoint: ::std::os::raw::c_uchar,
        data: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
        actual_length: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_interrupt_transfer(
        dev_handle: *mut libusb_device_handle,
        endpoint: ::std::os::raw::c_uchar,
        data: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
        actual_length: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_get_string_descriptor_ascii(
        dev_handle: *mut libusb_device_handle,
        desc_index: u8,
        data: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_try_lock_events(ctx: *mut libusb_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_lock_events(ctx: *mut libusb_context);
}
extern "C" {
    pub fn libusb_unlock_events(ctx: *mut libusb_context);
}
extern "C" {
    pub fn libusb_event_handling_ok(ctx: *mut libusb_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_event_handler_active(ctx: *mut libusb_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_interrupt_event_handler(ctx: *mut libusb_context);
}
extern "C" {
    pub fn libusb_lock_event_waiters(ctx: *mut libusb_context);
}
extern "C" {
    pub fn libusb_unlock_event_waiters(ctx: *mut libusb_context);
}
extern "C" {
    pub fn libusb_wait_for_event(
        ctx: *mut libusb_context,
        tv: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_handle_events_timeout(
        ctx: *mut libusb_context,
        tv: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_handle_events_timeout_completed(
        ctx: *mut libusb_context,
        tv: *mut timeval,
        completed: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_handle_events(ctx: *mut libusb_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_handle_events_completed(
        ctx: *mut libusb_context,
        completed: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_handle_events_locked(
        ctx: *mut libusb_context,
        tv: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_pollfds_handle_timeouts(ctx: *mut libusb_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libusb_get_next_timeout(
        ctx: *mut libusb_context,
        tv: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\ingroup libusb_poll"]
#[doc = " File descriptor for polling"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libusb_pollfd {
    #[doc = " Numeric file descriptor"]
    pub fd: ::std::os::raw::c_int,
    #[doc = " Event flags to poll for from <poll.h>. POLLIN indicates that you"]
    #[doc = " should monitor this file descriptor for becoming ready to read from,"]
    #[doc = " and POLLOUT indicates that you should monitor this file descriptor for"]
    #[doc = " nonblocking write readiness."]
    pub events: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_libusb_pollfd() {
    assert_eq!(
        ::std::mem::size_of::<libusb_pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(libusb_pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<libusb_pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(libusb_pollfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_pollfd>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_pollfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libusb_pollfd>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libusb_pollfd),
            "::",
            stringify!(events)
        )
    );
}
#[doc = " \\ingroup libusb_poll"]
#[doc = " Callback function, invoked when a new file descriptor should be added"]
#[doc = " to the set of file descriptors monitored for events."]
#[doc = " \\param fd the new file descriptor"]
#[doc = " \\param events events to monitor for, see \\ref libusb_pollfd for a"]
#[doc = " description"]
#[doc = " \\param user_data User data pointer specified in"]
#[doc = " libusb_set_pollfd_notifiers() call"]
#[doc = " \\see libusb_set_pollfd_notifiers()"]
pub type libusb_pollfd_added_cb = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        events: ::std::os::raw::c_short,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " \\ingroup libusb_poll"]
#[doc = " Callback function, invoked when a file descriptor should be removed from"]
#[doc = " the set of file descriptors being monitored for events. After returning"]
#[doc = " from this callback, do not use that file descriptor again."]
#[doc = " \\param fd the file descriptor to stop monitoring"]
#[doc = " \\param user_data User data pointer specified in"]
#[doc = " libusb_set_pollfd_notifiers() call"]
#[doc = " \\see libusb_set_pollfd_notifiers()"]
pub type libusb_pollfd_removed_cb = ::std::option::Option<
    unsafe extern "C" fn(fd: ::std::os::raw::c_int, user_data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn libusb_get_pollfds(ctx: *mut libusb_context) -> *mut *const libusb_pollfd;
}
extern "C" {
    pub fn libusb_free_pollfds(pollfds: *mut *const libusb_pollfd);
}
extern "C" {
    pub fn libusb_set_pollfd_notifiers(
        ctx: *mut libusb_context,
        added_cb: libusb_pollfd_added_cb,
        removed_cb: libusb_pollfd_removed_cb,
        user_data: *mut ::std::os::raw::c_void,
    );
}
#[doc = " \\ingroup libusb_hotplug"]
#[doc = " Callback handle."]
#[doc = ""]
#[doc = " Callbacks handles are generated by libusb_hotplug_register_callback()"]
#[doc = " and can be used to deregister callbacks. Callback handles are unique"]
#[doc = " per libusb_context and it is safe to call libusb_hotplug_deregister_callback()"]
#[doc = " on an already deregisted callback."]
#[doc = ""]
#[doc = " Since version 1.0.16, \\ref LIBUSB_API_VERSION >= 0x01000102"]
#[doc = ""]
#[doc = " For more information, see \\ref libusb_hotplug."]
pub type libusb_hotplug_callback_handle = ::std::os::raw::c_int;
#[doc = " Default value when not using any flags."]
pub const libusb_hotplug_flag_LIBUSB_HOTPLUG_NO_FLAGS: libusb_hotplug_flag = 0;
#[doc = " Arm the callback and fire it for all matching currently attached devices."]
pub const libusb_hotplug_flag_LIBUSB_HOTPLUG_ENUMERATE: libusb_hotplug_flag = 1;
#[doc = " \\ingroup libusb_hotplug"]
#[doc = ""]
#[doc = " Since version 1.0.16, \\ref LIBUSB_API_VERSION >= 0x01000102"]
#[doc = ""]
#[doc = " Flags for hotplug events"]
pub type libusb_hotplug_flag = ::std::os::raw::c_uint;
#[doc = " A device has been plugged in and is ready to use"]
pub const libusb_hotplug_event_LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED: libusb_hotplug_event = 1;
#[doc = " A device has left and is no longer available."]
#[doc = " It is the user's responsibility to call libusb_close on any handle associated with a disconnected device."]
#[doc = " It is safe to call libusb_get_device_descriptor on a device that has left"]
pub const libusb_hotplug_event_LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT: libusb_hotplug_event = 2;
#[doc = " \\ingroup libusb_hotplug"]
#[doc = ""]
#[doc = " Since version 1.0.16, \\ref LIBUSB_API_VERSION >= 0x01000102"]
#[doc = ""]
#[doc = " Hotplug events"]
pub type libusb_hotplug_event = ::std::os::raw::c_uint;
#[doc = " \\ingroup libusb_hotplug"]
#[doc = " Hotplug callback function type. When requesting hotplug event notifications,"]
#[doc = " you pass a pointer to a callback function of this type."]
#[doc = ""]
#[doc = " This callback may be called by an internal event thread and as such it is"]
#[doc = " recommended the callback do minimal processing before returning."]
#[doc = ""]
#[doc = " libusb will call this function later, when a matching event had happened on"]
#[doc = " a matching device. See \\ref libusb_hotplug for more information."]
#[doc = ""]
#[doc = " It is safe to call either libusb_hotplug_register_callback() or"]
#[doc = " libusb_hotplug_deregister_callback() from within a callback function."]
#[doc = ""]
#[doc = " Since version 1.0.16, \\ref LIBUSB_API_VERSION >= 0x01000102"]
#[doc = ""]
#[doc = " \\param ctx            context of this notification"]
#[doc = " \\param device         libusb_device this event occurred on"]
#[doc = " \\param event          event that occurred"]
#[doc = " \\param user_data      user data provided when this callback was registered"]
#[doc = " \\returns bool whether this callback is finished processing events."]
#[doc = "                       returning 1 will cause this callback to be deregistered"]
pub type libusb_hotplug_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut libusb_context,
        device: *mut libusb_device,
        event: libusb_hotplug_event,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " \\ingroup libusb_hotplug"]
    #[doc = " Register a hotplug callback function"]
    #[doc = ""]
    #[doc = " Register a callback with the libusb_context. The callback will fire"]
    #[doc = " when a matching event occurs on a matching device. The callback is"]
    #[doc = " armed until either it is deregistered with libusb_hotplug_deregister_callback()"]
    #[doc = " or the supplied callback returns 1 to indicate it is finished processing events."]
    #[doc = ""]
    #[doc = " If the \\ref LIBUSB_HOTPLUG_ENUMERATE is passed the callback will be"]
    #[doc = " called with a \\ref LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED for all devices"]
    #[doc = " already plugged into the machine. Note that libusb modifies its internal"]
    #[doc = " device list from a separate thread, while calling hotplug callbacks from"]
    #[doc = " libusb_handle_events(), so it is possible for a device to already be present"]
    #[doc = " on, or removed from, its internal device list, while the hotplug callbacks"]
    #[doc = " still need to be dispatched. This means that when using \\ref"]
    #[doc = " LIBUSB_HOTPLUG_ENUMERATE, your callback may be called twice for the arrival"]
    #[doc = " of the same device, once from libusb_hotplug_register_callback() and once"]
    #[doc = " from libusb_handle_events(); and/or your callback may be called for the"]
    #[doc = " removal of a device for which an arrived call was never made."]
    #[doc = ""]
    #[doc = " Since version 1.0.16, \\ref LIBUSB_API_VERSION >= 0x01000102"]
    #[doc = ""]
    #[doc = " \\param[in] ctx context to register this callback with"]
    #[doc = " \\param[in] events bitwise or of events that will trigger this callback. See \\ref"]
    #[doc = "            libusb_hotplug_event"]
    #[doc = " \\param[in] flags hotplug callback flags. See \\ref libusb_hotplug_flag"]
    #[doc = " \\param[in] vendor_id the vendor id to match or \\ref LIBUSB_HOTPLUG_MATCH_ANY"]
    #[doc = " \\param[in] product_id the product id to match or \\ref LIBUSB_HOTPLUG_MATCH_ANY"]
    #[doc = " \\param[in] dev_class the device class to match or \\ref LIBUSB_HOTPLUG_MATCH_ANY"]
    #[doc = " \\param[in] cb_fn the function to be invoked on a matching event/device"]
    #[doc = " \\param[in] user_data user data to pass to the callback function"]
    #[doc = " \\param[out] callback_handle pointer to store the handle of the allocated callback (can be NULL)"]
    #[doc = " \\returns LIBUSB_SUCCESS on success LIBUSB_ERROR code on failure"]
    pub fn libusb_hotplug_register_callback(
        ctx: *mut libusb_context,
        events: libusb_hotplug_event,
        flags: libusb_hotplug_flag,
        vendor_id: ::std::os::raw::c_int,
        product_id: ::std::os::raw::c_int,
        dev_class: ::std::os::raw::c_int,
        cb_fn: libusb_hotplug_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
        callback_handle: *mut libusb_hotplug_callback_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\ingroup libusb_hotplug"]
    #[doc = " Deregisters a hotplug callback."]
    #[doc = ""]
    #[doc = " Deregister a callback from a libusb_context. This function is safe to call from within"]
    #[doc = " a hotplug callback."]
    #[doc = ""]
    #[doc = " Since version 1.0.16, \\ref LIBUSB_API_VERSION >= 0x01000102"]
    #[doc = ""]
    #[doc = " \\param[in] ctx context this callback is registered with"]
    #[doc = " \\param[in] callback_handle the handle of the callback to deregister"]
    pub fn libusb_hotplug_deregister_callback(
        ctx: *mut libusb_context,
        callback_handle: libusb_hotplug_callback_handle,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
