/* automatically generated by rust-bindgen 0.57.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const LKL_CONFIG_CC_HAS_SANCOV_TRACE_PC: u32 = 1;
pub const LKL_CONFIG_DEFAULT_INIT: &'static [u8; 1usize] = b"\0";
pub const LKL_CONFIG_CRC32: u32 = 1;
pub const LKL_CONFIG_SET_FS: u32 = 1;
pub const LKL_CONFIG_HIGH_RES_TIMERS: u32 = 1;
pub const LKL_CONFIG_NETWORK_FILESYSTEMS: u32 = 1;
pub const LKL_CONFIG_INLINE_WRITE_UNLOCK_IRQ: u32 = 1;
pub const LKL_CONFIG_SSB_POSSIBLE: u32 = 1;
pub const LKL_CONFIG_USB_OHCI_LITTLE_ENDIAN: u32 = 1;
pub const LKL_CONFIG_CRYPTO_MANAGER_DISABLE_TESTS: u32 = 1;
pub const LKL_CONFIG_DEFAULT_SECURITY_DAC: u32 = 1;
pub const LKL_CONFIG_LDISC_AUTOLOAD: u32 = 1;
pub const LKL_CONFIG_IPV6: u32 = 1;
pub const LKL_CONFIG_BQL: u32 = 1;
pub const LKL_CONFIG_DEFAULT_TCP_CONG: &'static [u8; 6usize] = b"cubic\0";
pub const LKL_CONFIG_LEGACY_PTYS: u32 = 1;
pub const LKL_CONFIG_CRYPTO_RNG2: u32 = 1;
pub const LKL_CONFIG_DQL: u32 = 1;
pub const LKL_CONFIG_BCMA_POSSIBLE: u32 = 1;
pub const LKL_CONFIG_PRINTK: u32 = 1;
pub const LKL_CONFIG_CRYPTO_LIB_CHACHA_GENERIC: u32 = 1;
pub const LKL_CONFIG_BUILD_SALT: &'static [u8; 1usize] = b"\0";
pub const LKL_CONFIG_GENERIC_NET_UTILS: u32 = 1;
pub const LKL_CONFIG_CEPH_LIB: u32 = 1;
pub const LKL_CONFIG_EXPORTFS: u32 = 1;
pub const LKL_CONFIG_SERIO: u32 = 1;
pub const LKL_CONFIG_HWMON: u32 = 1;
pub const LKL_CONFIG_IP_PNP: u32 = 1;
pub const LKL_CONFIG_OUTPUT_FORMAT: &'static [u8; 13usize] = b"elf64-x86-64\0";
pub const LKL_CONFIG_CRYPTO_LIB_AES: u32 = 1;
pub const LKL_CONFIG_CRYPTO_KPP2: u32 = 1;
pub const LKL_CONFIG_NET_UDP_TUNNEL: u32 = 1;
pub const LKL_CONFIG_NO_HZ_IDLE: u32 = 1;
pub const LKL_CONFIG_STANDALONE: u32 = 1;
pub const LKL_CONFIG_BLOCK: u32 = 1;
pub const LKL_CONFIG_INIT_ENV_ARG_LIMIT: u32 = 32;
pub const LKL_CONFIG_BUG: u32 = 1;
pub const LKL_CONFIG_NET_FAILOVER: u32 = 1;
pub const LKL_CONFIG_IO_URING: u32 = 1;
pub const LKL_CONFIG_SPLIT_PTLOCK_CPUS: u32 = 999999;
pub const LKL_CONFIG_SBITMAP: u32 = 1;
pub const LKL_CONFIG_CRYPTO_SKCIPHER2: u32 = 1;
pub const LKL_CONFIG_IRQ_WORK: u32 = 1;
pub const LKL_CONFIG_BLK_MQ_PCI: u32 = 1;
pub const LKL_CONFIG_CRYPTO_LIB_CURVE25519: u32 = 1;
pub const LKL_CONFIG_NOMMU_INITIAL_TRIM_EXCESS: u32 = 1;
pub const LKL_CONFIG_NETDEVICES: u32 = 1;
pub const LKL_CONFIG_EVENTFD: u32 = 1;
pub const LKL_CONFIG_FS_POSIX_ACL: u32 = 1;
pub const LKL_CONFIG_IPV6_SIT: u32 = 1;
pub const LKL_CONFIG_BPF: u32 = 1;
pub const LKL_CONFIG_CC_HAS_ASM_INLINE: u32 = 1;
pub const LKL_CONFIG_PGTABLE_LEVELS: u32 = 2;
pub const LKL_CONFIG_INET_TUNNEL: u32 = 1;
pub const LKL_CONFIG_GENERIC_CLOCKEVENTS: u32 = 1;
pub const LKL_CONFIG_ETHTOOL_NETLINK: u32 = 1;
pub const LKL_CONFIG_PCIE_BUS_DEFAULT: u32 = 1;
pub const LKL_CONFIG_CRYPTO_RNG: u32 = 1;
pub const LKL_CONFIG_ALLOW_DEV_COREDUMP: u32 = 1;
pub const LKL_CONFIG_GRO_CELLS: u32 = 1;
pub const LKL_CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN: u32 = 1;
pub const LKL_CONFIG_INIT_STACK_NONE: u32 = 1;
pub const LKL_CONFIG_NO_GENERIC_PCI_IOPORT_MAP: u32 = 1;
pub const LKL_CONFIG_KEYS: u32 = 1;
pub const LKL_CONFIG_CRYPTO_HW: u32 = 1;
pub const LKL_CONFIG_CRYPTO_SKCIPHER: u32 = 1;
pub const LKL_CONFIG_CONSOLE_LOGLEVEL_QUIET: u32 = 4;
pub const LKL_CONFIG_BROKEN_ON_SMP: u32 = 1;
pub const LKL_CONFIG_IP_PNP_DHCP: u32 = 1;
pub const LKL_CONFIG_CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const LKL_CONFIG_CRYPTO_LIB_POLY1305: u32 = 1;
pub const LKL_CONFIG_SLUB_DEBUG: u32 = 1;
pub const LKL_CONFIG_IPV6_NDISC_NODETYPE: u32 = 1;
pub const LKL_CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT: u32 = 13;
pub const LKL_CONFIG_MQ_IOSCHED_DEADLINE: u32 = 1;
pub const LKL_CONFIG_CC_CAN_LINK: u32 = 1;
pub const LKL_CONFIG_NO_HZ_COMMON: u32 = 1;
pub const LKL_CONFIG_CRYPTO_HASH2: u32 = 1;
pub const LKL_CONFIG_DEFAULT_HOSTNAME: &'static [u8; 7usize] = b"(none)\0";
pub const LKL_CONFIG_SRCU: u32 = 1;
pub const LKL_CONFIG_MEMBARRIER: u32 = 1;
pub const LKL_CONFIG_SGL_ALLOC: u32 = 1;
pub const LKL_CONFIG_CRYPTO_ALGAPI: u32 = 1;
pub const LKL_CONFIG_CC_VERSION_TEXT: &'static [u8; 23usize] = b"gcc (SUSE Linux) 7.5.0\0";
pub const LKL_CONFIG_NET_IP_TUNNEL: u32 = 1;
pub const LKL_CONFIG_CRYPTO_HASH: u32 = 1;
pub const LKL_CONFIG_EFI_PARTITION: u32 = 1;
pub const LKL_CONFIG_LOG_BUF_SHIFT: u32 = 17;
pub const LKL_CONFIG_TINY_SRCU: u32 = 1;
pub const LKL_CONFIG_CRC32_SLICEBY8: u32 = 1;
pub const LKL_CONFIG_MULTIUSER: u32 = 1;
pub const LKL_CONFIG_CRYPTO_CBC: u32 = 1;
pub const LKL_CONFIG_CLANG_VERSION: u32 = 0;
pub const LKL_CONFIG_KALLSYMS_USE_DATA_SECTION: u32 = 1;
pub const LKL_CONFIG_CRYPTO_MANAGER2: u32 = 1;
pub const LKL_CONFIG_GENERIC_PCI_IOMAP: u32 = 1;
pub const LKL_CONFIG_SLUB: u32 = 1;
pub const LKL_CONFIG_BINFMT_SCRIPT: u32 = 1;
pub const LKL_CONFIG_FRAME_POINTER: u32 = 1;
pub const LKL_CONFIG_TICK_CPU_ACCOUNTING: u32 = 1;
pub const LKL_CONFIG_KALLSYMS: u32 = 1;
pub const LKL_CONFIG_PCI: u32 = 1;
pub const LKL_CONFIG_GENERIC_ATOMIC64: u32 = 1;
pub const LKL_CONFIG_PCI_QUIRKS: u32 = 1;
pub const LKL_CONFIG_NET_CORE: u32 = 1;
pub const LKL_CONFIG_WIREGUARD: u32 = 1;
pub const LKL_CONFIG_CRYPTO_LIB_BLAKE2S: u32 = 1;
pub const LKL_CONFIG_HAS_IOMEM: u32 = 1;
pub const LKL_CONFIG_CRYPTO_ACOMP2: u32 = 1;
pub const LKL_CONFIG_EPOLL: u32 = 1;
pub const LKL_CONFIG_FAILOVER: u32 = 1;
pub const LKL_CONFIG_HAVE_NET_DSA: u32 = 1;
pub const LKL_CONFIG_NET: u32 = 1;
pub const LKL_CONFIG_CRYPTO_LIB_BLAKE2S_GENERIC: u32 = 1;
pub const LKL_CONFIG_CRYPTO_AKCIPHER2: u32 = 1;
pub const LKL_CONFIG_INET: u32 = 1;
pub const LKL_CONFIG_VIRTIO_NET: u32 = 1;
pub const LKL_CONFIG_PREVENT_FIRMWARE_BUILD: u32 = 1;
pub const LKL_CONFIG_CRYPTO_AES: u32 = 1;
pub const LKL_CONFIG_DMA_NONCOHERENT_MMAP: u32 = 1;
pub const LKL_CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR: u32 = 1;
pub const LKL_CONFIG_SERIO_SERPORT: u32 = 1;
pub const LKL_CONFIG_CRYPTO_LIB_CURVE25519_GENERIC: u32 = 1;
pub const LKL_CONFIG_ARCH_THREAD_STACK_ALLOCATOR: u32 = 1;
pub const LKL_CONFIG_PANIC_TIMEOUT: u32 = 0;
pub const LKL_CONFIG_PREEMPT_NONE: u32 = 1;
pub const LKL_CONFIG_TTY: u32 = 1;
pub const LKL_CONFIG_NEED_PER_CPU_KM: u32 = 1;
pub const LKL_CONFIG_KALLSYMS_ALL: u32 = 1;
pub const LKL_CONFIG_LIBCRC32C: u32 = 1;
pub const LKL_CONFIG_POSIX_TIMERS: u32 = 1;
pub const LKL_CONFIG_INET_TCP_DIAG: u32 = 1;
pub const LKL_CONFIG_DEVMEM: u32 = 1;
pub const LKL_CONFIG_CC_HAS_KASAN_GENERIC: u32 = 1;
pub const LKL_CONFIG_DEBUG_KERNEL: u32 = 1;
pub const LKL_CONFIG_LOCALVERSION: &'static [u8; 1usize] = b"\0";
pub const LKL_CONFIG_SYMBOLIC_ERRNAME: u32 = 1;
pub const LKL_CONFIG_CRYPTO: u32 = 1;
pub const LKL_CONFIG_GENERIC_CPU_DEVICES: u32 = 1;
pub const LKL_CONFIG_SCHED_DEBUG: u32 = 1;
pub const LKL_CONFIG_RUNTIME_TESTING_MENU: u32 = 1;
pub const LKL_CONFIG_VIRTIO: u32 = 1;
pub const LKL_CONFIG_PANIC_ON_OOPS_VALUE: u32 = 0;
pub const LKL_CONFIG_SCSI_MOD: u32 = 1;
pub const LKL_CONFIG_LKL: u32 = 1;
pub const LKL_CONFIG_CRYPTO_CRC32C: u32 = 1;
pub const LKL_CONFIG_EMBEDDED: u32 = 1;
pub const LKL_CONFIG_ASSOCIATIVE_ARRAY: u32 = 1;
pub const LKL_CONFIG_INLINE_READ_UNLOCK: u32 = 1;
pub const LKL_CONFIG_HAS_DMA: u32 = 1;
pub const LKL_CONFIG_CRYPTO_LIB_CHACHA20POLY1305: u32 = 1;
pub const LKL_CONFIG_MISC_FILESYSTEMS: u32 = 1;
pub const LKL_CONFIG_INLINE_READ_UNLOCK_IRQ: u32 = 1;
pub const LKL_CONFIG_DST_CACHE: u32 = 1;
pub const LKL_CONFIG_LLD_VERSION: u32 = 0;
pub const LKL_CONFIG_SECTION_MISMATCH_WARN_ONLY: u32 = 1;
pub const LKL_CONFIG_PCIEASPM_DEFAULT: u32 = 1;
pub const LKL_CONFIG_CRYPTO_MANAGER: u32 = 1;
pub const LKL_CONFIG_SLAB_MERGE_DEFAULT: u32 = 1;
pub const LKL_CONFIG_KERNFS: u32 = 1;
pub const LKL_CONFIG_EXPERT: u32 = 1;
pub const LKL_CONFIG_FRAME_WARN: u32 = 2048;
pub const LKL_CONFIG_DEBUG_INFO_REDUCED: u32 = 1;
pub const LKL_CONFIG_GENERIC_HWEIGHT: u32 = 1;
pub const LKL_CONFIG_HZ: u32 = 100;
pub const LKL_CONFIG_INLINE_SPIN_UNLOCK_IRQ: u32 = 1;
pub const LKL_CONFIG_CC_IS_GCC: u32 = 1;
pub const LKL_CONFIG_NLATTR: u32 = 1;
pub const LKL_CONFIG_TCP_CONG_CUBIC: u32 = 1;
pub const LKL_CONFIG_CEPH_FS: u32 = 1;
pub const LKL_CONFIG_SYSFS: u32 = 1;
pub const LKL_CONFIG_IO_WQ: u32 = 1;
pub const LKL_CONFIG_BLK_MQ_VIRTIO: u32 = 1;
pub const LKL_CONFIG_CC_HAS_ASM_GOTO: u32 = 1;
pub const LKL_CONFIG_MSDOS_PARTITION: u32 = 1;
pub const LKL_CONFIG_CRYPTO_LIB_CHACHA: u32 = 1;
pub const LKL_CONFIG_LEGACY_PTY_COUNT: u32 = 256;
pub const LKL_CONFIG_GENERIC_CSUM: u32 = 1;
pub const LKL_CONFIG_TICK_ONESHOT: u32 = 1;
pub const LKL_CONFIG_TINY_RCU: u32 = 1;
pub const LKL_CONFIG_HW_RANDOM: u32 = 1;
pub const LKL_CONFIG_RWSEM_GENERIC_SPINLOCK: u32 = 1;
pub const LKL_CONFIG_CRYPTO_LIB_POLY1305_GENERIC: u32 = 1;
pub const LKL_CONFIG_CRYPTO_NULL2: u32 = 1;
pub const LKL_CONFIG_BASE_SMALL: u32 = 1;
pub const LKL_CONFIG_PROC_FS: u32 = 1;
pub const LKL_CONFIG_VIRTIO_MMIO: u32 = 1;
pub const LKL_CONFIG_FLATMEM: u32 = 1;
pub const LKL_CONFIG_GCC_VERSION: u32 = 70500;
pub const LKL_CONFIG_CRYPTO_LIB_POLY1305_RSIZE: u32 = 1;
pub const LKL_CONFIG_SYSCTL: u32 = 1;
pub const LKL_CONFIG_PHYS_ADDR_T_64BIT: u32 = 1;
pub const LKL_CONFIG_NO_IOPORT_MAP: u32 = 1;
pub const LKL_CONFIG_CEPH_FS_POSIX_ACL: u32 = 1;
pub const LKL_CONFIG_PCIEASPM: u32 = 1;
pub const LKL_CONFIG_UNIX98_PTYS: u32 = 1;
pub const LKL_CONFIG_NET_RX_BUSY_POLL: u32 = 1;
pub const LKL_CONFIG_CRYPTO_ANSI_CPRNG: u32 = 1;
pub const LKL_CONFIG_PRINTK_TIME: u32 = 1;
pub const LKL_CONFIG_INET_DIAG: u32 = 1;
pub const LKL_CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES: u32 = 1;
pub const LKL_CONFIG_FLAT_NODE_MEM_MAP: u32 = 1;
pub const LKL_CONFIG_MQ_IOSCHED_KYBER: u32 = 1;
pub const LKL_CONFIG_CC_HAS_INT128: u32 = 1;
pub const LKL_CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE: u32 = 1;
pub const LKL_CONFIG_VHOST_MENU: u32 = 1;
pub const LKL_CONFIG_DEBUG_MISC: u32 = 1;
pub const LKL_CONFIG_VIRTIO_MENU: u32 = 1;
pub const LKL_CONFIG_64BIT: u32 = 1;
pub const LKL_CONFIG_ARCH_WANT_FRAME_POINTERS: u32 = 1;
pub const LKL_CONFIG_FHANDLE: u32 = 1;
pub const LKL_CONFIG_BITREVERSE: u32 = 1;
pub const LKL_CONFIG_DEVPORT: u32 = 1;
pub const LKL_CONFIG_LSM: &'static [u8; 46usize] =
    b"lockdown,yama,loadpin,safesetid,integrity,bpf\0";
pub const LKL_CONFIG_ARCH_DMA_ADDR_T_64BIT: u32 = 1;
pub const LKL_CONFIG_KALLSYMS_BASE_RELATIVE: u32 = 1;
pub const LKL_CONFIG_MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const LKL_CONFIG_DEBUG_INFO: u32 = 1;
pub const LKL_CONFIG_CRYPTO_AEAD2: u32 = 1;
pub const LKL_CONFIG_CRYPTO_ALGAPI2: u32 = 1;
pub const LKL_CONFIG_PROC_SYSCTL: u32 = 1;
pub const LKL_CONFIG_LD_VERSION: u32 = 235010000;
pub const LKL_CONFIG_INLINE_WRITE_UNLOCK: u32 = 1;
pub const __LKL__BITS_PER_LONG: u32 = 64;
pub const __LKL__FD_SETSIZE: u32 = 1024;
pub const __lkl__NR_io_setup: u32 = 0;
pub const __lkl__NR_io_destroy: u32 = 1;
pub const __lkl__NR_io_submit: u32 = 2;
pub const __lkl__NR_io_cancel: u32 = 3;
pub const __lkl__NR_io_getevents: u32 = 4;
pub const __lkl__NR_setxattr: u32 = 5;
pub const __lkl__NR_lsetxattr: u32 = 6;
pub const __lkl__NR_fsetxattr: u32 = 7;
pub const __lkl__NR_getxattr: u32 = 8;
pub const __lkl__NR_lgetxattr: u32 = 9;
pub const __lkl__NR_fgetxattr: u32 = 10;
pub const __lkl__NR_listxattr: u32 = 11;
pub const __lkl__NR_llistxattr: u32 = 12;
pub const __lkl__NR_flistxattr: u32 = 13;
pub const __lkl__NR_removexattr: u32 = 14;
pub const __lkl__NR_lremovexattr: u32 = 15;
pub const __lkl__NR_fremovexattr: u32 = 16;
pub const __lkl__NR_getcwd: u32 = 17;
pub const __lkl__NR_lookup_dcookie: u32 = 18;
pub const __lkl__NR_eventfd2: u32 = 19;
pub const __lkl__NR_epoll_create1: u32 = 20;
pub const __lkl__NR_epoll_ctl: u32 = 21;
pub const __lkl__NR_epoll_pwait: u32 = 22;
pub const __lkl__NR_dup: u32 = 23;
pub const __lkl__NR_dup3: u32 = 24;
pub const __lkl__NR3264_fcntl: u32 = 25;
pub const __lkl__NR_inotify_init1: u32 = 26;
pub const __lkl__NR_inotify_add_watch: u32 = 27;
pub const __lkl__NR_inotify_rm_watch: u32 = 28;
pub const __lkl__NR_ioctl: u32 = 29;
pub const __lkl__NR_ioprio_set: u32 = 30;
pub const __lkl__NR_ioprio_get: u32 = 31;
pub const __lkl__NR_flock: u32 = 32;
pub const __lkl__NR_mknodat: u32 = 33;
pub const __lkl__NR_mkdirat: u32 = 34;
pub const __lkl__NR_unlinkat: u32 = 35;
pub const __lkl__NR_symlinkat: u32 = 36;
pub const __lkl__NR_linkat: u32 = 37;
pub const __lkl__NR_renameat: u32 = 38;
pub const __lkl__NR_umount2: u32 = 39;
pub const __lkl__NR_mount: u32 = 40;
pub const __lkl__NR_pivot_root: u32 = 41;
pub const __lkl__NR_nfsservctl: u32 = 42;
pub const __lkl__NR3264_statfs: u32 = 43;
pub const __lkl__NR3264_fstatfs: u32 = 44;
pub const __lkl__NR3264_truncate: u32 = 45;
pub const __lkl__NR3264_ftruncate: u32 = 46;
pub const __lkl__NR_fallocate: u32 = 47;
pub const __lkl__NR_faccessat: u32 = 48;
pub const __lkl__NR_chdir: u32 = 49;
pub const __lkl__NR_fchdir: u32 = 50;
pub const __lkl__NR_chroot: u32 = 51;
pub const __lkl__NR_fchmod: u32 = 52;
pub const __lkl__NR_fchmodat: u32 = 53;
pub const __lkl__NR_fchownat: u32 = 54;
pub const __lkl__NR_fchown: u32 = 55;
pub const __lkl__NR_openat: u32 = 56;
pub const __lkl__NR_close: u32 = 57;
pub const __lkl__NR_vhangup: u32 = 58;
pub const __lkl__NR_pipe2: u32 = 59;
pub const __lkl__NR_quotactl: u32 = 60;
pub const __lkl__NR_getdents64: u32 = 61;
pub const __lkl__NR3264_lseek: u32 = 62;
pub const __lkl__NR_read: u32 = 63;
pub const __lkl__NR_write: u32 = 64;
pub const __lkl__NR_readv: u32 = 65;
pub const __lkl__NR_writev: u32 = 66;
pub const __lkl__NR_pread64: u32 = 67;
pub const __lkl__NR_pwrite64: u32 = 68;
pub const __lkl__NR_preadv: u32 = 69;
pub const __lkl__NR_pwritev: u32 = 70;
pub const __lkl__NR3264_sendfile: u32 = 71;
pub const __lkl__NR_pselect6: u32 = 72;
pub const __lkl__NR_ppoll: u32 = 73;
pub const __lkl__NR_signalfd4: u32 = 74;
pub const __lkl__NR_vmsplice: u32 = 75;
pub const __lkl__NR_splice: u32 = 76;
pub const __lkl__NR_tee: u32 = 77;
pub const __lkl__NR_readlinkat: u32 = 78;
pub const __lkl__NR3264_fstatat: u32 = 79;
pub const __lkl__NR3264_fstat: u32 = 80;
pub const __lkl__NR_sync: u32 = 81;
pub const __lkl__NR_fsync: u32 = 82;
pub const __lkl__NR_fdatasync: u32 = 83;
pub const __lkl__NR_sync_file_range: u32 = 84;
pub const __lkl__NR_timerfd_create: u32 = 85;
pub const __lkl__NR_timerfd_settime: u32 = 86;
pub const __lkl__NR_timerfd_gettime: u32 = 87;
pub const __lkl__NR_utimensat: u32 = 88;
pub const __lkl__NR_acct: u32 = 89;
pub const __lkl__NR_capget: u32 = 90;
pub const __lkl__NR_capset: u32 = 91;
pub const __lkl__NR_personality: u32 = 92;
pub const __lkl__NR_exit: u32 = 93;
pub const __lkl__NR_exit_group: u32 = 94;
pub const __lkl__NR_waitid: u32 = 95;
pub const __lkl__NR_set_tid_address: u32 = 96;
pub const __lkl__NR_unshare: u32 = 97;
pub const __lkl__NR_futex: u32 = 98;
pub const __lkl__NR_set_robust_list: u32 = 99;
pub const __lkl__NR_get_robust_list: u32 = 100;
pub const __lkl__NR_nanosleep: u32 = 101;
pub const __lkl__NR_getitimer: u32 = 102;
pub const __lkl__NR_setitimer: u32 = 103;
pub const __lkl__NR_kexec_load: u32 = 104;
pub const __lkl__NR_init_module: u32 = 105;
pub const __lkl__NR_delete_module: u32 = 106;
pub const __lkl__NR_timer_create: u32 = 107;
pub const __lkl__NR_timer_gettime: u32 = 108;
pub const __lkl__NR_timer_getoverrun: u32 = 109;
pub const __lkl__NR_timer_settime: u32 = 110;
pub const __lkl__NR_timer_delete: u32 = 111;
pub const __lkl__NR_clock_settime: u32 = 112;
pub const __lkl__NR_clock_gettime: u32 = 113;
pub const __lkl__NR_clock_getres: u32 = 114;
pub const __lkl__NR_clock_nanosleep: u32 = 115;
pub const __lkl__NR_syslog: u32 = 116;
pub const __lkl__NR_ptrace: u32 = 117;
pub const __lkl__NR_sched_setparam: u32 = 118;
pub const __lkl__NR_sched_setscheduler: u32 = 119;
pub const __lkl__NR_sched_getscheduler: u32 = 120;
pub const __lkl__NR_sched_getparam: u32 = 121;
pub const __lkl__NR_sched_setaffinity: u32 = 122;
pub const __lkl__NR_sched_getaffinity: u32 = 123;
pub const __lkl__NR_sched_yield: u32 = 124;
pub const __lkl__NR_sched_get_priority_max: u32 = 125;
pub const __lkl__NR_sched_get_priority_min: u32 = 126;
pub const __lkl__NR_sched_rr_get_interval: u32 = 127;
pub const __lkl__NR_restart_syscall: u32 = 128;
pub const __lkl__NR_kill: u32 = 129;
pub const __lkl__NR_tkill: u32 = 130;
pub const __lkl__NR_tgkill: u32 = 131;
pub const __lkl__NR_sigaltstack: u32 = 132;
pub const __lkl__NR_rt_sigsuspend: u32 = 133;
pub const __lkl__NR_rt_sigaction: u32 = 134;
pub const __lkl__NR_rt_sigprocmask: u32 = 135;
pub const __lkl__NR_rt_sigpending: u32 = 136;
pub const __lkl__NR_rt_sigtimedwait: u32 = 137;
pub const __lkl__NR_rt_sigqueueinfo: u32 = 138;
pub const __lkl__NR_rt_sigreturn: u32 = 139;
pub const __lkl__NR_setpriority: u32 = 140;
pub const __lkl__NR_getpriority: u32 = 141;
pub const __lkl__NR_reboot: u32 = 142;
pub const __lkl__NR_setregid: u32 = 143;
pub const __lkl__NR_setgid: u32 = 144;
pub const __lkl__NR_setreuid: u32 = 145;
pub const __lkl__NR_setuid: u32 = 146;
pub const __lkl__NR_setresuid: u32 = 147;
pub const __lkl__NR_getresuid: u32 = 148;
pub const __lkl__NR_setresgid: u32 = 149;
pub const __lkl__NR_getresgid: u32 = 150;
pub const __lkl__NR_setfsuid: u32 = 151;
pub const __lkl__NR_setfsgid: u32 = 152;
pub const __lkl__NR_times: u32 = 153;
pub const __lkl__NR_setpgid: u32 = 154;
pub const __lkl__NR_getpgid: u32 = 155;
pub const __lkl__NR_getsid: u32 = 156;
pub const __lkl__NR_setsid: u32 = 157;
pub const __lkl__NR_getgroups: u32 = 158;
pub const __lkl__NR_setgroups: u32 = 159;
pub const __lkl__NR_uname: u32 = 160;
pub const __lkl__NR_sethostname: u32 = 161;
pub const __lkl__NR_setdomainname: u32 = 162;
pub const __lkl__NR_getrlimit: u32 = 163;
pub const __lkl__NR_setrlimit: u32 = 164;
pub const __lkl__NR_getrusage: u32 = 165;
pub const __lkl__NR_umask: u32 = 166;
pub const __lkl__NR_prctl: u32 = 167;
pub const __lkl__NR_getcpu: u32 = 168;
pub const __lkl__NR_gettimeofday: u32 = 169;
pub const __lkl__NR_settimeofday: u32 = 170;
pub const __lkl__NR_adjtimex: u32 = 171;
pub const __lkl__NR_getpid: u32 = 172;
pub const __lkl__NR_getppid: u32 = 173;
pub const __lkl__NR_getuid: u32 = 174;
pub const __lkl__NR_geteuid: u32 = 175;
pub const __lkl__NR_getgid: u32 = 176;
pub const __lkl__NR_getegid: u32 = 177;
pub const __lkl__NR_gettid: u32 = 178;
pub const __lkl__NR_sysinfo: u32 = 179;
pub const __lkl__NR_mq_open: u32 = 180;
pub const __lkl__NR_mq_unlink: u32 = 181;
pub const __lkl__NR_mq_timedsend: u32 = 182;
pub const __lkl__NR_mq_timedreceive: u32 = 183;
pub const __lkl__NR_mq_notify: u32 = 184;
pub const __lkl__NR_mq_getsetattr: u32 = 185;
pub const __lkl__NR_msgget: u32 = 186;
pub const __lkl__NR_msgctl: u32 = 187;
pub const __lkl__NR_msgrcv: u32 = 188;
pub const __lkl__NR_msgsnd: u32 = 189;
pub const __lkl__NR_semget: u32 = 190;
pub const __lkl__NR_semctl: u32 = 191;
pub const __lkl__NR_semtimedop: u32 = 192;
pub const __lkl__NR_semop: u32 = 193;
pub const __lkl__NR_shmget: u32 = 194;
pub const __lkl__NR_shmctl: u32 = 195;
pub const __lkl__NR_shmat: u32 = 196;
pub const __lkl__NR_shmdt: u32 = 197;
pub const __lkl__NR_socket: u32 = 198;
pub const __lkl__NR_socketpair: u32 = 199;
pub const __lkl__NR_bind: u32 = 200;
pub const __lkl__NR_listen: u32 = 201;
pub const __lkl__NR_accept: u32 = 202;
pub const __lkl__NR_connect: u32 = 203;
pub const __lkl__NR_getsockname: u32 = 204;
pub const __lkl__NR_getpeername: u32 = 205;
pub const __lkl__NR_sendto: u32 = 206;
pub const __lkl__NR_recvfrom: u32 = 207;
pub const __lkl__NR_setsockopt: u32 = 208;
pub const __lkl__NR_getsockopt: u32 = 209;
pub const __lkl__NR_shutdown: u32 = 210;
pub const __lkl__NR_sendmsg: u32 = 211;
pub const __lkl__NR_recvmsg: u32 = 212;
pub const __lkl__NR_readahead: u32 = 213;
pub const __lkl__NR_brk: u32 = 214;
pub const __lkl__NR_munmap: u32 = 215;
pub const __lkl__NR_mremap: u32 = 216;
pub const __lkl__NR_add_key: u32 = 217;
pub const __lkl__NR_request_key: u32 = 218;
pub const __lkl__NR_keyctl: u32 = 219;
pub const __lkl__NR_clone: u32 = 220;
pub const __lkl__NR_execve: u32 = 221;
pub const __lkl__NR3264_mmap: u32 = 222;
pub const __lkl__NR3264_fadvise64: u32 = 223;
pub const __lkl__NR_swapon: u32 = 224;
pub const __lkl__NR_swapoff: u32 = 225;
pub const __lkl__NR_mprotect: u32 = 226;
pub const __lkl__NR_msync: u32 = 227;
pub const __lkl__NR_mlock: u32 = 228;
pub const __lkl__NR_munlock: u32 = 229;
pub const __lkl__NR_mlockall: u32 = 230;
pub const __lkl__NR_munlockall: u32 = 231;
pub const __lkl__NR_mincore: u32 = 232;
pub const __lkl__NR_madvise: u32 = 233;
pub const __lkl__NR_remap_file_pages: u32 = 234;
pub const __lkl__NR_mbind: u32 = 235;
pub const __lkl__NR_get_mempolicy: u32 = 236;
pub const __lkl__NR_set_mempolicy: u32 = 237;
pub const __lkl__NR_migrate_pages: u32 = 238;
pub const __lkl__NR_move_pages: u32 = 239;
pub const __lkl__NR_rt_tgsigqueueinfo: u32 = 240;
pub const __lkl__NR_perf_event_open: u32 = 241;
pub const __lkl__NR_accept4: u32 = 242;
pub const __lkl__NR_recvmmsg: u32 = 243;
pub const __lkl__NR_arch_specific_syscall: u32 = 244;
pub const __lkl__NR_wait4: u32 = 260;
pub const __lkl__NR_prlimit64: u32 = 261;
pub const __lkl__NR_fanotify_init: u32 = 262;
pub const __lkl__NR_fanotify_mark: u32 = 263;
pub const __lkl__NR_name_to_handle_at: u32 = 264;
pub const __lkl__NR_open_by_handle_at: u32 = 265;
pub const __lkl__NR_clock_adjtime: u32 = 266;
pub const __lkl__NR_syncfs: u32 = 267;
pub const __lkl__NR_setns: u32 = 268;
pub const __lkl__NR_sendmmsg: u32 = 269;
pub const __lkl__NR_process_vm_readv: u32 = 270;
pub const __lkl__NR_process_vm_writev: u32 = 271;
pub const __lkl__NR_kcmp: u32 = 272;
pub const __lkl__NR_finit_module: u32 = 273;
pub const __lkl__NR_sched_setattr: u32 = 274;
pub const __lkl__NR_sched_getattr: u32 = 275;
pub const __lkl__NR_renameat2: u32 = 276;
pub const __lkl__NR_seccomp: u32 = 277;
pub const __lkl__NR_getrandom: u32 = 278;
pub const __lkl__NR_memfd_create: u32 = 279;
pub const __lkl__NR_bpf: u32 = 280;
pub const __lkl__NR_execveat: u32 = 281;
pub const __lkl__NR_userfaultfd: u32 = 282;
pub const __lkl__NR_membarrier: u32 = 283;
pub const __lkl__NR_mlock2: u32 = 284;
pub const __lkl__NR_copy_file_range: u32 = 285;
pub const __lkl__NR_preadv2: u32 = 286;
pub const __lkl__NR_pwritev2: u32 = 287;
pub const __lkl__NR_pkey_mprotect: u32 = 288;
pub const __lkl__NR_pkey_alloc: u32 = 289;
pub const __lkl__NR_pkey_free: u32 = 290;
pub const __lkl__NR_statx: u32 = 291;
pub const __lkl__NR_io_pgetevents: u32 = 292;
pub const __lkl__NR_rseq: u32 = 293;
pub const __lkl__NR_kexec_file_load: u32 = 294;
pub const __lkl__NR_pidfd_send_signal: u32 = 424;
pub const __lkl__NR_io_uring_setup: u32 = 425;
pub const __lkl__NR_io_uring_enter: u32 = 426;
pub const __lkl__NR_io_uring_register: u32 = 427;
pub const __lkl__NR_open_tree: u32 = 428;
pub const __lkl__NR_move_mount: u32 = 429;
pub const __lkl__NR_fsopen: u32 = 430;
pub const __lkl__NR_fsconfig: u32 = 431;
pub const __lkl__NR_fsmount: u32 = 432;
pub const __lkl__NR_fspick: u32 = 433;
pub const __lkl__NR_pidfd_open: u32 = 434;
pub const __lkl__NR_close_range: u32 = 436;
pub const __lkl__NR_openat2: u32 = 437;
pub const __lkl__NR_pidfd_getfd: u32 = 438;
pub const __lkl__NR_faccessat2: u32 = 439;
pub const __lkl__NR_process_madvise: u32 = 440;
pub const __lkl__NR_syscalls: u32 = 441;
pub const __lkl__NR_fcntl: u32 = 25;
pub const __lkl__NR_statfs: u32 = 43;
pub const __lkl__NR_fstatfs: u32 = 44;
pub const __lkl__NR_truncate: u32 = 45;
pub const __lkl__NR_ftruncate: u32 = 46;
pub const __lkl__NR_lseek: u32 = 62;
pub const __lkl__NR_sendfile: u32 = 71;
pub const __lkl__NR_newfstatat: u32 = 79;
pub const __lkl__NR_fstat: u32 = 80;
pub const __lkl__NR_mmap: u32 = 222;
pub const __lkl__NR_fadvise64: u32 = 223;
pub const __lkl__NR_virtio_mmio_device_add: u32 = 244;
pub const __lkl__NR_umount: u32 = 39;
pub const __lkl__NR_newfstat: u32 = 80;
pub const __lkl__NR_mmap_pgoff: u32 = 222;
pub const LKL_ITIMER_REAL: u32 = 0;
pub const LKL_ITIMER_VIRTUAL: u32 = 1;
pub const LKL_ITIMER_PROF: u32 = 2;
pub const LKL_CLOCK_REALTIME: u32 = 0;
pub const LKL_CLOCK_MONOTONIC: u32 = 1;
pub const LKL_CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const LKL_CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const LKL_CLOCK_MONOTONIC_RAW: u32 = 4;
pub const LKL_CLOCK_REALTIME_COARSE: u32 = 5;
pub const LKL_CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const LKL_CLOCK_BOOTTIME: u32 = 7;
pub const LKL_CLOCK_REALTIME_ALARM: u32 = 8;
pub const LKL_CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const LKL_CLOCK_SGI_CYCLE: u32 = 10;
pub const LKL_CLOCK_TAI: u32 = 11;
pub const LKL_MAX_CLOCKS: u32 = 16;
pub const LKL_CLOCKS_MASK: u32 = 1;
pub const LKL_CLOCKS_MONO: u32 = 1;
pub const LKL_TIMER_ABSTIME: u32 = 1;
pub const LKL_NTP_API: u32 = 4;
pub const LKL_ADJ_OFFSET: u32 = 1;
pub const LKL_ADJ_FREQUENCY: u32 = 2;
pub const LKL_ADJ_MAXERROR: u32 = 4;
pub const LKL_ADJ_ESTERROR: u32 = 8;
pub const LKL_ADJ_STATUS: u32 = 16;
pub const LKL_ADJ_TIMECONST: u32 = 32;
pub const LKL_ADJ_TAI: u32 = 128;
pub const LKL_ADJ_SETOFFSET: u32 = 256;
pub const LKL_ADJ_MICRO: u32 = 4096;
pub const LKL_ADJ_NANO: u32 = 8192;
pub const LKL_ADJ_TICK: u32 = 16384;
pub const LKL_ADJ_OFFSET_SINGLESHOT: u32 = 32769;
pub const LKL_ADJ_OFFSET_SS_READ: u32 = 40961;
pub const LKL_MOD_OFFSET: u32 = 1;
pub const LKL_MOD_FREQUENCY: u32 = 2;
pub const LKL_MOD_MAXERROR: u32 = 4;
pub const LKL_MOD_ESTERROR: u32 = 8;
pub const LKL_MOD_STATUS: u32 = 16;
pub const LKL_MOD_TIMECONST: u32 = 32;
pub const LKL_MOD_TAI: u32 = 128;
pub const LKL_MOD_MICRO: u32 = 4096;
pub const LKL_MOD_NANO: u32 = 8192;
pub const LKL_STA_PLL: u32 = 1;
pub const LKL_STA_PPSFREQ: u32 = 2;
pub const LKL_STA_PPSTIME: u32 = 4;
pub const LKL_STA_FLL: u32 = 8;
pub const LKL_STA_INS: u32 = 16;
pub const LKL_STA_DEL: u32 = 32;
pub const LKL_STA_UNSYNC: u32 = 64;
pub const LKL_STA_FREQHOLD: u32 = 128;
pub const LKL_STA_PPSSIGNAL: u32 = 256;
pub const LKL_STA_PPSJITTER: u32 = 512;
pub const LKL_STA_PPSWANDER: u32 = 1024;
pub const LKL_STA_PPSERROR: u32 = 2048;
pub const LKL_STA_CLOCKERR: u32 = 4096;
pub const LKL_STA_NANO: u32 = 8192;
pub const LKL_STA_MODE: u32 = 16384;
pub const LKL_STA_CLK: u32 = 32768;
pub const LKL_STA_RONLY: u32 = 65280;
pub const LKL_TIME_OK: u32 = 0;
pub const LKL_TIME_INS: u32 = 1;
pub const LKL_TIME_DEL: u32 = 2;
pub const LKL_TIME_OOP: u32 = 3;
pub const LKL_TIME_WAIT: u32 = 4;
pub const LKL_TIME_ERROR: u32 = 5;
pub const LKL_TIME_BAD: u32 = 5;
pub const _LKL_LINUX_CAPABILITY_VERSION_1: u32 = 429392688;
pub const _LKL_LINUX_CAPABILITY_U32S_1: u32 = 1;
pub const _LKL_LINUX_CAPABILITY_VERSION_2: u32 = 537333798;
pub const _LKL_LINUX_CAPABILITY_U32S_2: u32 = 2;
pub const _LKL_LINUX_CAPABILITY_VERSION_3: u32 = 537396514;
pub const _LKL_LINUX_CAPABILITY_U32S_3: u32 = 2;
pub const LKL_VFS_CAP_REVISION_MASK: u32 = 4278190080;
pub const LKL_VFS_CAP_REVISION_SHIFT: u32 = 24;
pub const LKL_VFS_CAP_FLAGS_MASK: i64 = -4278190081;
pub const LKL_VFS_CAP_FLAGS_EFFECTIVE: u32 = 1;
pub const LKL_VFS_CAP_REVISION_1: u32 = 16777216;
pub const LKL_VFS_CAP_U32_1: u32 = 1;
pub const LKL_VFS_CAP_REVISION_2: u32 = 33554432;
pub const LKL_VFS_CAP_U32_2: u32 = 2;
pub const LKL_VFS_CAP_REVISION_3: u32 = 50331648;
pub const LKL_VFS_CAP_U32_3: u32 = 2;
pub const LKL_VFS_CAP_U32: u32 = 2;
pub const LKL_VFS_CAP_REVISION: u32 = 50331648;
pub const _LKL_LINUX_CAPABILITY_VERSION: u32 = 429392688;
pub const _LKL_LINUX_CAPABILITY_U32S: u32 = 1;
pub const LKL_CAP_CHOWN: u32 = 0;
pub const LKL_CAP_DAC_OVERRIDE: u32 = 1;
pub const LKL_CAP_DAC_READ_SEARCH: u32 = 2;
pub const LKL_CAP_FOWNER: u32 = 3;
pub const LKL_CAP_FSETID: u32 = 4;
pub const LKL_CAP_KILL: u32 = 5;
pub const LKL_CAP_SETGID: u32 = 6;
pub const LKL_CAP_SETUID: u32 = 7;
pub const LKL_CAP_SETPCAP: u32 = 8;
pub const LKL_CAP_LINUX_IMMUTABLE: u32 = 9;
pub const LKL_CAP_NET_BIND_SERVICE: u32 = 10;
pub const LKL_CAP_NET_BROADCAST: u32 = 11;
pub const LKL_CAP_NET_ADMIN: u32 = 12;
pub const LKL_CAP_NET_RAW: u32 = 13;
pub const LKL_CAP_IPC_LOCK: u32 = 14;
pub const LKL_CAP_IPC_OWNER: u32 = 15;
pub const LKL_CAP_SYS_MODULE: u32 = 16;
pub const LKL_CAP_SYS_RAWIO: u32 = 17;
pub const LKL_CAP_SYS_CHROOT: u32 = 18;
pub const LKL_CAP_SYS_PTRACE: u32 = 19;
pub const LKL_CAP_SYS_PACCT: u32 = 20;
pub const LKL_CAP_SYS_ADMIN: u32 = 21;
pub const LKL_CAP_SYS_BOOT: u32 = 22;
pub const LKL_CAP_SYS_NICE: u32 = 23;
pub const LKL_CAP_SYS_RESOURCE: u32 = 24;
pub const LKL_CAP_SYS_TIME: u32 = 25;
pub const LKL_CAP_SYS_TTY_CONFIG: u32 = 26;
pub const LKL_CAP_MKNOD: u32 = 27;
pub const LKL_CAP_LEASE: u32 = 28;
pub const LKL_CAP_AUDIT_WRITE: u32 = 29;
pub const LKL_CAP_AUDIT_CONTROL: u32 = 30;
pub const LKL_CAP_SETFCAP: u32 = 31;
pub const LKL_CAP_MAC_OVERRIDE: u32 = 32;
pub const LKL_CAP_MAC_ADMIN: u32 = 33;
pub const LKL_CAP_SYSLOG: u32 = 34;
pub const LKL_CAP_WAKE_ALARM: u32 = 35;
pub const LKL_CAP_BLOCK_SUSPEND: u32 = 36;
pub const LKL_CAP_AUDIT_READ: u32 = 37;
pub const LKL_CAP_PERFMON: u32 = 38;
pub const LKL_CAP_BPF: u32 = 39;
pub const LKL_CAP_CHECKPOINT_RESTORE: u32 = 40;
pub const LKL_CAP_LAST_CAP: u32 = 40;
pub const LKL_S_IFMT: u32 = 61440;
pub const LKL_S_IFSOCK: u32 = 49152;
pub const LKL_S_IFLNK: u32 = 40960;
pub const LKL_S_IFREG: u32 = 32768;
pub const LKL_S_IFBLK: u32 = 24576;
pub const LKL_S_IFDIR: u32 = 16384;
pub const LKL_S_IFCHR: u32 = 8192;
pub const LKL_S_IFIFO: u32 = 4096;
pub const LKL_S_ISUID: u32 = 2048;
pub const LKL_S_ISGID: u32 = 1024;
pub const LKL_S_ISVTX: u32 = 512;
pub const LKL_S_IRWXU: u32 = 448;
pub const LKL_S_IRUSR: u32 = 256;
pub const LKL_S_IWUSR: u32 = 128;
pub const LKL_S_IXUSR: u32 = 64;
pub const LKL_S_IRWXG: u32 = 56;
pub const LKL_S_IRGRP: u32 = 32;
pub const LKL_S_IWGRP: u32 = 16;
pub const LKL_S_IXGRP: u32 = 8;
pub const LKL_S_IRWXO: u32 = 7;
pub const LKL_S_IROTH: u32 = 4;
pub const LKL_S_IWOTH: u32 = 2;
pub const LKL_S_IXOTH: u32 = 1;
pub const LKL_STATX_TYPE: u32 = 1;
pub const LKL_STATX_MODE: u32 = 2;
pub const LKL_STATX_NLINK: u32 = 4;
pub const LKL_STATX_UID: u32 = 8;
pub const LKL_STATX_GID: u32 = 16;
pub const LKL_STATX_ATIME: u32 = 32;
pub const LKL_STATX_MTIME: u32 = 64;
pub const LKL_STATX_CTIME: u32 = 128;
pub const LKL_STATX_INO: u32 = 256;
pub const LKL_STATX_SIZE: u32 = 512;
pub const LKL_STATX_BLOCKS: u32 = 1024;
pub const LKL_STATX_BASIC_STATS: u32 = 2047;
pub const LKL_STATX_BTIME: u32 = 2048;
pub const LKL_STATX_MNT_ID: u32 = 4096;
pub const LKL_STATX__RESERVED: u32 = 2147483648;
pub const LKL_STATX_ALL: u32 = 4095;
pub const LKL_STATX_ATTR_COMPRESSED: u32 = 4;
pub const LKL_STATX_ATTR_IMMUTABLE: u32 = 16;
pub const LKL_STATX_ATTR_APPEND: u32 = 32;
pub const LKL_STATX_ATTR_NODUMP: u32 = 64;
pub const LKL_STATX_ATTR_ENCRYPTED: u32 = 2048;
pub const LKL_STATX_ATTR_AUTOMOUNT: u32 = 4096;
pub const LKL_STATX_ATTR_MOUNT_ROOT: u32 = 8192;
pub const LKL_STATX_ATTR_VERITY: u32 = 1048576;
pub const LKL_STATX_ATTR_DAX: u32 = 2097152;
pub const LKL_EPERM: u32 = 1;
pub const LKL_ENOENT: u32 = 2;
pub const LKL_ESRCH: u32 = 3;
pub const LKL_EINTR: u32 = 4;
pub const LKL_EIO: u32 = 5;
pub const LKL_ENXIO: u32 = 6;
pub const LKL_E2BIG: u32 = 7;
pub const LKL_ENOEXEC: u32 = 8;
pub const LKL_EBADF: u32 = 9;
pub const LKL_ECHILD: u32 = 10;
pub const LKL_EAGAIN: u32 = 11;
pub const LKL_ENOMEM: u32 = 12;
pub const LKL_EACCES: u32 = 13;
pub const LKL_EFAULT: u32 = 14;
pub const LKL_ENOTBLK: u32 = 15;
pub const LKL_EBUSY: u32 = 16;
pub const LKL_EEXIST: u32 = 17;
pub const LKL_EXDEV: u32 = 18;
pub const LKL_ENODEV: u32 = 19;
pub const LKL_ENOTDIR: u32 = 20;
pub const LKL_EISDIR: u32 = 21;
pub const LKL_EINVAL: u32 = 22;
pub const LKL_ENFILE: u32 = 23;
pub const LKL_EMFILE: u32 = 24;
pub const LKL_ENOTTY: u32 = 25;
pub const LKL_ETXTBSY: u32 = 26;
pub const LKL_EFBIG: u32 = 27;
pub const LKL_ENOSPC: u32 = 28;
pub const LKL_ESPIPE: u32 = 29;
pub const LKL_EROFS: u32 = 30;
pub const LKL_EMLINK: u32 = 31;
pub const LKL_EPIPE: u32 = 32;
pub const LKL_EDOM: u32 = 33;
pub const LKL_ERANGE: u32 = 34;
pub const LKL_EDEADLK: u32 = 35;
pub const LKL_ENAMETOOLONG: u32 = 36;
pub const LKL_ENOLCK: u32 = 37;
pub const LKL_ENOSYS: u32 = 38;
pub const LKL_ENOTEMPTY: u32 = 39;
pub const LKL_ELOOP: u32 = 40;
pub const LKL_EWOULDBLOCK: u32 = 11;
pub const LKL_ENOMSG: u32 = 42;
pub const LKL_EIDRM: u32 = 43;
pub const LKL_ECHRNG: u32 = 44;
pub const LKL_EL2NSYNC: u32 = 45;
pub const LKL_EL3HLT: u32 = 46;
pub const LKL_EL3RST: u32 = 47;
pub const LKL_ELNRNG: u32 = 48;
pub const LKL_EUNATCH: u32 = 49;
pub const LKL_ENOCSI: u32 = 50;
pub const LKL_EL2HLT: u32 = 51;
pub const LKL_EBADE: u32 = 52;
pub const LKL_EBADR: u32 = 53;
pub const LKL_EXFULL: u32 = 54;
pub const LKL_ENOANO: u32 = 55;
pub const LKL_EBADRQC: u32 = 56;
pub const LKL_EBADSLT: u32 = 57;
pub const LKL_EDEADLOCK: u32 = 35;
pub const LKL_EBFONT: u32 = 59;
pub const LKL_ENOSTR: u32 = 60;
pub const LKL_ENODATA: u32 = 61;
pub const LKL_ETIME: u32 = 62;
pub const LKL_ENOSR: u32 = 63;
pub const LKL_ENONET: u32 = 64;
pub const LKL_ENOPKG: u32 = 65;
pub const LKL_EREMOTE: u32 = 66;
pub const LKL_ENOLINK: u32 = 67;
pub const LKL_EADV: u32 = 68;
pub const LKL_ESRMNT: u32 = 69;
pub const LKL_ECOMM: u32 = 70;
pub const LKL_EPROTO: u32 = 71;
pub const LKL_EMULTIHOP: u32 = 72;
pub const LKL_EDOTDOT: u32 = 73;
pub const LKL_EBADMSG: u32 = 74;
pub const LKL_EOVERFLOW: u32 = 75;
pub const LKL_ENOTUNIQ: u32 = 76;
pub const LKL_EBADFD: u32 = 77;
pub const LKL_EREMCHG: u32 = 78;
pub const LKL_ELIBACC: u32 = 79;
pub const LKL_ELIBBAD: u32 = 80;
pub const LKL_ELIBSCN: u32 = 81;
pub const LKL_ELIBMAX: u32 = 82;
pub const LKL_ELIBEXEC: u32 = 83;
pub const LKL_EILSEQ: u32 = 84;
pub const LKL_ERESTART: u32 = 85;
pub const LKL_ESTRPIPE: u32 = 86;
pub const LKL_EUSERS: u32 = 87;
pub const LKL_ENOTSOCK: u32 = 88;
pub const LKL_EDESTADDRREQ: u32 = 89;
pub const LKL_EMSGSIZE: u32 = 90;
pub const LKL_EPROTOTYPE: u32 = 91;
pub const LKL_ENOPROTOOPT: u32 = 92;
pub const LKL_EPROTONOSUPPORT: u32 = 93;
pub const LKL_ESOCKTNOSUPPORT: u32 = 94;
pub const LKL_EOPNOTSUPP: u32 = 95;
pub const LKL_EPFNOSUPPORT: u32 = 96;
pub const LKL_EAFNOSUPPORT: u32 = 97;
pub const LKL_EADDRINUSE: u32 = 98;
pub const LKL_EADDRNOTAVAIL: u32 = 99;
pub const LKL_ENETDOWN: u32 = 100;
pub const LKL_ENETUNREACH: u32 = 101;
pub const LKL_ENETRESET: u32 = 102;
pub const LKL_ECONNABORTED: u32 = 103;
pub const LKL_ECONNRESET: u32 = 104;
pub const LKL_ENOBUFS: u32 = 105;
pub const LKL_EISCONN: u32 = 106;
pub const LKL_ENOTCONN: u32 = 107;
pub const LKL_ESHUTDOWN: u32 = 108;
pub const LKL_ETOOMANYREFS: u32 = 109;
pub const LKL_ETIMEDOUT: u32 = 110;
pub const LKL_ECONNREFUSED: u32 = 111;
pub const LKL_EHOSTDOWN: u32 = 112;
pub const LKL_EHOSTUNREACH: u32 = 113;
pub const LKL_EALREADY: u32 = 114;
pub const LKL_EINPROGRESS: u32 = 115;
pub const LKL_ESTALE: u32 = 116;
pub const LKL_EUCLEAN: u32 = 117;
pub const LKL_ENOTNAM: u32 = 118;
pub const LKL_ENAVAIL: u32 = 119;
pub const LKL_EISNAM: u32 = 120;
pub const LKL_EREMOTEIO: u32 = 121;
pub const LKL_EDQUOT: u32 = 122;
pub const LKL_ENOMEDIUM: u32 = 123;
pub const LKL_EMEDIUMTYPE: u32 = 124;
pub const LKL_ECANCELED: u32 = 125;
pub const LKL_ENOKEY: u32 = 126;
pub const LKL_EKEYEXPIRED: u32 = 127;
pub const LKL_EKEYREVOKED: u32 = 128;
pub const LKL_EKEYREJECTED: u32 = 129;
pub const LKL_EOWNERDEAD: u32 = 130;
pub const LKL_ENOTRECOVERABLE: u32 = 131;
pub const LKL_ERFKILL: u32 = 132;
pub const LKL_EHWPOISON: u32 = 133;
pub const LKL_O_ACCMODE: u32 = 3;
pub const LKL_O_RDONLY: u32 = 0;
pub const LKL_O_WRONLY: u32 = 1;
pub const LKL_O_RDWR: u32 = 2;
pub const LKL_O_CREAT: u32 = 64;
pub const LKL_O_EXCL: u32 = 128;
pub const LKL_O_NOCTTY: u32 = 256;
pub const LKL_O_TRUNC: u32 = 512;
pub const LKL_O_APPEND: u32 = 1024;
pub const LKL_O_NONBLOCK: u32 = 2048;
pub const LKL_O_DSYNC: u32 = 4096;
pub const LKL_FASYNC: u32 = 8192;
pub const LKL_O_DIRECT: u32 = 16384;
pub const LKL_O_LARGEFILE: u32 = 32768;
pub const LKL_O_DIRECTORY: u32 = 65536;
pub const LKL_O_NOFOLLOW: u32 = 131072;
pub const LKL_O_NOATIME: u32 = 262144;
pub const LKL_O_CLOEXEC: u32 = 524288;
pub const __LKL__O_SYNC: u32 = 1048576;
pub const LKL_O_SYNC: u32 = 1052672;
pub const LKL_O_PATH: u32 = 2097152;
pub const __LKL__O_TMPFILE: u32 = 4194304;
pub const LKL_O_TMPFILE: u32 = 4259840;
pub const LKL_O_TMPFILE_MASK: u32 = 4259904;
pub const LKL_O_NDELAY: u32 = 2048;
pub const LKL_F_DUPFD: u32 = 0;
pub const LKL_F_GETFD: u32 = 1;
pub const LKL_F_SETFD: u32 = 2;
pub const LKL_F_GETFL: u32 = 3;
pub const LKL_F_SETFL: u32 = 4;
pub const LKL_F_GETLK: u32 = 5;
pub const LKL_F_SETLK: u32 = 6;
pub const LKL_F_SETLKW: u32 = 7;
pub const LKL_F_SETOWN: u32 = 8;
pub const LKL_F_GETOWN: u32 = 9;
pub const LKL_F_SETSIG: u32 = 10;
pub const LKL_F_GETSIG: u32 = 11;
pub const LKL_F_SETOWN_EX: u32 = 15;
pub const LKL_F_GETOWN_EX: u32 = 16;
pub const LKL_F_GETOWNER_UIDS: u32 = 17;
pub const LKL_F_OFD_GETLK: u32 = 36;
pub const LKL_F_OFD_SETLK: u32 = 37;
pub const LKL_F_OFD_SETLKW: u32 = 38;
pub const LKL_F_OWNER_TID: u32 = 0;
pub const LKL_F_OWNER_PID: u32 = 1;
pub const LKL_F_OWNER_PGRP: u32 = 2;
pub const LKL_FD_CLOEXEC: u32 = 1;
pub const LKL_F_RDLCK: u32 = 0;
pub const LKL_F_WRLCK: u32 = 1;
pub const LKL_F_UNLCK: u32 = 2;
pub const LKL_F_EXLCK: u32 = 4;
pub const LKL_F_SHLCK: u32 = 8;
pub const LKL_LOCK_SH: u32 = 1;
pub const LKL_LOCK_EX: u32 = 2;
pub const LKL_LOCK_NB: u32 = 4;
pub const LKL_LOCK_UN: u32 = 8;
pub const LKL_LOCK_MAND: u32 = 32;
pub const LKL_LOCK_READ: u32 = 64;
pub const LKL_LOCK_WRITE: u32 = 128;
pub const LKL_LOCK_RW: u32 = 192;
pub const LKL_F_LINUX_SPECIFIC_BASE: u32 = 1024;
pub const LKL_RESOLVE_NO_XDEV: u32 = 1;
pub const LKL_RESOLVE_NO_MAGICLINKS: u32 = 2;
pub const LKL_RESOLVE_NO_SYMLINKS: u32 = 4;
pub const LKL_RESOLVE_BENEATH: u32 = 8;
pub const LKL_RESOLVE_IN_ROOT: u32 = 16;
pub const LKL_F_SETLEASE: u32 = 1024;
pub const LKL_F_GETLEASE: u32 = 1025;
pub const LKL_F_CANCELLK: u32 = 1029;
pub const LKL_F_DUPFD_CLOEXEC: u32 = 1030;
pub const LKL_F_NOTIFY: u32 = 1026;
pub const LKL_F_SETPIPE_SZ: u32 = 1031;
pub const LKL_F_GETPIPE_SZ: u32 = 1032;
pub const LKL_F_ADD_SEALS: u32 = 1033;
pub const LKL_F_GET_SEALS: u32 = 1034;
pub const LKL_F_SEAL_SEAL: u32 = 1;
pub const LKL_F_SEAL_SHRINK: u32 = 2;
pub const LKL_F_SEAL_GROW: u32 = 4;
pub const LKL_F_SEAL_WRITE: u32 = 8;
pub const LKL_F_SEAL_FUTURE_WRITE: u32 = 16;
pub const LKL_F_GET_RW_HINT: u32 = 1035;
pub const LKL_F_SET_RW_HINT: u32 = 1036;
pub const LKL_F_GET_FILE_RW_HINT: u32 = 1037;
pub const LKL_F_SET_FILE_RW_HINT: u32 = 1038;
pub const LKL_RWH_WRITE_LIFE_NOT_SET: u32 = 0;
pub const LKL_RWH_WRITE_LIFE_NONE: u32 = 1;
pub const LKL_RWH_WRITE_LIFE_SHORT: u32 = 2;
pub const LKL_RWH_WRITE_LIFE_MEDIUM: u32 = 3;
pub const LKL_RWH_WRITE_LIFE_LONG: u32 = 4;
pub const LKL_RWH_WRITE_LIFE_EXTREME: u32 = 5;
pub const LKL_RWF_WRITE_LIFE_NOT_SET: u32 = 0;
pub const LKL_DN_ACCESS: u32 = 1;
pub const LKL_DN_MODIFY: u32 = 2;
pub const LKL_DN_CREATE: u32 = 4;
pub const LKL_DN_DELETE: u32 = 8;
pub const LKL_DN_RENAME: u32 = 16;
pub const LKL_DN_ATTRIB: u32 = 32;
pub const LKL_DN_MULTISHOT: u32 = 2147483648;
pub const LKL_AT_FDCWD: i32 = -100;
pub const LKL_AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const LKL_AT_EACCESS: u32 = 512;
pub const LKL_AT_REMOVEDIR: u32 = 512;
pub const LKL_AT_SYMLINK_FOLLOW: u32 = 1024;
pub const LKL_AT_NO_AUTOMOUNT: u32 = 2048;
pub const LKL_AT_EMPTY_PATH: u32 = 4096;
pub const LKL_AT_STATX_SYNC_TYPE: u32 = 24576;
pub const LKL_AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const LKL_AT_STATX_FORCE_SYNC: u32 = 8192;
pub const LKL_AT_STATX_DONT_SYNC: u32 = 16384;
pub const LKL_AT_RECURSIVE: u32 = 32768;
pub const LKL_NR_OPEN: u32 = 1024;
pub const LKL_NGROUPS_MAX: u32 = 65536;
pub const LKL_ARG_MAX: u32 = 131072;
pub const LKL_LINK_MAX: u32 = 127;
pub const LKL_MAX_CANON: u32 = 255;
pub const LKL_MAX_INPUT: u32 = 255;
pub const LKL_NAME_MAX: u32 = 255;
pub const LKL_PATH_MAX: u32 = 4096;
pub const LKL_PIPE_BUF: u32 = 4096;
pub const LKL_XATTR_NAME_MAX: u32 = 255;
pub const LKL_XATTR_SIZE_MAX: u32 = 65536;
pub const LKL_XATTR_LIST_MAX: u32 = 65536;
pub const LKL_RTSIG_MAX: u32 = 32;
pub const _LKL_IOC_NRBITS: u32 = 8;
pub const _LKL_IOC_TYPEBITS: u32 = 8;
pub const _LKL_IOC_SIZEBITS: u32 = 14;
pub const _LKL_IOC_DIRBITS: u32 = 2;
pub const _LKL_IOC_NRMASK: u32 = 255;
pub const _LKL_IOC_TYPEMASK: u32 = 255;
pub const _LKL_IOC_SIZEMASK: u32 = 16383;
pub const _LKL_IOC_DIRMASK: u32 = 3;
pub const _LKL_IOC_NRSHIFT: u32 = 0;
pub const _LKL_IOC_TYPESHIFT: u32 = 8;
pub const _LKL_IOC_SIZESHIFT: u32 = 16;
pub const _LKL_IOC_DIRSHIFT: u32 = 30;
pub const _LKL_IOC_NONE: u32 = 0;
pub const _LKL_IOC_WRITE: u32 = 1;
pub const _LKL_IOC_READ: u32 = 2;
pub const LKL_IOC_IN: u32 = 1073741824;
pub const LKL_IOC_OUT: u32 = 2147483648;
pub const LKL_IOC_INOUT: u32 = 3221225472;
pub const LKL_IOCSIZE_MASK: u32 = 1073676288;
pub const LKL_IOCSIZE_SHIFT: u32 = 16;
pub const LKL_FSCRYPT_POLICY_FLAGS_PAD_4: u32 = 0;
pub const LKL_FSCRYPT_POLICY_FLAGS_PAD_8: u32 = 1;
pub const LKL_FSCRYPT_POLICY_FLAGS_PAD_16: u32 = 2;
pub const LKL_FSCRYPT_POLICY_FLAGS_PAD_32: u32 = 3;
pub const LKL_FSCRYPT_POLICY_FLAGS_PAD_MASK: u32 = 3;
pub const LKL_FSCRYPT_POLICY_FLAG_DIRECT_KEY: u32 = 4;
pub const LKL_FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64: u32 = 8;
pub const LKL_FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32: u32 = 16;
pub const LKL_FSCRYPT_POLICY_FLAGS_VALID: u32 = 31;
pub const LKL_FSCRYPT_MODE_AES_256_XTS: u32 = 1;
pub const LKL_FSCRYPT_MODE_AES_256_CTS: u32 = 4;
pub const LKL_FSCRYPT_MODE_AES_128_CBC: u32 = 5;
pub const LKL_FSCRYPT_MODE_AES_128_CTS: u32 = 6;
pub const LKL_FSCRYPT_MODE_ADIANTUM: u32 = 9;
pub const __LKL__FSCRYPT_MODE_MAX: u32 = 9;
pub const LKL_FSCRYPT_POLICY_V1: u32 = 0;
pub const LKL_FSCRYPT_KEY_DESCRIPTOR_SIZE: u32 = 8;
pub const LKL_FSCRYPT_KEY_DESC_PREFIX: &'static [u8; 9usize] = b"fscrypt:\0";
pub const LKL_FSCRYPT_KEY_DESC_PREFIX_SIZE: u32 = 8;
pub const LKL_FSCRYPT_MAX_KEY_SIZE: u32 = 64;
pub const LKL_FSCRYPT_POLICY_V2: u32 = 2;
pub const LKL_FSCRYPT_KEY_IDENTIFIER_SIZE: u32 = 16;
pub const LKL_FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR: u32 = 1;
pub const LKL_FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER: u32 = 2;
pub const LKL_FSCRYPT_KEY_REMOVAL_STATUS_FLAG_FILES_BUSY: u32 = 1;
pub const LKL_FSCRYPT_KEY_REMOVAL_STATUS_FLAG_OTHER_USERS: u32 = 2;
pub const LKL_FSCRYPT_KEY_STATUS_ABSENT: u32 = 1;
pub const LKL_FSCRYPT_KEY_STATUS_PRESENT: u32 = 2;
pub const LKL_FSCRYPT_KEY_STATUS_INCOMPLETELY_REMOVED: u32 = 3;
pub const LKL_FSCRYPT_KEY_STATUS_FLAG_ADDED_BY_SELF: u32 = 1;
pub const LKL_FS_KEY_DESCRIPTOR_SIZE: u32 = 8;
pub const LKL_FS_POLICY_FLAGS_PAD_4: u32 = 0;
pub const LKL_FS_POLICY_FLAGS_PAD_8: u32 = 1;
pub const LKL_FS_POLICY_FLAGS_PAD_16: u32 = 2;
pub const LKL_FS_POLICY_FLAGS_PAD_32: u32 = 3;
pub const LKL_FS_POLICY_FLAGS_PAD_MASK: u32 = 3;
pub const LKL_FS_POLICY_FLAG_DIRECT_KEY: u32 = 4;
pub const LKL_FS_POLICY_FLAGS_VALID: u32 = 31;
pub const LKL_FS_ENCRYPTION_MODE_INVALID: u32 = 0;
pub const LKL_FS_ENCRYPTION_MODE_AES_256_XTS: u32 = 1;
pub const LKL_FS_ENCRYPTION_MODE_AES_256_GCM: u32 = 2;
pub const LKL_FS_ENCRYPTION_MODE_AES_256_CBC: u32 = 3;
pub const LKL_FS_ENCRYPTION_MODE_AES_256_CTS: u32 = 4;
pub const LKL_FS_ENCRYPTION_MODE_AES_128_CBC: u32 = 5;
pub const LKL_FS_ENCRYPTION_MODE_AES_128_CTS: u32 = 6;
pub const LKL_FS_ENCRYPTION_MODE_SPECK128_256_XTS: u32 = 7;
pub const LKL_FS_ENCRYPTION_MODE_SPECK128_256_CTS: u32 = 8;
pub const LKL_FS_ENCRYPTION_MODE_ADIANTUM: u32 = 9;
pub const LKL_FS_KEY_DESC_PREFIX: &'static [u8; 9usize] = b"fscrypt:\0";
pub const LKL_FS_KEY_DESC_PREFIX_SIZE: u32 = 8;
pub const LKL_FS_MAX_KEY_SIZE: u32 = 64;
pub const LKL_MS_RDONLY: u32 = 1;
pub const LKL_MS_NOSUID: u32 = 2;
pub const LKL_MS_NODEV: u32 = 4;
pub const LKL_MS_NOEXEC: u32 = 8;
pub const LKL_MS_SYNCHRONOUS: u32 = 16;
pub const LKL_MS_REMOUNT: u32 = 32;
pub const LKL_MS_MANDLOCK: u32 = 64;
pub const LKL_MS_DIRSYNC: u32 = 128;
pub const LKL_MS_NOSYMFOLLOW: u32 = 256;
pub const LKL_MS_NOATIME: u32 = 1024;
pub const LKL_MS_NODIRATIME: u32 = 2048;
pub const LKL_MS_BIND: u32 = 4096;
pub const LKL_MS_MOVE: u32 = 8192;
pub const LKL_MS_REC: u32 = 16384;
pub const LKL_MS_VERBOSE: u32 = 32768;
pub const LKL_MS_SILENT: u32 = 32768;
pub const LKL_MS_POSIXACL: u32 = 65536;
pub const LKL_MS_UNBINDABLE: u32 = 131072;
pub const LKL_MS_PRIVATE: u32 = 262144;
pub const LKL_MS_SLAVE: u32 = 524288;
pub const LKL_MS_SHARED: u32 = 1048576;
pub const LKL_MS_RELATIME: u32 = 2097152;
pub const LKL_MS_KERNMOUNT: u32 = 4194304;
pub const LKL_MS_I_VERSION: u32 = 8388608;
pub const LKL_MS_STRICTATIME: u32 = 16777216;
pub const LKL_MS_LAZYTIME: u32 = 33554432;
pub const LKL_MS_SUBMOUNT: u32 = 67108864;
pub const LKL_MS_NOREMOTELOCK: u32 = 134217728;
pub const LKL_MS_NOSEC: u32 = 268435456;
pub const LKL_MS_BORN: u32 = 536870912;
pub const LKL_MS_ACTIVE: u32 = 1073741824;
pub const LKL_MS_NOUSER: u32 = 2147483648;
pub const LKL_MS_RMT_MASK: u32 = 41943121;
pub const LKL_MS_MGC_VAL: u32 = 3236757504;
pub const LKL_MS_MGC_MSK: u32 = 4294901760;
pub const LKL_OPEN_TREE_CLONE: u32 = 1;
pub const LKL_OPEN_TREE_CLOEXEC: u32 = 524288;
pub const LKL_MOVE_MOUNT_F_SYMLINKS: u32 = 1;
pub const LKL_MOVE_MOUNT_F_AUTOMOUNTS: u32 = 2;
pub const LKL_MOVE_MOUNT_F_EMPTY_PATH: u32 = 4;
pub const LKL_MOVE_MOUNT_T_SYMLINKS: u32 = 16;
pub const LKL_MOVE_MOUNT_T_AUTOMOUNTS: u32 = 32;
pub const LKL_MOVE_MOUNT_T_EMPTY_PATH: u32 = 64;
pub const LKL_MOVE_MOUNT__MASK: u32 = 119;
pub const LKL_FSOPEN_CLOEXEC: u32 = 1;
pub const LKL_FSPICK_CLOEXEC: u32 = 1;
pub const LKL_FSPICK_SYMLINK_NOFOLLOW: u32 = 2;
pub const LKL_FSPICK_NO_AUTOMOUNT: u32 = 4;
pub const LKL_FSPICK_EMPTY_PATH: u32 = 8;
pub const LKL_FSMOUNT_CLOEXEC: u32 = 1;
pub const LKL_MOUNT_ATTR_RDONLY: u32 = 1;
pub const LKL_MOUNT_ATTR_NOSUID: u32 = 2;
pub const LKL_MOUNT_ATTR_NODEV: u32 = 4;
pub const LKL_MOUNT_ATTR_NOEXEC: u32 = 8;
pub const LKL_MOUNT_ATTR__ATIME: u32 = 112;
pub const LKL_MOUNT_ATTR_RELATIME: u32 = 0;
pub const LKL_MOUNT_ATTR_NOATIME: u32 = 16;
pub const LKL_MOUNT_ATTR_STRICTATIME: u32 = 32;
pub const LKL_MOUNT_ATTR_NODIRATIME: u32 = 128;
pub const LKL_INR_OPEN_CUR: u32 = 1024;
pub const LKL_INR_OPEN_MAX: u32 = 4096;
pub const LKL_BLOCK_SIZE_BITS: u32 = 10;
pub const LKL_BLOCK_SIZE: u32 = 1024;
pub const LKL_SEEK_SET: u32 = 0;
pub const LKL_SEEK_CUR: u32 = 1;
pub const LKL_SEEK_END: u32 = 2;
pub const LKL_SEEK_DATA: u32 = 3;
pub const LKL_SEEK_HOLE: u32 = 4;
pub const LKL_SEEK_MAX: u32 = 4;
pub const LKL_RENAME_NOREPLACE: u32 = 1;
pub const LKL_RENAME_EXCHANGE: u32 = 2;
pub const LKL_RENAME_WHITEOUT: u32 = 4;
pub const LKL_FILE_DEDUPE_RANGE_SAME: u32 = 0;
pub const LKL_FILE_DEDUPE_RANGE_DIFFERS: u32 = 1;
pub const LKL_NR_FILE: u32 = 8192;
pub const LKL_FS_XFLAG_REALTIME: u32 = 1;
pub const LKL_FS_XFLAG_PREALLOC: u32 = 2;
pub const LKL_FS_XFLAG_IMMUTABLE: u32 = 8;
pub const LKL_FS_XFLAG_APPEND: u32 = 16;
pub const LKL_FS_XFLAG_SYNC: u32 = 32;
pub const LKL_FS_XFLAG_NOATIME: u32 = 64;
pub const LKL_FS_XFLAG_NODUMP: u32 = 128;
pub const LKL_FS_XFLAG_RTINHERIT: u32 = 256;
pub const LKL_FS_XFLAG_PROJINHERIT: u32 = 512;
pub const LKL_FS_XFLAG_NOSYMLINKS: u32 = 1024;
pub const LKL_FS_XFLAG_EXTSIZE: u32 = 2048;
pub const LKL_FS_XFLAG_EXTSZINHERIT: u32 = 4096;
pub const LKL_FS_XFLAG_NODEFRAG: u32 = 8192;
pub const LKL_FS_XFLAG_FILESTREAM: u32 = 16384;
pub const LKL_FS_XFLAG_DAX: u32 = 32768;
pub const LKL_FS_XFLAG_COWEXTSIZE: u32 = 65536;
pub const LKL_FS_XFLAG_HASATTR: u32 = 2147483648;
pub const LKL_BMAP_IOCTL: u32 = 1;
pub const LKL_FSLABEL_MAX: u32 = 256;
pub const LKL_FS_SECRM_FL: u32 = 1;
pub const LKL_FS_UNRM_FL: u32 = 2;
pub const LKL_FS_COMPR_FL: u32 = 4;
pub const LKL_FS_SYNC_FL: u32 = 8;
pub const LKL_FS_IMMUTABLE_FL: u32 = 16;
pub const LKL_FS_APPEND_FL: u32 = 32;
pub const LKL_FS_NODUMP_FL: u32 = 64;
pub const LKL_FS_NOATIME_FL: u32 = 128;
pub const LKL_FS_DIRTY_FL: u32 = 256;
pub const LKL_FS_COMPRBLK_FL: u32 = 512;
pub const LKL_FS_NOCOMP_FL: u32 = 1024;
pub const LKL_FS_ENCRYPT_FL: u32 = 2048;
pub const LKL_FS_BTREE_FL: u32 = 4096;
pub const LKL_FS_INDEX_FL: u32 = 4096;
pub const LKL_FS_IMAGIC_FL: u32 = 8192;
pub const LKL_FS_JOURNAL_DATA_FL: u32 = 16384;
pub const LKL_FS_NOTAIL_FL: u32 = 32768;
pub const LKL_FS_DIRSYNC_FL: u32 = 65536;
pub const LKL_FS_TOPDIR_FL: u32 = 131072;
pub const LKL_FS_HUGE_FILE_FL: u32 = 262144;
pub const LKL_FS_EXTENT_FL: u32 = 524288;
pub const LKL_FS_VERITY_FL: u32 = 1048576;
pub const LKL_FS_EA_INODE_FL: u32 = 2097152;
pub const LKL_FS_EOFBLOCKS_FL: u32 = 4194304;
pub const LKL_FS_NOCOW_FL: u32 = 8388608;
pub const LKL_FS_DAX_FL: u32 = 33554432;
pub const LKL_FS_INLINE_DATA_FL: u32 = 268435456;
pub const LKL_FS_PROJINHERIT_FL: u32 = 536870912;
pub const LKL_FS_CASEFOLD_FL: u32 = 1073741824;
pub const LKL_FS_RESERVED_FL: u32 = 2147483648;
pub const LKL_FS_FL_USER_VISIBLE: u32 = 253951;
pub const LKL_FS_FL_USER_MODIFIABLE: u32 = 229631;
pub const LKL_SYNC_FILE_RANGE_WAIT_BEFORE: u32 = 1;
pub const LKL_SYNC_FILE_RANGE_WRITE: u32 = 2;
pub const LKL_SYNC_FILE_RANGE_WAIT_AFTER: u32 = 4;
pub const LKL_SYNC_FILE_RANGE_WRITE_AND_WAIT: u32 = 7;
pub const LKL_STAT_HAVE_NSEC: u32 = 1;
pub const LKL_BPF_LD: u32 = 0;
pub const LKL_BPF_LDX: u32 = 1;
pub const LKL_BPF_ST: u32 = 2;
pub const LKL_BPF_STX: u32 = 3;
pub const LKL_BPF_ALU: u32 = 4;
pub const LKL_BPF_JMP: u32 = 5;
pub const LKL_BPF_RET: u32 = 6;
pub const LKL_BPF_MISC: u32 = 7;
pub const LKL_BPF_W: u32 = 0;
pub const LKL_BPF_H: u32 = 8;
pub const LKL_BPF_B: u32 = 16;
pub const LKL_BPF_IMM: u32 = 0;
pub const LKL_BPF_ABS: u32 = 32;
pub const LKL_BPF_IND: u32 = 64;
pub const LKL_BPF_MEM: u32 = 96;
pub const LKL_BPF_LEN: u32 = 128;
pub const LKL_BPF_MSH: u32 = 160;
pub const LKL_BPF_ADD: u32 = 0;
pub const LKL_BPF_SUB: u32 = 16;
pub const LKL_BPF_MUL: u32 = 32;
pub const LKL_BPF_DIV: u32 = 48;
pub const LKL_BPF_OR: u32 = 64;
pub const LKL_BPF_AND: u32 = 80;
pub const LKL_BPF_LSH: u32 = 96;
pub const LKL_BPF_RSH: u32 = 112;
pub const LKL_BPF_NEG: u32 = 128;
pub const LKL_BPF_MOD: u32 = 144;
pub const LKL_BPF_XOR: u32 = 160;
pub const LKL_BPF_JA: u32 = 0;
pub const LKL_BPF_JEQ: u32 = 16;
pub const LKL_BPF_JGT: u32 = 32;
pub const LKL_BPF_JGE: u32 = 48;
pub const LKL_BPF_JSET: u32 = 64;
pub const LKL_BPF_K: u32 = 0;
pub const LKL_BPF_X: u32 = 8;
pub const LKL_BPF_MAXINSNS: u32 = 4096;
pub const LKL_BPF_JMP32: u32 = 6;
pub const LKL_BPF_ALU64: u32 = 7;
pub const LKL_BPF_DW: u32 = 24;
pub const LKL_BPF_XADD: u32 = 192;
pub const LKL_BPF_MOV: u32 = 176;
pub const LKL_BPF_ARSH: u32 = 192;
pub const LKL_BPF_END: u32 = 208;
pub const LKL_BPF_TO_LE: u32 = 0;
pub const LKL_BPF_TO_BE: u32 = 8;
pub const LKL_BPF_FROM_LE: u32 = 0;
pub const LKL_BPF_FROM_BE: u32 = 8;
pub const LKL_BPF_JNE: u32 = 80;
pub const LKL_BPF_JLT: u32 = 160;
pub const LKL_BPF_JLE: u32 = 176;
pub const LKL_BPF_JSGT: u32 = 96;
pub const LKL_BPF_JSGE: u32 = 112;
pub const LKL_BPF_JSLT: u32 = 192;
pub const LKL_BPF_JSLE: u32 = 208;
pub const LKL_BPF_CALL: u32 = 128;
pub const LKL_BPF_EXIT: u32 = 144;
pub const LKL_BPF_F_ALLOW_OVERRIDE: u32 = 1;
pub const LKL_BPF_F_ALLOW_MULTI: u32 = 2;
pub const LKL_BPF_F_REPLACE: u32 = 4;
pub const LKL_BPF_F_STRICT_ALIGNMENT: u32 = 1;
pub const LKL_BPF_F_ANY_ALIGNMENT: u32 = 2;
pub const LKL_BPF_F_TEST_RND_HI32: u32 = 4;
pub const LKL_BPF_F_TEST_STATE_FREQ: u32 = 8;
pub const LKL_BPF_F_SLEEPABLE: u32 = 16;
pub const LKL_BPF_PSEUDO_MAP_FD: u32 = 1;
pub const LKL_BPF_PSEUDO_MAP_VALUE: u32 = 2;
pub const LKL_BPF_PSEUDO_BTF_ID: u32 = 3;
pub const LKL_BPF_PSEUDO_CALL: u32 = 1;
pub const LKL_BPF_F_QUERY_EFFECTIVE: u32 = 1;
pub const LKL_BPF_F_TEST_RUN_ON_CPU: u32 = 1;
pub const LKL_BPF_BUILD_ID_SIZE: u32 = 20;
pub const LKL_BPF_OBJ_NAME_LEN: u32 = 16;
pub const LKL_XDP_PACKET_HEADROOM: u32 = 256;
pub const LKL_BPF_TAG_SIZE: u32 = 8;
pub const LKL_IPC_CREAT: u32 = 512;
pub const LKL_IPC_EXCL: u32 = 1024;
pub const LKL_IPC_NOWAIT: u32 = 2048;
pub const LKL_IPC_DIPC: u32 = 4096;
pub const LKL_IPC_OWN: u32 = 8192;
pub const LKL_IPC_RMID: u32 = 0;
pub const LKL_IPC_SET: u32 = 1;
pub const LKL_IPC_STAT: u32 = 2;
pub const LKL_IPC_INFO: u32 = 3;
pub const LKL_IPC_OLD: u32 = 0;
pub const LKL_IPC_64: u32 = 256;
pub const LKL_SEMOP: u32 = 1;
pub const LKL_SEMGET: u32 = 2;
pub const LKL_SEMCTL: u32 = 3;
pub const LKL_SEMTIMEDOP: u32 = 4;
pub const LKL_MSGSND: u32 = 11;
pub const LKL_MSGRCV: u32 = 12;
pub const LKL_MSGGET: u32 = 13;
pub const LKL_MSGCTL: u32 = 14;
pub const LKL_SHMAT: u32 = 21;
pub const LKL_SHMDT: u32 = 22;
pub const LKL_SHMGET: u32 = 23;
pub const LKL_SHMCTL: u32 = 24;
pub const LKL_DIPC: u32 = 25;
pub const LKL_MSG_STAT: u32 = 11;
pub const LKL_MSG_INFO: u32 = 12;
pub const LKL_MSG_STAT_ANY: u32 = 13;
pub const LKL_MSG_NOERROR: u32 = 4096;
pub const LKL_MSG_EXCEPT: u32 = 8192;
pub const LKL_MSG_COPY: u32 = 16384;
pub const LKL_MSGMNI: u32 = 32000;
pub const LKL_MSGMAX: u32 = 8192;
pub const LKL_MSGMNB: u32 = 16384;
pub const LKL_MSGPOOL: u32 = 512000;
pub const LKL_MSGTQL: u32 = 16384;
pub const LKL_MSGMAP: u32 = 16384;
pub const LKL_MSGSSZ: u32 = 16;
pub const __LKL__MSGSEG: u32 = 32768000;
pub const LKL_RUSAGE_SELF: u32 = 0;
pub const LKL_RUSAGE_CHILDREN: i32 = -1;
pub const LKL_RUSAGE_BOTH: i32 = -2;
pub const LKL_RUSAGE_THREAD: u32 = 1;
pub const LKL_RLIM64_INFINITY: i32 = -1;
pub const LKL_PRIO_MIN: i32 = -20;
pub const LKL_PRIO_MAX: u32 = 20;
pub const LKL_PRIO_PROCESS: u32 = 0;
pub const LKL_PRIO_PGRP: u32 = 1;
pub const LKL_PRIO_USER: u32 = 2;
pub const _LKL_STK_LIM: u32 = 8388608;
pub const LKL_RLIMIT_CPU: u32 = 0;
pub const LKL_RLIMIT_FSIZE: u32 = 1;
pub const LKL_RLIMIT_DATA: u32 = 2;
pub const LKL_RLIMIT_STACK: u32 = 3;
pub const LKL_RLIMIT_CORE: u32 = 4;
pub const LKL_RLIMIT_RSS: u32 = 5;
pub const LKL_RLIMIT_NPROC: u32 = 6;
pub const LKL_RLIMIT_NOFILE: u32 = 7;
pub const LKL_RLIMIT_MEMLOCK: u32 = 8;
pub const LKL_RLIMIT_AS: u32 = 9;
pub const LKL_RLIMIT_LOCKS: u32 = 10;
pub const LKL_RLIMIT_SIGPENDING: u32 = 11;
pub const LKL_RLIMIT_MSGQUEUE: u32 = 12;
pub const LKL_RLIMIT_NICE: u32 = 13;
pub const LKL_RLIMIT_RTPRIO: u32 = 14;
pub const LKL_RLIMIT_RTTIME: u32 = 15;
pub const LKL_RLIM_NLIMITS: u32 = 16;
pub const LKL_RLIM_INFINITY: i32 = -1;
pub const LKL_SI_LOAD_SHIFT: u32 = 16;
pub const LKL_HUGETLB_FLAG_ENCODE_SHIFT: u32 = 26;
pub const LKL_HUGETLB_FLAG_ENCODE_MASK: u32 = 63;
pub const LKL_HUGETLB_FLAG_ENCODE_16KB: u32 = 939524096;
pub const LKL_HUGETLB_FLAG_ENCODE_64KB: u32 = 1073741824;
pub const LKL_HUGETLB_FLAG_ENCODE_512KB: u32 = 1275068416;
pub const LKL_HUGETLB_FLAG_ENCODE_1MB: u32 = 1342177280;
pub const LKL_HUGETLB_FLAG_ENCODE_2MB: u32 = 1409286144;
pub const LKL_HUGETLB_FLAG_ENCODE_8MB: u32 = 1543503872;
pub const LKL_HUGETLB_FLAG_ENCODE_16MB: u32 = 1610612736;
pub const LKL_HUGETLB_FLAG_ENCODE_32MB: u32 = 1677721600;
pub const LKL_HUGETLB_FLAG_ENCODE_256MB: u32 = 1879048192;
pub const LKL_HUGETLB_FLAG_ENCODE_512MB: u32 = 1946157056;
pub const LKL_HUGETLB_FLAG_ENCODE_1GB: u32 = 2013265920;
pub const LKL_HUGETLB_FLAG_ENCODE_2GB: u32 = 2080374784;
pub const LKL_HUGETLB_FLAG_ENCODE_16GB: u32 = 2281701376;
pub const _UNISTD_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &'static [u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const LKL_SHMMIN: u32 = 1;
pub const LKL_SHMMNI: u32 = 4096;
pub const LKL_SHMSEG: u32 = 4096;
pub const LKL_SHM_R: u32 = 256;
pub const LKL_SHM_W: u32 = 128;
pub const LKL_SHM_HUGETLB: u32 = 2048;
pub const LKL_SHM_NORESERVE: u32 = 4096;
pub const LKL_SHM_HUGE_SHIFT: u32 = 26;
pub const LKL_SHM_HUGE_MASK: u32 = 63;
pub const LKL_SHM_HUGE_64KB: u32 = 1073741824;
pub const LKL_SHM_HUGE_512KB: u32 = 1275068416;
pub const LKL_SHM_HUGE_1MB: u32 = 1342177280;
pub const LKL_SHM_HUGE_2MB: u32 = 1409286144;
pub const LKL_SHM_HUGE_8MB: u32 = 1543503872;
pub const LKL_SHM_HUGE_16MB: u32 = 1610612736;
pub const LKL_SHM_HUGE_32MB: u32 = 1677721600;
pub const LKL_SHM_HUGE_256MB: u32 = 1879048192;
pub const LKL_SHM_HUGE_512MB: u32 = 1946157056;
pub const LKL_SHM_HUGE_1GB: u32 = 2013265920;
pub const LKL_SHM_HUGE_2GB: u32 = 2080374784;
pub const LKL_SHM_HUGE_16GB: u32 = 2281701376;
pub const LKL_SHM_RDONLY: u32 = 4096;
pub const LKL_SHM_RND: u32 = 8192;
pub const LKL_SHM_REMAP: u32 = 16384;
pub const LKL_SHM_EXEC: u32 = 32768;
pub const LKL_SHM_LOCK: u32 = 11;
pub const LKL_SHM_UNLOCK: u32 = 12;
pub const LKL_SHM_STAT: u32 = 13;
pub const LKL_SHM_INFO: u32 = 14;
pub const LKL_SHM_STAT_ANY: u32 = 15;
pub const __LKL__LITTLE_ENDIAN: u32 = 1234;
pub const LKL_IOCB_FLAG_RESFD: u32 = 1;
pub const LKL_IOCB_FLAG_IOPRIO: u32 = 2;
pub const _LKL_K_SS_MAXSIZE: u32 = 128;
pub const LKL_PERF_ATTR_SIZE_VER0: u32 = 64;
pub const LKL_PERF_ATTR_SIZE_VER1: u32 = 72;
pub const LKL_PERF_ATTR_SIZE_VER2: u32 = 80;
pub const LKL_PERF_ATTR_SIZE_VER3: u32 = 96;
pub const LKL_PERF_ATTR_SIZE_VER4: u32 = 104;
pub const LKL_PERF_ATTR_SIZE_VER5: u32 = 112;
pub const LKL_PERF_ATTR_SIZE_VER6: u32 = 120;
pub const LKL_PERF_RECORD_MISC_CPUMODE_MASK: u32 = 7;
pub const LKL_PERF_RECORD_MISC_CPUMODE_UNKNOWN: u32 = 0;
pub const LKL_PERF_RECORD_MISC_KERNEL: u32 = 1;
pub const LKL_PERF_RECORD_MISC_USER: u32 = 2;
pub const LKL_PERF_RECORD_MISC_HYPERVISOR: u32 = 3;
pub const LKL_PERF_RECORD_MISC_GUEST_KERNEL: u32 = 4;
pub const LKL_PERF_RECORD_MISC_GUEST_USER: u32 = 5;
pub const LKL_PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT: u32 = 4096;
pub const LKL_PERF_RECORD_MISC_MMAP_DATA: u32 = 8192;
pub const LKL_PERF_RECORD_MISC_COMM_EXEC: u32 = 8192;
pub const LKL_PERF_RECORD_MISC_FORK_EXEC: u32 = 8192;
pub const LKL_PERF_RECORD_MISC_SWITCH_OUT: u32 = 8192;
pub const LKL_PERF_RECORD_MISC_EXACT_IP: u32 = 16384;
pub const LKL_PERF_RECORD_MISC_SWITCH_OUT_PREEMPT: u32 = 16384;
pub const LKL_PERF_RECORD_MISC_EXT_RESERVED: u32 = 32768;
pub const LKL_PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER: u32 = 1;
pub const LKL_PERF_MAX_STACK_DEPTH: u32 = 127;
pub const LKL_PERF_MAX_CONTEXTS_PER_STACK: u32 = 8;
pub const LKL_PERF_AUX_FLAG_TRUNCATED: u32 = 1;
pub const LKL_PERF_AUX_FLAG_OVERWRITE: u32 = 2;
pub const LKL_PERF_AUX_FLAG_PARTIAL: u32 = 4;
pub const LKL_PERF_AUX_FLAG_COLLISION: u32 = 8;
pub const LKL_PERF_FLAG_FD_NO_GROUP: u32 = 1;
pub const LKL_PERF_FLAG_FD_OUTPUT: u32 = 2;
pub const LKL_PERF_FLAG_PID_CGROUP: u32 = 4;
pub const LKL_PERF_FLAG_FD_CLOEXEC: u32 = 8;
pub const LKL_PERF_MEM_OP_NA: u32 = 1;
pub const LKL_PERF_MEM_OP_LOAD: u32 = 2;
pub const LKL_PERF_MEM_OP_STORE: u32 = 4;
pub const LKL_PERF_MEM_OP_PFETCH: u32 = 8;
pub const LKL_PERF_MEM_OP_EXEC: u32 = 16;
pub const LKL_PERF_MEM_OP_SHIFT: u32 = 0;
pub const LKL_PERF_MEM_LVL_NA: u32 = 1;
pub const LKL_PERF_MEM_LVL_HIT: u32 = 2;
pub const LKL_PERF_MEM_LVL_MISS: u32 = 4;
pub const LKL_PERF_MEM_LVL_L1: u32 = 8;
pub const LKL_PERF_MEM_LVL_LFB: u32 = 16;
pub const LKL_PERF_MEM_LVL_L2: u32 = 32;
pub const LKL_PERF_MEM_LVL_L3: u32 = 64;
pub const LKL_PERF_MEM_LVL_LOC_RAM: u32 = 128;
pub const LKL_PERF_MEM_LVL_REM_RAM1: u32 = 256;
pub const LKL_PERF_MEM_LVL_REM_RAM2: u32 = 512;
pub const LKL_PERF_MEM_LVL_REM_CCE1: u32 = 1024;
pub const LKL_PERF_MEM_LVL_REM_CCE2: u32 = 2048;
pub const LKL_PERF_MEM_LVL_IO: u32 = 4096;
pub const LKL_PERF_MEM_LVL_UNC: u32 = 8192;
pub const LKL_PERF_MEM_LVL_SHIFT: u32 = 5;
pub const LKL_PERF_MEM_REMOTE_REMOTE: u32 = 1;
pub const LKL_PERF_MEM_REMOTE_SHIFT: u32 = 37;
pub const LKL_PERF_MEM_LVLNUM_L1: u32 = 1;
pub const LKL_PERF_MEM_LVLNUM_L2: u32 = 2;
pub const LKL_PERF_MEM_LVLNUM_L3: u32 = 3;
pub const LKL_PERF_MEM_LVLNUM_L4: u32 = 4;
pub const LKL_PERF_MEM_LVLNUM_ANY_CACHE: u32 = 11;
pub const LKL_PERF_MEM_LVLNUM_LFB: u32 = 12;
pub const LKL_PERF_MEM_LVLNUM_RAM: u32 = 13;
pub const LKL_PERF_MEM_LVLNUM_PMEM: u32 = 14;
pub const LKL_PERF_MEM_LVLNUM_NA: u32 = 15;
pub const LKL_PERF_MEM_LVLNUM_SHIFT: u32 = 33;
pub const LKL_PERF_MEM_SNOOP_NA: u32 = 1;
pub const LKL_PERF_MEM_SNOOP_NONE: u32 = 2;
pub const LKL_PERF_MEM_SNOOP_HIT: u32 = 4;
pub const LKL_PERF_MEM_SNOOP_MISS: u32 = 8;
pub const LKL_PERF_MEM_SNOOP_HITM: u32 = 16;
pub const LKL_PERF_MEM_SNOOP_SHIFT: u32 = 19;
pub const LKL_PERF_MEM_SNOOPX_FWD: u32 = 1;
pub const LKL_PERF_MEM_SNOOPX_SHIFT: u32 = 38;
pub const LKL_PERF_MEM_LOCK_NA: u32 = 1;
pub const LKL_PERF_MEM_LOCK_LOCKED: u32 = 2;
pub const LKL_PERF_MEM_LOCK_SHIFT: u32 = 24;
pub const LKL_PERF_MEM_TLB_NA: u32 = 1;
pub const LKL_PERF_MEM_TLB_HIT: u32 = 2;
pub const LKL_PERF_MEM_TLB_MISS: u32 = 4;
pub const LKL_PERF_MEM_TLB_L1: u32 = 8;
pub const LKL_PERF_MEM_TLB_L2: u32 = 16;
pub const LKL_PERF_MEM_TLB_WK: u32 = 32;
pub const LKL_PERF_MEM_TLB_OS: u32 = 64;
pub const LKL_PERF_MEM_TLB_SHIFT: u32 = 26;
pub const LKL_SEM_UNDO: u32 = 4096;
pub const LKL_GETPID: u32 = 11;
pub const LKL_GETVAL: u32 = 12;
pub const LKL_GETALL: u32 = 13;
pub const LKL_GETNCNT: u32 = 14;
pub const LKL_GETZCNT: u32 = 15;
pub const LKL_SETVAL: u32 = 16;
pub const LKL_SETALL: u32 = 17;
pub const LKL_SEM_STAT: u32 = 18;
pub const LKL_SEM_INFO: u32 = 19;
pub const LKL_SEM_STAT_ANY: u32 = 20;
pub const LKL_SEMMNI: u32 = 32000;
pub const LKL_SEMMSL: u32 = 32000;
pub const LKL_SEMMNS: u32 = 1024000000;
pub const LKL_SEMOPM: u32 = 500;
pub const LKL_SEMVMX: u32 = 32767;
pub const LKL_SEMAEM: u32 = 32767;
pub const LKL_SEMUME: u32 = 500;
pub const LKL_SEMMNU: u32 = 1024000000;
pub const LKL_SEMMAP: u32 = 1024000000;
pub const LKL_SEMUSZ: u32 = 20;
pub const LKL_FUTEX_WAIT: u32 = 0;
pub const LKL_FUTEX_WAKE: u32 = 1;
pub const LKL_FUTEX_FD: u32 = 2;
pub const LKL_FUTEX_REQUEUE: u32 = 3;
pub const LKL_FUTEX_CMP_REQUEUE: u32 = 4;
pub const LKL_FUTEX_WAKE_OP: u32 = 5;
pub const LKL_FUTEX_LOCK_PI: u32 = 6;
pub const LKL_FUTEX_UNLOCK_PI: u32 = 7;
pub const LKL_FUTEX_TRYLOCK_PI: u32 = 8;
pub const LKL_FUTEX_WAIT_BITSET: u32 = 9;
pub const LKL_FUTEX_WAKE_BITSET: u32 = 10;
pub const LKL_FUTEX_WAIT_REQUEUE_PI: u32 = 11;
pub const LKL_FUTEX_CMP_REQUEUE_PI: u32 = 12;
pub const LKL_FUTEX_PRIVATE_FLAG: u32 = 128;
pub const LKL_FUTEX_CLOCK_REALTIME: u32 = 256;
pub const LKL_FUTEX_CMD_MASK: i32 = -385;
pub const LKL_FUTEX_WAIT_PRIVATE: u32 = 128;
pub const LKL_FUTEX_WAKE_PRIVATE: u32 = 129;
pub const LKL_FUTEX_REQUEUE_PRIVATE: u32 = 131;
pub const LKL_FUTEX_CMP_REQUEUE_PRIVATE: u32 = 132;
pub const LKL_FUTEX_WAKE_OP_PRIVATE: u32 = 133;
pub const LKL_FUTEX_LOCK_PI_PRIVATE: u32 = 134;
pub const LKL_FUTEX_UNLOCK_PI_PRIVATE: u32 = 135;
pub const LKL_FUTEX_TRYLOCK_PI_PRIVATE: u32 = 136;
pub const LKL_FUTEX_WAIT_BITSET_PRIVATE: u32 = 137;
pub const LKL_FUTEX_WAKE_BITSET_PRIVATE: u32 = 138;
pub const LKL_FUTEX_WAIT_REQUEUE_PI_PRIVATE: u32 = 139;
pub const LKL_FUTEX_CMP_REQUEUE_PI_PRIVATE: u32 = 140;
pub const LKL_FUTEX_WAITERS: u32 = 2147483648;
pub const LKL_FUTEX_OWNER_DIED: u32 = 1073741824;
pub const LKL_FUTEX_TID_MASK: u32 = 1073741823;
pub const LKL_ROBUST_LIST_LIMIT: u32 = 2048;
pub const LKL_FUTEX_BITSET_MATCH_ANY: u32 = 4294967295;
pub const LKL_FUTEX_OP_SET: u32 = 0;
pub const LKL_FUTEX_OP_ADD: u32 = 1;
pub const LKL_FUTEX_OP_OR: u32 = 2;
pub const LKL_FUTEX_OP_ANDN: u32 = 3;
pub const LKL_FUTEX_OP_XOR: u32 = 4;
pub const LKL_FUTEX_OP_OPARG_SHIFT: u32 = 8;
pub const LKL_FUTEX_OP_CMP_EQ: u32 = 0;
pub const LKL_FUTEX_OP_CMP_NE: u32 = 1;
pub const LKL_FUTEX_OP_CMP_LT: u32 = 2;
pub const LKL_FUTEX_OP_CMP_LE: u32 = 3;
pub const LKL_FUTEX_OP_CMP_GT: u32 = 4;
pub const LKL_FUTEX_OP_CMP_GE: u32 = 5;
pub const LKL_POLLIN: u32 = 1;
pub const LKL_POLLPRI: u32 = 2;
pub const LKL_POLLOUT: u32 = 4;
pub const LKL_POLLERR: u32 = 8;
pub const LKL_POLLHUP: u32 = 16;
pub const LKL_POLLNVAL: u32 = 32;
pub const LKL_POLLRDNORM: u32 = 64;
pub const LKL_POLLRDBAND: u32 = 128;
pub const LKL_POLLWRNORM: u32 = 256;
pub const LKL_POLLWRBAND: u32 = 512;
pub const LKL_POLLMSG: u32 = 1024;
pub const LKL_POLLREMOVE: u32 = 4096;
pub const LKL_POLLRDHUP: u32 = 8192;
pub const LKL_MQ_PRIO_MAX: u32 = 32768;
pub const LKL_MQ_BYTES_MAX: u32 = 819200;
pub const LKL_NOTIFY_NONE: u32 = 0;
pub const LKL_NOTIFY_WOKENUP: u32 = 1;
pub const LKL_NOTIFY_REMOVED: u32 = 2;
pub const LKL_NOTIFY_COOKIE_LEN: u32 = 32;
pub const LKL_EPOLL_CLOEXEC: u32 = 524288;
pub const LKL_EPOLL_CTL_ADD: u32 = 1;
pub const LKL_EPOLL_CTL_DEL: u32 = 2;
pub const LKL_EPOLL_CTL_MOD: u32 = 3;
pub const LKL_UIO_FASTIOV: u32 = 8;
pub const LKL_UIO_MAXIOV: u32 = 1024;
pub const _LKL_NSIG: u32 = 64;
pub const _LKL_NSIG_BPW: u32 = 64;
pub const _LKL_NSIG_WORDS: u32 = 1;
pub const LKL_SIGHUP: u32 = 1;
pub const LKL_SIGINT: u32 = 2;
pub const LKL_SIGQUIT: u32 = 3;
pub const LKL_SIGILL: u32 = 4;
pub const LKL_SIGTRAP: u32 = 5;
pub const LKL_SIGABRT: u32 = 6;
pub const LKL_SIGIOT: u32 = 6;
pub const LKL_SIGBUS: u32 = 7;
pub const LKL_SIGFPE: u32 = 8;
pub const LKL_SIGKILL: u32 = 9;
pub const LKL_SIGUSR1: u32 = 10;
pub const LKL_SIGSEGV: u32 = 11;
pub const LKL_SIGUSR2: u32 = 12;
pub const LKL_SIGPIPE: u32 = 13;
pub const LKL_SIGALRM: u32 = 14;
pub const LKL_SIGTERM: u32 = 15;
pub const LKL_SIGSTKFLT: u32 = 16;
pub const LKL_SIGCHLD: u32 = 17;
pub const LKL_SIGCONT: u32 = 18;
pub const LKL_SIGSTOP: u32 = 19;
pub const LKL_SIGTSTP: u32 = 20;
pub const LKL_SIGTTIN: u32 = 21;
pub const LKL_SIGTTOU: u32 = 22;
pub const LKL_SIGURG: u32 = 23;
pub const LKL_SIGXCPU: u32 = 24;
pub const LKL_SIGXFSZ: u32 = 25;
pub const LKL_SIGVTALRM: u32 = 26;
pub const LKL_SIGPROF: u32 = 27;
pub const LKL_SIGWINCH: u32 = 28;
pub const LKL_SIGIO: u32 = 29;
pub const LKL_SIGPOLL: u32 = 29;
pub const LKL_SIGPWR: u32 = 30;
pub const LKL_SIGSYS: u32 = 31;
pub const LKL_SIGUNUSED: u32 = 31;
pub const LKL_SIGRTMIN: u32 = 32;
pub const LKL_SIGRTMAX: u32 = 64;
pub const LKL_SA_NOCLDSTOP: u32 = 1;
pub const LKL_SA_NOCLDWAIT: u32 = 2;
pub const LKL_SA_SIGINFO: u32 = 4;
pub const LKL_SA_ONSTACK: u32 = 134217728;
pub const LKL_SA_RESTART: u32 = 268435456;
pub const LKL_SA_NODEFER: u32 = 1073741824;
pub const LKL_SA_RESETHAND: u32 = 2147483648;
pub const LKL_SA_NOMASK: u32 = 1073741824;
pub const LKL_SA_ONESHOT: u32 = 2147483648;
pub const LKL_MINSIGSTKSZ: u32 = 2048;
pub const LKL_SIGSTKSZ: u32 = 8192;
pub const LKL_SIG_BLOCK: u32 = 0;
pub const LKL_SIG_UNBLOCK: u32 = 1;
pub const LKL_SIG_SETMASK: u32 = 2;
pub const LKL_SI_MAX_SIZE: u32 = 128;
pub const LKL_SI_USER: u32 = 0;
pub const LKL_SI_KERNEL: u32 = 128;
pub const LKL_SI_QUEUE: i32 = -1;
pub const LKL_SI_TIMER: i32 = -2;
pub const LKL_SI_MESGQ: i32 = -3;
pub const LKL_SI_ASYNCIO: i32 = -4;
pub const LKL_SI_SIGIO: i32 = -5;
pub const LKL_SI_TKILL: i32 = -6;
pub const LKL_SI_DETHREAD: i32 = -7;
pub const LKL_SI_ASYNCNL: i32 = -60;
pub const LKL_ILL_ILLOPC: u32 = 1;
pub const LKL_ILL_ILLOPN: u32 = 2;
pub const LKL_ILL_ILLADR: u32 = 3;
pub const LKL_ILL_ILLTRP: u32 = 4;
pub const LKL_ILL_PRVOPC: u32 = 5;
pub const LKL_ILL_PRVREG: u32 = 6;
pub const LKL_ILL_COPROC: u32 = 7;
pub const LKL_ILL_BADSTK: u32 = 8;
pub const LKL_ILL_BADIADDR: u32 = 9;
pub const __LKL__ILL_BREAK: u32 = 10;
pub const __LKL__ILL_BNDMOD: u32 = 11;
pub const LKL_NSIGILL: u32 = 11;
pub const LKL_FPE_INTDIV: u32 = 1;
pub const LKL_FPE_INTOVF: u32 = 2;
pub const LKL_FPE_FLTDIV: u32 = 3;
pub const LKL_FPE_FLTOVF: u32 = 4;
pub const LKL_FPE_FLTUND: u32 = 5;
pub const LKL_FPE_FLTRES: u32 = 6;
pub const LKL_FPE_FLTINV: u32 = 7;
pub const LKL_FPE_FLTSUB: u32 = 8;
pub const __LKL__FPE_DECOVF: u32 = 9;
pub const __LKL__FPE_DECDIV: u32 = 10;
pub const __LKL__FPE_DECERR: u32 = 11;
pub const __LKL__FPE_INVASC: u32 = 12;
pub const __LKL__FPE_INVDEC: u32 = 13;
pub const LKL_FPE_FLTUNK: u32 = 14;
pub const LKL_FPE_CONDTRAP: u32 = 15;
pub const LKL_NSIGFPE: u32 = 15;
pub const LKL_SEGV_MAPERR: u32 = 1;
pub const LKL_SEGV_ACCERR: u32 = 2;
pub const LKL_SEGV_BNDERR: u32 = 3;
pub const LKL_SEGV_PKUERR: u32 = 4;
pub const LKL_SEGV_ACCADI: u32 = 5;
pub const LKL_SEGV_ADIDERR: u32 = 6;
pub const LKL_SEGV_ADIPERR: u32 = 7;
pub const LKL_SEGV_MTEAERR: u32 = 8;
pub const LKL_SEGV_MTESERR: u32 = 9;
pub const LKL_NSIGSEGV: u32 = 9;
pub const LKL_BUS_ADRALN: u32 = 1;
pub const LKL_BUS_ADRERR: u32 = 2;
pub const LKL_BUS_OBJERR: u32 = 3;
pub const LKL_BUS_MCEERR_AR: u32 = 4;
pub const LKL_BUS_MCEERR_AO: u32 = 5;
pub const LKL_NSIGBUS: u32 = 5;
pub const LKL_TRAP_BRKPT: u32 = 1;
pub const LKL_TRAP_TRACE: u32 = 2;
pub const LKL_TRAP_BRANCH: u32 = 3;
pub const LKL_TRAP_HWBKPT: u32 = 4;
pub const LKL_TRAP_UNK: u32 = 5;
pub const LKL_NSIGTRAP: u32 = 5;
pub const LKL_CLD_EXITED: u32 = 1;
pub const LKL_CLD_KILLED: u32 = 2;
pub const LKL_CLD_DUMPED: u32 = 3;
pub const LKL_CLD_TRAPPED: u32 = 4;
pub const LKL_CLD_STOPPED: u32 = 5;
pub const LKL_CLD_CONTINUED: u32 = 6;
pub const LKL_NSIGCHLD: u32 = 6;
pub const LKL_POLL_IN: u32 = 1;
pub const LKL_POLL_OUT: u32 = 2;
pub const LKL_POLL_MSG: u32 = 3;
pub const LKL_POLL_ERR: u32 = 4;
pub const LKL_POLL_PRI: u32 = 5;
pub const LKL_POLL_HUP: u32 = 6;
pub const LKL_NSIGPOLL: u32 = 6;
pub const LKL_SYS_SECCOMP: u32 = 1;
pub const LKL_NSIGSYS: u32 = 1;
pub const LKL_EMT_TAGOVF: u32 = 1;
pub const LKL_NSIGEMT: u32 = 1;
pub const LKL_SIGEV_SIGNAL: u32 = 0;
pub const LKL_SIGEV_NONE: u32 = 1;
pub const LKL_SIGEV_THREAD: u32 = 2;
pub const LKL_SIGEV_THREAD_ID: u32 = 4;
pub const LKL_SIGEV_MAX_SIZE: u32 = 64;
pub const LKL_FIOSETOWN: u32 = 35073;
pub const LKL_SIOCSPGRP: u32 = 35074;
pub const LKL_FIOGETOWN: u32 = 35075;
pub const LKL_SIOCGPGRP: u32 = 35076;
pub const LKL_SIOCATMARK: u32 = 35077;
pub const LKL_SIOCGSTAMP_OLD: u32 = 35078;
pub const LKL_SIOCGSTAMPNS_OLD: u32 = 35079;
pub const LKL_SOL_SOCKET: u32 = 1;
pub const LKL_SO_DEBUG: u32 = 1;
pub const LKL_SO_REUSEADDR: u32 = 2;
pub const LKL_SO_TYPE: u32 = 3;
pub const LKL_SO_ERROR: u32 = 4;
pub const LKL_SO_DONTROUTE: u32 = 5;
pub const LKL_SO_BROADCAST: u32 = 6;
pub const LKL_SO_SNDBUF: u32 = 7;
pub const LKL_SO_RCVBUF: u32 = 8;
pub const LKL_SO_SNDBUFFORCE: u32 = 32;
pub const LKL_SO_RCVBUFFORCE: u32 = 33;
pub const LKL_SO_KEEPALIVE: u32 = 9;
pub const LKL_SO_OOBINLINE: u32 = 10;
pub const LKL_SO_NO_CHECK: u32 = 11;
pub const LKL_SO_PRIORITY: u32 = 12;
pub const LKL_SO_LINGER: u32 = 13;
pub const LKL_SO_BSDCOMPAT: u32 = 14;
pub const LKL_SO_REUSEPORT: u32 = 15;
pub const LKL_SO_PASSCRED: u32 = 16;
pub const LKL_SO_PEERCRED: u32 = 17;
pub const LKL_SO_RCVLOWAT: u32 = 18;
pub const LKL_SO_SNDLOWAT: u32 = 19;
pub const LKL_SO_RCVTIMEO_OLD: u32 = 20;
pub const LKL_SO_SNDTIMEO_OLD: u32 = 21;
pub const LKL_SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const LKL_SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const LKL_SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const LKL_SO_BINDTODEVICE: u32 = 25;
pub const LKL_SO_ATTACH_FILTER: u32 = 26;
pub const LKL_SO_DETACH_FILTER: u32 = 27;
pub const LKL_SO_GET_FILTER: u32 = 26;
pub const LKL_SO_PEERNAME: u32 = 28;
pub const LKL_SO_ACCEPTCONN: u32 = 30;
pub const LKL_SO_PEERSEC: u32 = 31;
pub const LKL_SO_PASSSEC: u32 = 34;
pub const LKL_SO_MARK: u32 = 36;
pub const LKL_SO_PROTOCOL: u32 = 38;
pub const LKL_SO_DOMAIN: u32 = 39;
pub const LKL_SO_RXQ_OVFL: u32 = 40;
pub const LKL_SO_WIFI_STATUS: u32 = 41;
pub const LKL_SCM_WIFI_STATUS: u32 = 41;
pub const LKL_SO_PEEK_OFF: u32 = 42;
pub const LKL_SO_NOFCS: u32 = 43;
pub const LKL_SO_LOCK_FILTER: u32 = 44;
pub const LKL_SO_SELECT_ERR_QUEUE: u32 = 45;
pub const LKL_SO_BUSY_POLL: u32 = 46;
pub const LKL_SO_MAX_PACING_RATE: u32 = 47;
pub const LKL_SO_BPF_EXTENSIONS: u32 = 48;
pub const LKL_SO_INCOMING_CPU: u32 = 49;
pub const LKL_SO_ATTACH_BPF: u32 = 50;
pub const LKL_SO_DETACH_BPF: u32 = 27;
pub const LKL_SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const LKL_SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const LKL_SO_CNX_ADVICE: u32 = 53;
pub const LKL_SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const LKL_SO_MEMINFO: u32 = 55;
pub const LKL_SO_INCOMING_NAPI_ID: u32 = 56;
pub const LKL_SO_COOKIE: u32 = 57;
pub const LKL_SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const LKL_SO_PEERGROUPS: u32 = 59;
pub const LKL_SO_ZEROCOPY: u32 = 60;
pub const LKL_SO_TXTIME: u32 = 61;
pub const LKL_SCM_TXTIME: u32 = 61;
pub const LKL_SO_BINDTOIFINDEX: u32 = 62;
pub const LKL_SO_TIMESTAMP_OLD: u32 = 29;
pub const LKL_SO_TIMESTAMPNS_OLD: u32 = 35;
pub const LKL_SO_TIMESTAMPING_OLD: u32 = 37;
pub const LKL_SO_TIMESTAMP_NEW: u32 = 63;
pub const LKL_SO_TIMESTAMPNS_NEW: u32 = 64;
pub const LKL_SO_TIMESTAMPING_NEW: u32 = 65;
pub const LKL_SO_RCVTIMEO_NEW: u32 = 66;
pub const LKL_SO_SNDTIMEO_NEW: u32 = 67;
pub const LKL_SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const LKL_SO_TIMESTAMP: u32 = 29;
pub const LKL_SO_TIMESTAMPNS: u32 = 35;
pub const LKL_SO_TIMESTAMPING: u32 = 37;
pub const LKL_SO_RCVTIMEO: u32 = 20;
pub const LKL_SO_SNDTIMEO: u32 = 21;
pub const LKL_SCM_TIMESTAMP: u32 = 29;
pub const LKL_SCM_TIMESTAMPNS: u32 = 35;
pub const LKL_SCM_TIMESTAMPING: u32 = 37;
pub const LKL_ICMP_ECHOREPLY: u32 = 0;
pub const LKL_ICMP_DEST_UNREACH: u32 = 3;
pub const LKL_ICMP_SOURCE_QUENCH: u32 = 4;
pub const LKL_ICMP_REDIRECT: u32 = 5;
pub const LKL_ICMP_ECHO: u32 = 8;
pub const LKL_ICMP_TIME_EXCEEDED: u32 = 11;
pub const LKL_ICMP_PARAMETERPROB: u32 = 12;
pub const LKL_ICMP_TIMESTAMP: u32 = 13;
pub const LKL_ICMP_TIMESTAMPREPLY: u32 = 14;
pub const LKL_ICMP_INFO_REQUEST: u32 = 15;
pub const LKL_ICMP_INFO_REPLY: u32 = 16;
pub const LKL_ICMP_ADDRESS: u32 = 17;
pub const LKL_ICMP_ADDRESSREPLY: u32 = 18;
pub const LKL_NR_ICMP_TYPES: u32 = 18;
pub const LKL_ICMP_NET_UNREACH: u32 = 0;
pub const LKL_ICMP_HOST_UNREACH: u32 = 1;
pub const LKL_ICMP_PROT_UNREACH: u32 = 2;
pub const LKL_ICMP_PORT_UNREACH: u32 = 3;
pub const LKL_ICMP_FRAG_NEEDED: u32 = 4;
pub const LKL_ICMP_SR_FAILED: u32 = 5;
pub const LKL_ICMP_NET_UNKNOWN: u32 = 6;
pub const LKL_ICMP_HOST_UNKNOWN: u32 = 7;
pub const LKL_ICMP_HOST_ISOLATED: u32 = 8;
pub const LKL_ICMP_NET_ANO: u32 = 9;
pub const LKL_ICMP_HOST_ANO: u32 = 10;
pub const LKL_ICMP_NET_UNR_TOS: u32 = 11;
pub const LKL_ICMP_HOST_UNR_TOS: u32 = 12;
pub const LKL_ICMP_PKT_FILTERED: u32 = 13;
pub const LKL_ICMP_PREC_VIOLATION: u32 = 14;
pub const LKL_ICMP_PREC_CUTOFF: u32 = 15;
pub const LKL_NR_ICMP_UNREACH: u32 = 15;
pub const LKL_ICMP_REDIR_NET: u32 = 0;
pub const LKL_ICMP_REDIR_HOST: u32 = 1;
pub const LKL_ICMP_REDIR_NETTOS: u32 = 2;
pub const LKL_ICMP_REDIR_HOSTTOS: u32 = 3;
pub const LKL_ICMP_EXC_TTL: u32 = 0;
pub const LKL_ICMP_EXC_FRAGTIME: u32 = 1;
pub const LKL_ICMP_FILTER: u32 = 1;
pub const LKL_IPTOS_TOS_MASK: u32 = 30;
pub const LKL_IPTOS_LOWDELAY: u32 = 16;
pub const LKL_IPTOS_THROUGHPUT: u32 = 8;
pub const LKL_IPTOS_RELIABILITY: u32 = 4;
pub const LKL_IPTOS_MINCOST: u32 = 2;
pub const LKL_IPTOS_PREC_MASK: u32 = 224;
pub const LKL_IPTOS_PREC_NETCONTROL: u32 = 224;
pub const LKL_IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const LKL_IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const LKL_IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const LKL_IPTOS_PREC_FLASH: u32 = 96;
pub const LKL_IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const LKL_IPTOS_PREC_PRIORITY: u32 = 32;
pub const LKL_IPTOS_PREC_ROUTINE: u32 = 0;
pub const LKL_IPOPT_COPY: u32 = 128;
pub const LKL_IPOPT_CLASS_MASK: u32 = 96;
pub const LKL_IPOPT_NUMBER_MASK: u32 = 31;
pub const LKL_IPOPT_CONTROL: u32 = 0;
pub const LKL_IPOPT_RESERVED1: u32 = 32;
pub const LKL_IPOPT_MEASUREMENT: u32 = 64;
pub const LKL_IPOPT_RESERVED2: u32 = 96;
pub const LKL_IPOPT_END: u32 = 0;
pub const LKL_IPOPT_NOOP: u32 = 1;
pub const LKL_IPOPT_SEC: u32 = 130;
pub const LKL_IPOPT_LSRR: u32 = 131;
pub const LKL_IPOPT_TIMESTAMP: u32 = 68;
pub const LKL_IPOPT_CIPSO: u32 = 134;
pub const LKL_IPOPT_RR: u32 = 7;
pub const LKL_IPOPT_SID: u32 = 136;
pub const LKL_IPOPT_SSRR: u32 = 137;
pub const LKL_IPOPT_RA: u32 = 148;
pub const LKL_IPVERSION: u32 = 4;
pub const LKL_MAXTTL: u32 = 255;
pub const LKL_IPDEFTTL: u32 = 64;
pub const LKL_IPOPT_OPTVAL: u32 = 0;
pub const LKL_IPOPT_OLEN: u32 = 1;
pub const LKL_IPOPT_OFFSET: u32 = 2;
pub const LKL_IPOPT_MINOFF: u32 = 4;
pub const LKL_MAX_IPOPTLEN: u32 = 40;
pub const LKL_IPOPT_NOP: u32 = 1;
pub const LKL_IPOPT_EOL: u32 = 0;
pub const LKL_IPOPT_TS: u32 = 68;
pub const LKL_IPOPT_TS_TSONLY: u32 = 0;
pub const LKL_IPOPT_TS_TSANDADDR: u32 = 1;
pub const LKL_IPOPT_TS_PRESPEC: u32 = 3;
pub const LKL_IPV4_BEET_PHMAXLEN: u32 = 8;
pub const __LKL__UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO: u32 = 1;
pub const __LKL__UAPI_DEF_IF_IFNAMSIZ: u32 = 1;
pub const __LKL__UAPI_DEF_IF_NET_DEVICE_FLAGS: u32 = 1;
pub const __LKL__UAPI_DEF_IF_IFREQ: u32 = 1;
pub const __LKL__UAPI_DEF_IF_IFMAP: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MAX: u32 = 45;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MAX: u32 = 45;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const LKL_IFNAMSIZ: u32 = 16;
pub const LKL_IFALIASZ: u32 = 256;
pub const LKL_ALTIFNAMSIZ: u32 = 128;
pub const LKL_GENERIC_HDLC_VERSION: u32 = 4;
pub const LKL_CLOCK_DEFAULT: u32 = 0;
pub const LKL_CLOCK_EXT: u32 = 1;
pub const LKL_CLOCK_INT: u32 = 2;
pub const LKL_CLOCK_TXINT: u32 = 3;
pub const LKL_CLOCK_TXFROMRX: u32 = 4;
pub const LKL_ENCODING_DEFAULT: u32 = 0;
pub const LKL_ENCODING_NRZ: u32 = 1;
pub const LKL_ENCODING_NRZI: u32 = 2;
pub const LKL_ENCODING_FM_MARK: u32 = 3;
pub const LKL_ENCODING_FM_SPACE: u32 = 4;
pub const LKL_ENCODING_MANCHESTER: u32 = 5;
pub const LKL_PARITY_DEFAULT: u32 = 0;
pub const LKL_PARITY_NONE: u32 = 1;
pub const LKL_PARITY_CRC16_PR0: u32 = 2;
pub const LKL_PARITY_CRC16_PR1: u32 = 3;
pub const LKL_PARITY_CRC16_PR0_CCITT: u32 = 4;
pub const LKL_PARITY_CRC16_PR1_CCITT: u32 = 5;
pub const LKL_PARITY_CRC32_PR0_CCITT: u32 = 6;
pub const LKL_PARITY_CRC32_PR1_CCITT: u32 = 7;
pub const LKL_LMI_DEFAULT: u32 = 0;
pub const LKL_LMI_NONE: u32 = 1;
pub const LKL_LMI_ANSI: u32 = 2;
pub const LKL_LMI_CCITT: u32 = 3;
pub const LKL_LMI_CISCO: u32 = 4;
pub const LKL_IF_GET_IFACE: u32 = 1;
pub const LKL_IF_GET_PROTO: u32 = 2;
pub const LKL_IF_IFACE_V35: u32 = 4096;
pub const LKL_IF_IFACE_V24: u32 = 4097;
pub const LKL_IF_IFACE_X21: u32 = 4098;
pub const LKL_IF_IFACE_T1: u32 = 4099;
pub const LKL_IF_IFACE_E1: u32 = 4100;
pub const LKL_IF_IFACE_SYNC_SERIAL: u32 = 4101;
pub const LKL_IF_IFACE_X21D: u32 = 4102;
pub const LKL_IF_PROTO_HDLC: u32 = 8192;
pub const LKL_IF_PROTO_PPP: u32 = 8193;
pub const LKL_IF_PROTO_CISCO: u32 = 8194;
pub const LKL_IF_PROTO_FR: u32 = 8195;
pub const LKL_IF_PROTO_FR_ADD_PVC: u32 = 8196;
pub const LKL_IF_PROTO_FR_DEL_PVC: u32 = 8197;
pub const LKL_IF_PROTO_X25: u32 = 8198;
pub const LKL_IF_PROTO_HDLC_ETH: u32 = 8199;
pub const LKL_IF_PROTO_FR_ADD_ETH_PVC: u32 = 8200;
pub const LKL_IF_PROTO_FR_DEL_ETH_PVC: u32 = 8201;
pub const LKL_IF_PROTO_FR_PVC: u32 = 8202;
pub const LKL_IF_PROTO_FR_ETH_PVC: u32 = 8203;
pub const LKL_IF_PROTO_RAW: u32 = 8204;
pub const LKL_IFHWADDRLEN: u32 = 6;
pub const __LKL__UAPI_DEF_IN_IPPROTO: u32 = 1;
pub const __LKL__UAPI_DEF_IN_ADDR: u32 = 1;
pub const __LKL__UAPI_DEF_IN6_ADDR: u32 = 1;
pub const __LKL__UAPI_DEF_IP_MREQ: u32 = 1;
pub const __LKL__UAPI_DEF_IN_PKTINFO: u32 = 1;
pub const __LKL__UAPI_DEF_SOCKADDR_IN: u32 = 1;
pub const __LKL__UAPI_DEF_IN_CLASS: u32 = 1;
pub const LKL_IP_TOS: u32 = 1;
pub const LKL_IP_TTL: u32 = 2;
pub const LKL_IP_HDRINCL: u32 = 3;
pub const LKL_IP_OPTIONS: u32 = 4;
pub const LKL_IP_ROUTER_ALERT: u32 = 5;
pub const LKL_IP_RECVOPTS: u32 = 6;
pub const LKL_IP_RETOPTS: u32 = 7;
pub const LKL_IP_PKTINFO: u32 = 8;
pub const LKL_IP_PKTOPTIONS: u32 = 9;
pub const LKL_IP_MTU_DISCOVER: u32 = 10;
pub const LKL_IP_RECVERR: u32 = 11;
pub const LKL_IP_RECVTTL: u32 = 12;
pub const LKL_IP_RECVTOS: u32 = 13;
pub const LKL_IP_MTU: u32 = 14;
pub const LKL_IP_FREEBIND: u32 = 15;
pub const LKL_IP_IPSEC_POLICY: u32 = 16;
pub const LKL_IP_XFRM_POLICY: u32 = 17;
pub const LKL_IP_PASSSEC: u32 = 18;
pub const LKL_IP_TRANSPARENT: u32 = 19;
pub const LKL_IP_RECVRETOPTS: u32 = 7;
pub const LKL_IP_ORIGDSTADDR: u32 = 20;
pub const LKL_IP_RECVORIGDSTADDR: u32 = 20;
pub const LKL_IP_MINTTL: u32 = 21;
pub const LKL_IP_NODEFRAG: u32 = 22;
pub const LKL_IP_CHECKSUM: u32 = 23;
pub const LKL_IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const LKL_IP_RECVFRAGSIZE: u32 = 25;
pub const LKL_IP_RECVERR_RFC4884: u32 = 26;
pub const LKL_IP_PMTUDISC_DONT: u32 = 0;
pub const LKL_IP_PMTUDISC_WANT: u32 = 1;
pub const LKL_IP_PMTUDISC_DO: u32 = 2;
pub const LKL_IP_PMTUDISC_PROBE: u32 = 3;
pub const LKL_IP_PMTUDISC_INTERFACE: u32 = 4;
pub const LKL_IP_PMTUDISC_OMIT: u32 = 5;
pub const LKL_IP_MULTICAST_IF: u32 = 32;
pub const LKL_IP_MULTICAST_TTL: u32 = 33;
pub const LKL_IP_MULTICAST_LOOP: u32 = 34;
pub const LKL_IP_ADD_MEMBERSHIP: u32 = 35;
pub const LKL_IP_DROP_MEMBERSHIP: u32 = 36;
pub const LKL_IP_UNBLOCK_SOURCE: u32 = 37;
pub const LKL_IP_BLOCK_SOURCE: u32 = 38;
pub const LKL_IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const LKL_IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const LKL_IP_MSFILTER: u32 = 41;
pub const LKL_MCAST_JOIN_GROUP: u32 = 42;
pub const LKL_MCAST_BLOCK_SOURCE: u32 = 43;
pub const LKL_MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const LKL_MCAST_LEAVE_GROUP: u32 = 45;
pub const LKL_MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const LKL_MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const LKL_MCAST_MSFILTER: u32 = 48;
pub const LKL_IP_MULTICAST_ALL: u32 = 49;
pub const LKL_IP_UNICAST_IF: u32 = 50;
pub const LKL_MCAST_EXCLUDE: u32 = 0;
pub const LKL_MCAST_INCLUDE: u32 = 1;
pub const LKL_IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const LKL_IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const __LKL__SOCK_SIZE__: u32 = 16;
pub const LKL_IN_CLASSA_NET: u32 = 4278190080;
pub const LKL_IN_CLASSA_NSHIFT: u32 = 24;
pub const LKL_IN_CLASSA_HOST: u32 = 16777215;
pub const LKL_IN_CLASSA_MAX: u32 = 128;
pub const LKL_IN_CLASSB_NET: u32 = 4294901760;
pub const LKL_IN_CLASSB_NSHIFT: u32 = 16;
pub const LKL_IN_CLASSB_HOST: u32 = 65535;
pub const LKL_IN_CLASSB_MAX: u32 = 65536;
pub const LKL_IN_CLASSC_NET: u32 = 4294967040;
pub const LKL_IN_CLASSC_NSHIFT: u32 = 8;
pub const LKL_IN_CLASSC_HOST: u32 = 255;
pub const LKL_IN_MULTICAST_NET: u32 = 3758096384;
pub const LKL_IN_CLASSE_NET: u32 = 4294967295;
pub const LKL_IN_CLASSE_NSHIFT: u32 = 0;
pub const LKL_IN_LOOPBACKNET: u32 = 127;
pub const LKL_INADDR_LOOPBACK: u32 = 2130706433;
pub const LKL_INADDR_UNSPEC_GROUP: u32 = 3758096384;
pub const LKL_INADDR_ALLHOSTS_GROUP: u32 = 3758096385;
pub const LKL_INADDR_ALLRTRS_GROUP: u32 = 3758096386;
pub const LKL_INADDR_ALLSNOOPERS_GROUP: u32 = 3758096490;
pub const LKL_INADDR_MAX_LOCAL_GROUP: u32 = 3758096639;
pub const LKL_IPV6_FL_A_GET: u32 = 0;
pub const LKL_IPV6_FL_A_PUT: u32 = 1;
pub const LKL_IPV6_FL_A_RENEW: u32 = 2;
pub const LKL_IPV6_FL_F_CREATE: u32 = 1;
pub const LKL_IPV6_FL_F_EXCL: u32 = 2;
pub const LKL_IPV6_FL_F_REFLECT: u32 = 4;
pub const LKL_IPV6_FL_F_REMOTE: u32 = 8;
pub const LKL_IPV6_FL_S_NONE: u32 = 0;
pub const LKL_IPV6_FL_S_EXCL: u32 = 1;
pub const LKL_IPV6_FL_S_PROCESS: u32 = 2;
pub const LKL_IPV6_FL_S_USER: u32 = 3;
pub const LKL_IPV6_FL_S_ANY: u32 = 255;
pub const LKL_IPV6_FLOWINFO_FLOWLABEL: u32 = 1048575;
pub const LKL_IPV6_FLOWINFO_PRIORITY: u32 = 267386880;
pub const LKL_IPV6_PRIORITY_UNCHARACTERIZED: u32 = 0;
pub const LKL_IPV6_PRIORITY_FILLER: u32 = 256;
pub const LKL_IPV6_PRIORITY_UNATTENDED: u32 = 512;
pub const LKL_IPV6_PRIORITY_RESERVED1: u32 = 768;
pub const LKL_IPV6_PRIORITY_BULK: u32 = 1024;
pub const LKL_IPV6_PRIORITY_RESERVED2: u32 = 1280;
pub const LKL_IPV6_PRIORITY_INTERACTIVE: u32 = 1536;
pub const LKL_IPV6_PRIORITY_CONTROL: u32 = 1792;
pub const LKL_IPV6_PRIORITY_8: u32 = 2048;
pub const LKL_IPV6_PRIORITY_9: u32 = 2304;
pub const LKL_IPV6_PRIORITY_10: u32 = 2560;
pub const LKL_IPV6_PRIORITY_11: u32 = 2816;
pub const LKL_IPV6_PRIORITY_12: u32 = 3072;
pub const LKL_IPV6_PRIORITY_13: u32 = 3328;
pub const LKL_IPV6_PRIORITY_14: u32 = 3584;
pub const LKL_IPV6_PRIORITY_15: u32 = 3840;
pub const LKL_IPV6_TLV_PAD1: u32 = 0;
pub const LKL_IPV6_TLV_PADN: u32 = 1;
pub const LKL_IPV6_TLV_ROUTERALERT: u32 = 5;
pub const LKL_IPV6_TLV_CALIPSO: u32 = 7;
pub const LKL_IPV6_TLV_JUMBO: u32 = 194;
pub const LKL_IPV6_TLV_HAO: u32 = 201;
pub const LKL_IPV6_RECVPKTINFO: u32 = 49;
pub const LKL_IPV6_PKTINFO: u32 = 50;
pub const LKL_IPV6_RECVHOPLIMIT: u32 = 51;
pub const LKL_IPV6_HOPLIMIT: u32 = 52;
pub const LKL_IPV6_RECVHOPOPTS: u32 = 53;
pub const LKL_IPV6_HOPOPTS: u32 = 54;
pub const LKL_IPV6_RTHDRDSTOPTS: u32 = 55;
pub const LKL_IPV6_RECVRTHDR: u32 = 56;
pub const LKL_IPV6_RTHDR: u32 = 57;
pub const LKL_IPV6_RECVDSTOPTS: u32 = 58;
pub const LKL_IPV6_DSTOPTS: u32 = 59;
pub const LKL_IPV6_RECVPATHMTU: u32 = 60;
pub const LKL_IPV6_PATHMTU: u32 = 61;
pub const LKL_IPV6_DONTFRAG: u32 = 62;
pub const LKL_IPV6_RECVTCLASS: u32 = 66;
pub const LKL_IPV6_TCLASS: u32 = 67;
pub const LKL_IPV6_AUTOFLOWLABEL: u32 = 70;
pub const LKL_IPV6_ADDR_PREFERENCES: u32 = 72;
pub const LKL_IPV6_PREFER_SRC_TMP: u32 = 1;
pub const LKL_IPV6_PREFER_SRC_PUBLIC: u32 = 2;
pub const LKL_IPV6_PREFER_SRC_PUBTMP_DEFAULT: u32 = 256;
pub const LKL_IPV6_PREFER_SRC_COA: u32 = 4;
pub const LKL_IPV6_PREFER_SRC_HOME: u32 = 1024;
pub const LKL_IPV6_PREFER_SRC_CGA: u32 = 8;
pub const LKL_IPV6_PREFER_SRC_NONCGA: u32 = 2048;
pub const LKL_IPV6_MINHOPCOUNT: u32 = 73;
pub const LKL_IPV6_ORIGDSTADDR: u32 = 74;
pub const LKL_IPV6_RECVORIGDSTADDR: u32 = 74;
pub const LKL_IPV6_TRANSPARENT: u32 = 75;
pub const LKL_IPV6_UNICAST_IF: u32 = 76;
pub const LKL_IPV6_RECVFRAGSIZE: u32 = 77;
pub const LKL_IPV6_FREEBIND: u32 = 78;
pub const LKL_SOCK_IOC_TYPE: u32 = 137;
pub const LKL_SIOCGSTAMP: u32 = 35078;
pub const LKL_SIOCGSTAMPNS: u32 = 35079;
pub const LKL_SIOCADDRT: u32 = 35083;
pub const LKL_SIOCDELRT: u32 = 35084;
pub const LKL_SIOCRTMSG: u32 = 35085;
pub const LKL_SIOCGIFNAME: u32 = 35088;
pub const LKL_SIOCSIFLINK: u32 = 35089;
pub const LKL_SIOCGIFCONF: u32 = 35090;
pub const LKL_SIOCGIFFLAGS: u32 = 35091;
pub const LKL_SIOCSIFFLAGS: u32 = 35092;
pub const LKL_SIOCGIFADDR: u32 = 35093;
pub const LKL_SIOCSIFADDR: u32 = 35094;
pub const LKL_SIOCGIFDSTADDR: u32 = 35095;
pub const LKL_SIOCSIFDSTADDR: u32 = 35096;
pub const LKL_SIOCGIFBRDADDR: u32 = 35097;
pub const LKL_SIOCSIFBRDADDR: u32 = 35098;
pub const LKL_SIOCGIFNETMASK: u32 = 35099;
pub const LKL_SIOCSIFNETMASK: u32 = 35100;
pub const LKL_SIOCGIFMETRIC: u32 = 35101;
pub const LKL_SIOCSIFMETRIC: u32 = 35102;
pub const LKL_SIOCGIFMEM: u32 = 35103;
pub const LKL_SIOCSIFMEM: u32 = 35104;
pub const LKL_SIOCGIFMTU: u32 = 35105;
pub const LKL_SIOCSIFMTU: u32 = 35106;
pub const LKL_SIOCSIFNAME: u32 = 35107;
pub const LKL_SIOCSIFHWADDR: u32 = 35108;
pub const LKL_SIOCGIFENCAP: u32 = 35109;
pub const LKL_SIOCSIFENCAP: u32 = 35110;
pub const LKL_SIOCGIFHWADDR: u32 = 35111;
pub const LKL_SIOCGIFSLAVE: u32 = 35113;
pub const LKL_SIOCSIFSLAVE: u32 = 35120;
pub const LKL_SIOCADDMULTI: u32 = 35121;
pub const LKL_SIOCDELMULTI: u32 = 35122;
pub const LKL_SIOCGIFINDEX: u32 = 35123;
pub const LKL_SIOGIFINDEX: u32 = 35123;
pub const LKL_SIOCSIFPFLAGS: u32 = 35124;
pub const LKL_SIOCGIFPFLAGS: u32 = 35125;
pub const LKL_SIOCDIFADDR: u32 = 35126;
pub const LKL_SIOCSIFHWBROADCAST: u32 = 35127;
pub const LKL_SIOCGIFCOUNT: u32 = 35128;
pub const LKL_SIOCGIFBR: u32 = 35136;
pub const LKL_SIOCSIFBR: u32 = 35137;
pub const LKL_SIOCGIFTXQLEN: u32 = 35138;
pub const LKL_SIOCSIFTXQLEN: u32 = 35139;
pub const LKL_SIOCETHTOOL: u32 = 35142;
pub const LKL_SIOCGMIIPHY: u32 = 35143;
pub const LKL_SIOCGMIIREG: u32 = 35144;
pub const LKL_SIOCSMIIREG: u32 = 35145;
pub const LKL_SIOCWANDEV: u32 = 35146;
pub const LKL_SIOCOUTQNSD: u32 = 35147;
pub const LKL_SIOCGSKNS: u32 = 35148;
pub const LKL_SIOCDARP: u32 = 35155;
pub const LKL_SIOCGARP: u32 = 35156;
pub const LKL_SIOCSARP: u32 = 35157;
pub const LKL_SIOCDRARP: u32 = 35168;
pub const LKL_SIOCGRARP: u32 = 35169;
pub const LKL_SIOCSRARP: u32 = 35170;
pub const LKL_SIOCGIFMAP: u32 = 35184;
pub const LKL_SIOCSIFMAP: u32 = 35185;
pub const LKL_SIOCADDDLCI: u32 = 35200;
pub const LKL_SIOCDELDLCI: u32 = 35201;
pub const LKL_SIOCGIFVLAN: u32 = 35202;
pub const LKL_SIOCSIFVLAN: u32 = 35203;
pub const LKL_SIOCBONDENSLAVE: u32 = 35216;
pub const LKL_SIOCBONDRELEASE: u32 = 35217;
pub const LKL_SIOCBONDSETHWADDR: u32 = 35218;
pub const LKL_SIOCBONDSLAVEINFOQUERY: u32 = 35219;
pub const LKL_SIOCBONDINFOQUERY: u32 = 35220;
pub const LKL_SIOCBONDCHANGEACTIVE: u32 = 35221;
pub const LKL_SIOCBRADDBR: u32 = 35232;
pub const LKL_SIOCBRDELBR: u32 = 35233;
pub const LKL_SIOCBRADDIF: u32 = 35234;
pub const LKL_SIOCBRDELIF: u32 = 35235;
pub const LKL_SIOCSHWTSTAMP: u32 = 35248;
pub const LKL_SIOCGHWTSTAMP: u32 = 35249;
pub const LKL_SIOCDEVPRIVATE: u32 = 35312;
pub const LKL_SIOCPROTOPRIVATE: u32 = 35296;
pub const LKL_RTF_UP: u32 = 1;
pub const LKL_RTF_GATEWAY: u32 = 2;
pub const LKL_RTF_HOST: u32 = 4;
pub const LKL_RTF_REINSTATE: u32 = 8;
pub const LKL_RTF_DYNAMIC: u32 = 16;
pub const LKL_RTF_MODIFIED: u32 = 32;
pub const LKL_RTF_MTU: u32 = 64;
pub const LKL_RTF_MSS: u32 = 64;
pub const LKL_RTF_WINDOW: u32 = 128;
pub const LKL_RTF_IRTT: u32 = 256;
pub const LKL_RTF_REJECT: u32 = 512;
pub const LKL_RTF_DEFAULT: u32 = 65536;
pub const LKL_RTF_ALLONLINK: u32 = 131072;
pub const LKL_RTF_ADDRCONF: u32 = 262144;
pub const LKL_RTF_PREFIX_RT: u32 = 524288;
pub const LKL_RTF_ANYCAST: u32 = 1048576;
pub const LKL_RTF_NONEXTHOP: u32 = 2097152;
pub const LKL_RTF_EXPIRES: u32 = 4194304;
pub const LKL_RTF_ROUTEINFO: u32 = 8388608;
pub const LKL_RTF_CACHE: u32 = 16777216;
pub const LKL_RTF_FLOW: u32 = 33554432;
pub const LKL_RTF_POLICY: u32 = 67108864;
pub const LKL_RTF_PREF_MASK: u32 = 402653184;
pub const LKL_RTF_PCPU: u32 = 1073741824;
pub const LKL_RTF_LOCAL: u32 = 2147483648;
pub const LKL_RTMSG_NEWDEVICE: u32 = 17;
pub const LKL_RTMSG_DELDEVICE: u32 = 18;
pub const LKL_RTMSG_NEWROUTE: u32 = 33;
pub const LKL_RTMSG_DELROUTE: u32 = 34;
pub const LKL_IP6_RT_PRIO_USER: u32 = 1024;
pub const LKL_IP6_RT_PRIO_ADDRCONF: u32 = 256;
pub const LKL_IPV6_MIN_MTU: u32 = 1280;
pub const LKL_IPV6_SRCRT_STRICT: u32 = 1;
pub const LKL_IPV6_SRCRT_TYPE_0: u32 = 0;
pub const LKL_IPV6_SRCRT_TYPE_2: u32 = 2;
pub const LKL_IPV6_SRCRT_TYPE_3: u32 = 3;
pub const LKL_IPV6_SRCRT_TYPE_4: u32 = 4;
pub const LKL_IPV6_OPT_ROUTERALERT_MLD: u32 = 0;
pub const LKL_NETLINK_ROUTE: u32 = 0;
pub const LKL_NETLINK_UNUSED: u32 = 1;
pub const LKL_NETLINK_USERSOCK: u32 = 2;
pub const LKL_NETLINK_FIREWALL: u32 = 3;
pub const LKL_NETLINK_SOCK_DIAG: u32 = 4;
pub const LKL_NETLINK_NFLOG: u32 = 5;
pub const LKL_NETLINK_XFRM: u32 = 6;
pub const LKL_NETLINK_SELINUX: u32 = 7;
pub const LKL_NETLINK_ISCSI: u32 = 8;
pub const LKL_NETLINK_AUDIT: u32 = 9;
pub const LKL_NETLINK_FIB_LOOKUP: u32 = 10;
pub const LKL_NETLINK_CONNECTOR: u32 = 11;
pub const LKL_NETLINK_NETFILTER: u32 = 12;
pub const LKL_NETLINK_IP6_FW: u32 = 13;
pub const LKL_NETLINK_DNRTMSG: u32 = 14;
pub const LKL_NETLINK_KOBJECT_UEVENT: u32 = 15;
pub const LKL_NETLINK_GENERIC: u32 = 16;
pub const LKL_NETLINK_SCSITRANSPORT: u32 = 18;
pub const LKL_NETLINK_ECRYPTFS: u32 = 19;
pub const LKL_NETLINK_RDMA: u32 = 20;
pub const LKL_NETLINK_CRYPTO: u32 = 21;
pub const LKL_NETLINK_SMC: u32 = 22;
pub const LKL_NETLINK_INET_DIAG: u32 = 4;
pub const LKL_MAX_LINKS: u32 = 32;
pub const LKL_NLM_F_REQUEST: u32 = 1;
pub const LKL_NLM_F_MULTI: u32 = 2;
pub const LKL_NLM_F_ACK: u32 = 4;
pub const LKL_NLM_F_ECHO: u32 = 8;
pub const LKL_NLM_F_DUMP_INTR: u32 = 16;
pub const LKL_NLM_F_DUMP_FILTERED: u32 = 32;
pub const LKL_NLM_F_ROOT: u32 = 256;
pub const LKL_NLM_F_MATCH: u32 = 512;
pub const LKL_NLM_F_ATOMIC: u32 = 1024;
pub const LKL_NLM_F_DUMP: u32 = 768;
pub const LKL_NLM_F_REPLACE: u32 = 256;
pub const LKL_NLM_F_EXCL: u32 = 512;
pub const LKL_NLM_F_CREATE: u32 = 1024;
pub const LKL_NLM_F_APPEND: u32 = 2048;
pub const LKL_NLM_F_NONREC: u32 = 256;
pub const LKL_NLM_F_CAPPED: u32 = 256;
pub const LKL_NLM_F_ACK_TLVS: u32 = 512;
pub const LKL_NLMSG_ALIGNTO: u32 = 4;
pub const LKL_NLMSG_NOOP: u32 = 1;
pub const LKL_NLMSG_ERROR: u32 = 2;
pub const LKL_NLMSG_DONE: u32 = 3;
pub const LKL_NLMSG_OVERRUN: u32 = 4;
pub const LKL_NLMSG_MIN_TYPE: u32 = 16;
pub const LKL_NETLINK_ADD_MEMBERSHIP: u32 = 1;
pub const LKL_NETLINK_DROP_MEMBERSHIP: u32 = 2;
pub const LKL_NETLINK_PKTINFO: u32 = 3;
pub const LKL_NETLINK_BROADCAST_ERROR: u32 = 4;
pub const LKL_NETLINK_NO_ENOBUFS: u32 = 5;
pub const LKL_NETLINK_RX_RING: u32 = 6;
pub const LKL_NETLINK_TX_RING: u32 = 7;
pub const LKL_NETLINK_LISTEN_ALL_NSID: u32 = 8;
pub const LKL_NETLINK_LIST_MEMBERSHIPS: u32 = 9;
pub const LKL_NETLINK_CAP_ACK: u32 = 10;
pub const LKL_NETLINK_EXT_ACK: u32 = 11;
pub const LKL_NETLINK_GET_STRICT_CHK: u32 = 12;
pub const LKL_NL_MMAP_MSG_ALIGNMENT: u32 = 4;
pub const LKL_NET_MAJOR: u32 = 36;
pub const LKL_NLA_F_NESTED: u32 = 32768;
pub const LKL_NLA_F_NET_BYTEORDER: u32 = 16384;
pub const LKL_NLA_TYPE_MASK: i32 = -49153;
pub const LKL_NLA_ALIGNTO: u32 = 4;
pub const LKL_NTF_USE: u32 = 1;
pub const LKL_NTF_SELF: u32 = 2;
pub const LKL_NTF_MASTER: u32 = 4;
pub const LKL_NTF_PROXY: u32 = 8;
pub const LKL_NTF_EXT_LEARNED: u32 = 16;
pub const LKL_NTF_OFFLOADED: u32 = 32;
pub const LKL_NTF_STICKY: u32 = 64;
pub const LKL_NTF_ROUTER: u32 = 128;
pub const LKL_NUD_INCOMPLETE: u32 = 1;
pub const LKL_NUD_REACHABLE: u32 = 2;
pub const LKL_NUD_STALE: u32 = 4;
pub const LKL_NUD_DELAY: u32 = 8;
pub const LKL_NUD_PROBE: u32 = 16;
pub const LKL_NUD_FAILED: u32 = 32;
pub const LKL_NUD_NOARP: u32 = 64;
pub const LKL_NUD_PERMANENT: u32 = 128;
pub const LKL_NUD_NONE: u32 = 0;
pub const LKL_MACVLAN_FLAG_NOPROMISC: u32 = 1;
pub const LKL_IPVLAN_F_PRIVATE: u32 = 1;
pub const LKL_IPVLAN_F_VEPA: u32 = 2;
pub const LKL_MAX_VLAN_LIST_LEN: u32 = 1;
pub const LKL_PORT_PROFILE_MAX: u32 = 40;
pub const LKL_PORT_UUID_MAX: u32 = 16;
pub const LKL_PORT_SELF_VF: i32 = -1;
pub const LKL_XDP_FLAGS_UPDATE_IF_NOEXIST: u32 = 1;
pub const LKL_XDP_FLAGS_SKB_MODE: u32 = 2;
pub const LKL_XDP_FLAGS_DRV_MODE: u32 = 4;
pub const LKL_XDP_FLAGS_HW_MODE: u32 = 8;
pub const LKL_XDP_FLAGS_REPLACE: u32 = 16;
pub const LKL_XDP_FLAGS_MODES: u32 = 14;
pub const LKL_XDP_FLAGS_MASK: u32 = 31;
pub const LKL_RMNET_FLAGS_INGRESS_DEAGGREGATION: u32 = 1;
pub const LKL_RMNET_FLAGS_INGRESS_MAP_COMMANDS: u32 = 2;
pub const LKL_RMNET_FLAGS_INGRESS_MAP_CKSUMV4: u32 = 4;
pub const LKL_RMNET_FLAGS_EGRESS_MAP_CKSUMV4: u32 = 8;
pub const LKL_IFA_F_SECONDARY: u32 = 1;
pub const LKL_IFA_F_TEMPORARY: u32 = 1;
pub const LKL_IFA_F_NODAD: u32 = 2;
pub const LKL_IFA_F_OPTIMISTIC: u32 = 4;
pub const LKL_IFA_F_DADFAILED: u32 = 8;
pub const LKL_IFA_F_HOMEADDRESS: u32 = 16;
pub const LKL_IFA_F_DEPRECATED: u32 = 32;
pub const LKL_IFA_F_TENTATIVE: u32 = 64;
pub const LKL_IFA_F_PERMANENT: u32 = 128;
pub const LKL_IFA_F_MANAGETEMPADDR: u32 = 256;
pub const LKL_IFA_F_NOPREFIXROUTE: u32 = 512;
pub const LKL_IFA_F_MCAUTOJOIN: u32 = 1024;
pub const LKL_IFA_F_STABLE_PRIVACY: u32 = 2048;
pub const LKL_RTNL_FAMILY_IPMR: u32 = 128;
pub const LKL_RTNL_FAMILY_IP6MR: u32 = 129;
pub const LKL_RTNL_FAMILY_MAX: u32 = 129;
pub const LKL_RTA_ALIGNTO: u32 = 4;
pub const LKL_RTPROT_UNSPEC: u32 = 0;
pub const LKL_RTPROT_REDIRECT: u32 = 1;
pub const LKL_RTPROT_KERNEL: u32 = 2;
pub const LKL_RTPROT_BOOT: u32 = 3;
pub const LKL_RTPROT_STATIC: u32 = 4;
pub const LKL_RTPROT_GATED: u32 = 8;
pub const LKL_RTPROT_RA: u32 = 9;
pub const LKL_RTPROT_MRT: u32 = 10;
pub const LKL_RTPROT_ZEBRA: u32 = 11;
pub const LKL_RTPROT_BIRD: u32 = 12;
pub const LKL_RTPROT_DNROUTED: u32 = 13;
pub const LKL_RTPROT_XORP: u32 = 14;
pub const LKL_RTPROT_NTK: u32 = 15;
pub const LKL_RTPROT_DHCP: u32 = 16;
pub const LKL_RTPROT_MROUTED: u32 = 17;
pub const LKL_RTPROT_KEEPALIVED: u32 = 18;
pub const LKL_RTPROT_BABEL: u32 = 42;
pub const LKL_RTPROT_BGP: u32 = 186;
pub const LKL_RTPROT_ISIS: u32 = 187;
pub const LKL_RTPROT_OSPF: u32 = 188;
pub const LKL_RTPROT_RIP: u32 = 189;
pub const LKL_RTPROT_EIGRP: u32 = 192;
pub const LKL_RTM_F_NOTIFY: u32 = 256;
pub const LKL_RTM_F_CLONED: u32 = 512;
pub const LKL_RTM_F_EQUALIZE: u32 = 1024;
pub const LKL_RTM_F_PREFIX: u32 = 2048;
pub const LKL_RTM_F_LOOKUP_TABLE: u32 = 4096;
pub const LKL_RTM_F_FIB_MATCH: u32 = 8192;
pub const LKL_RTM_F_OFFLOAD: u32 = 16384;
pub const LKL_RTM_F_TRAP: u32 = 32768;
pub const LKL_RTNH_F_DEAD: u32 = 1;
pub const LKL_RTNH_F_PERVASIVE: u32 = 2;
pub const LKL_RTNH_F_ONLINK: u32 = 4;
pub const LKL_RTNH_F_OFFLOAD: u32 = 8;
pub const LKL_RTNH_F_LINKDOWN: u32 = 16;
pub const LKL_RTNH_F_UNRESOLVED: u32 = 32;
pub const LKL_RTNH_COMPARE_MASK: u32 = 25;
pub const LKL_RTNH_ALIGNTO: u32 = 4;
pub const LKL_RTNETLINK_HAVE_PEERINFO: u32 = 1;
pub const LKL_RTAX_FEATURE_ECN: u32 = 1;
pub const LKL_RTAX_FEATURE_SACK: u32 = 2;
pub const LKL_RTAX_FEATURE_TIMESTAMP: u32 = 4;
pub const LKL_RTAX_FEATURE_ALLFRAG: u32 = 8;
pub const LKL_RTAX_FEATURE_MASK: u32 = 15;
pub const LKL_TCM_IFINDEX_MAGIC_BLOCK: u32 = 4294967295;
pub const LKL_TCA_DUMP_FLAGS_TERSE: u32 = 1;
pub const LKL_RTMGRP_LINK: u32 = 1;
pub const LKL_RTMGRP_NOTIFY: u32 = 2;
pub const LKL_RTMGRP_NEIGH: u32 = 4;
pub const LKL_RTMGRP_TC: u32 = 8;
pub const LKL_RTMGRP_IPV4_IFADDR: u32 = 16;
pub const LKL_RTMGRP_IPV4_MROUTE: u32 = 32;
pub const LKL_RTMGRP_IPV4_ROUTE: u32 = 64;
pub const LKL_RTMGRP_IPV4_RULE: u32 = 128;
pub const LKL_RTMGRP_IPV6_IFADDR: u32 = 256;
pub const LKL_RTMGRP_IPV6_MROUTE: u32 = 512;
pub const LKL_RTMGRP_IPV6_ROUTE: u32 = 1024;
pub const LKL_RTMGRP_IPV6_IFINFO: u32 = 2048;
pub const lkl_RTMGRP_DECnet_IFADDR: u32 = 4096;
pub const lkl_RTMGRP_DECnet_ROUTE: u32 = 16384;
pub const LKL_RTMGRP_IPV6_PREFIX: u32 = 131072;
pub const LKL_TCA_FLAG_LARGE_DUMP_ON: u32 = 1;
pub const LKL_RTEXT_FILTER_VF: u32 = 1;
pub const LKL_RTEXT_FILTER_BRVLAN: u32 = 2;
pub const LKL_RTEXT_FILTER_BRVLAN_COMPRESSED: u32 = 4;
pub const LKL_RTEXT_FILTER_SKIP_STATS: u32 = 8;
pub const LKL_RTEXT_FILTER_MRP: u32 = 16;
pub const LKL_FIB_RULE_PERMANENT: u32 = 1;
pub const LKL_FIB_RULE_INVERT: u32 = 2;
pub const LKL_FIB_RULE_UNRESOLVED: u32 = 4;
pub const LKL_FIB_RULE_IIF_DETACHED: u32 = 8;
pub const LKL_FIB_RULE_DEV_DETACHED: u32 = 8;
pub const LKL_FIB_RULE_OIF_DETACHED: u32 = 16;
pub const LKL_FIB_RULE_FIND_SADDR: u32 = 65536;
pub const LKL_VIRTIO_ID_NET: u32 = 1;
pub const LKL_VIRTIO_ID_BLOCK: u32 = 2;
pub const LKL_VIRTIO_ID_CONSOLE: u32 = 3;
pub const LKL_VIRTIO_ID_RNG: u32 = 4;
pub const LKL_VIRTIO_ID_BALLOON: u32 = 5;
pub const LKL_VIRTIO_ID_RPMSG: u32 = 7;
pub const LKL_VIRTIO_ID_SCSI: u32 = 8;
pub const LKL_VIRTIO_ID_9P: u32 = 9;
pub const LKL_VIRTIO_ID_RPROC_SERIAL: u32 = 11;
pub const LKL_VIRTIO_ID_CAIF: u32 = 12;
pub const LKL_VIRTIO_ID_GPU: u32 = 16;
pub const LKL_VIRTIO_ID_INPUT: u32 = 18;
pub const LKL_VIRTIO_ID_VSOCK: u32 = 19;
pub const LKL_VIRTIO_ID_CRYPTO: u32 = 20;
pub const LKL_VIRTIO_ID_IOMMU: u32 = 23;
pub const LKL_VIRTIO_ID_MEM: u32 = 24;
pub const LKL_VIRTIO_ID_FS: u32 = 26;
pub const LKL_VIRTIO_ID_PMEM: u32 = 27;
pub const LKL_VIRTIO_ID_MAC80211_HWSIM: u32 = 29;
pub const LKL_VIRTIO_CONFIG_S_ACKNOWLEDGE: u32 = 1;
pub const LKL_VIRTIO_CONFIG_S_DRIVER: u32 = 2;
pub const LKL_VIRTIO_CONFIG_S_DRIVER_OK: u32 = 4;
pub const LKL_VIRTIO_CONFIG_S_FEATURES_OK: u32 = 8;
pub const LKL_VIRTIO_CONFIG_S_NEEDS_RESET: u32 = 64;
pub const LKL_VIRTIO_CONFIG_S_FAILED: u32 = 128;
pub const LKL_VIRTIO_TRANSPORT_F_START: u32 = 28;
pub const LKL_VIRTIO_TRANSPORT_F_END: u32 = 38;
pub const LKL_VIRTIO_F_NOTIFY_ON_EMPTY: u32 = 24;
pub const LKL_VIRTIO_F_ANY_LAYOUT: u32 = 27;
pub const LKL_VIRTIO_F_VERSION_1: u32 = 32;
pub const LKL_VIRTIO_F_ACCESS_PLATFORM: u32 = 33;
pub const LKL_VIRTIO_F_IOMMU_PLATFORM: u32 = 33;
pub const LKL_VIRTIO_F_RING_PACKED: u32 = 34;
pub const LKL_VIRTIO_F_ORDER_PLATFORM: u32 = 36;
pub const LKL_VIRTIO_F_SR_IOV: u32 = 37;
pub const LKL_VIRTIO_BLK_F_SIZE_MAX: u32 = 1;
pub const LKL_VIRTIO_BLK_F_SEG_MAX: u32 = 2;
pub const LKL_VIRTIO_BLK_F_GEOMETRY: u32 = 4;
pub const LKL_VIRTIO_BLK_F_RO: u32 = 5;
pub const LKL_VIRTIO_BLK_F_BLK_SIZE: u32 = 6;
pub const LKL_VIRTIO_BLK_F_TOPOLOGY: u32 = 10;
pub const LKL_VIRTIO_BLK_F_MQ: u32 = 12;
pub const LKL_VIRTIO_BLK_F_DISCARD: u32 = 13;
pub const LKL_VIRTIO_BLK_F_WRITE_ZEROES: u32 = 14;
pub const LKL_VIRTIO_BLK_F_BARRIER: u32 = 0;
pub const LKL_VIRTIO_BLK_F_SCSI: u32 = 7;
pub const LKL_VIRTIO_BLK_F_FLUSH: u32 = 9;
pub const LKL_VIRTIO_BLK_F_CONFIG_WCE: u32 = 11;
pub const LKL_VIRTIO_BLK_F_WCE: u32 = 9;
pub const LKL_VIRTIO_BLK_ID_BYTES: u32 = 20;
pub const LKL_VIRTIO_BLK_T_IN: u32 = 0;
pub const LKL_VIRTIO_BLK_T_OUT: u32 = 1;
pub const LKL_VIRTIO_BLK_T_SCSI_CMD: u32 = 2;
pub const LKL_VIRTIO_BLK_T_FLUSH: u32 = 4;
pub const LKL_VIRTIO_BLK_T_GET_ID: u32 = 8;
pub const LKL_VIRTIO_BLK_T_DISCARD: u32 = 11;
pub const LKL_VIRTIO_BLK_T_WRITE_ZEROES: u32 = 13;
pub const LKL_VIRTIO_BLK_T_BARRIER: u32 = 2147483648;
pub const LKL_VIRTIO_BLK_WRITE_ZEROES_FLAG_UNMAP: u32 = 1;
pub const LKL_VIRTIO_BLK_S_OK: u32 = 0;
pub const LKL_VIRTIO_BLK_S_IOERR: u32 = 1;
pub const LKL_VIRTIO_BLK_S_UNSUPP: u32 = 2;
pub const LKL_ETH_ALEN: u32 = 6;
pub const LKL_ETH_TLEN: u32 = 2;
pub const LKL_ETH_HLEN: u32 = 14;
pub const LKL_ETH_ZLEN: u32 = 60;
pub const LKL_ETH_DATA_LEN: u32 = 1500;
pub const LKL_ETH_FRAME_LEN: u32 = 1514;
pub const LKL_ETH_FCS_LEN: u32 = 4;
pub const LKL_ETH_MIN_MTU: u32 = 68;
pub const LKL_ETH_MAX_MTU: u32 = 65535;
pub const LKL_ETH_P_LOOP: u32 = 96;
pub const LKL_ETH_P_PUP: u32 = 512;
pub const LKL_ETH_P_PUPAT: u32 = 513;
pub const LKL_ETH_P_TSN: u32 = 8944;
pub const LKL_ETH_P_ERSPAN2: u32 = 8939;
pub const LKL_ETH_P_IP: u32 = 2048;
pub const LKL_ETH_P_X25: u32 = 2053;
pub const LKL_ETH_P_ARP: u32 = 2054;
pub const LKL_ETH_P_BPQ: u32 = 2303;
pub const LKL_ETH_P_IEEEPUP: u32 = 2560;
pub const LKL_ETH_P_IEEEPUPAT: u32 = 2561;
pub const LKL_ETH_P_BATMAN: u32 = 17157;
pub const LKL_ETH_P_DEC: u32 = 24576;
pub const LKL_ETH_P_DNA_DL: u32 = 24577;
pub const LKL_ETH_P_DNA_RC: u32 = 24578;
pub const LKL_ETH_P_DNA_RT: u32 = 24579;
pub const LKL_ETH_P_LAT: u32 = 24580;
pub const LKL_ETH_P_DIAG: u32 = 24581;
pub const LKL_ETH_P_CUST: u32 = 24582;
pub const LKL_ETH_P_SCA: u32 = 24583;
pub const LKL_ETH_P_TEB: u32 = 25944;
pub const LKL_ETH_P_RARP: u32 = 32821;
pub const LKL_ETH_P_ATALK: u32 = 32923;
pub const LKL_ETH_P_AARP: u32 = 33011;
pub const LKL_ETH_P_8021Q: u32 = 33024;
pub const LKL_ETH_P_ERSPAN: u32 = 35006;
pub const LKL_ETH_P_IPX: u32 = 33079;
pub const LKL_ETH_P_IPV6: u32 = 34525;
pub const LKL_ETH_P_PAUSE: u32 = 34824;
pub const LKL_ETH_P_SLOW: u32 = 34825;
pub const LKL_ETH_P_WCCP: u32 = 34878;
pub const LKL_ETH_P_MPLS_UC: u32 = 34887;
pub const LKL_ETH_P_MPLS_MC: u32 = 34888;
pub const LKL_ETH_P_ATMMPOA: u32 = 34892;
pub const LKL_ETH_P_PPP_DISC: u32 = 34915;
pub const LKL_ETH_P_PPP_SES: u32 = 34916;
pub const LKL_ETH_P_LINK_CTL: u32 = 34924;
pub const LKL_ETH_P_ATMFATE: u32 = 34948;
pub const LKL_ETH_P_PAE: u32 = 34958;
pub const LKL_ETH_P_AOE: u32 = 34978;
pub const LKL_ETH_P_8021AD: u32 = 34984;
pub const LKL_ETH_P_802_EX1: u32 = 34997;
pub const LKL_ETH_P_PREAUTH: u32 = 35015;
pub const LKL_ETH_P_TIPC: u32 = 35018;
pub const LKL_ETH_P_LLDP: u32 = 35020;
pub const LKL_ETH_P_MRP: u32 = 35043;
pub const LKL_ETH_P_MACSEC: u32 = 35045;
pub const LKL_ETH_P_8021AH: u32 = 35047;
pub const LKL_ETH_P_MVRP: u32 = 35061;
pub const LKL_ETH_P_1588: u32 = 35063;
pub const LKL_ETH_P_NCSI: u32 = 35064;
pub const LKL_ETH_P_PRP: u32 = 35067;
pub const LKL_ETH_P_FCOE: u32 = 35078;
pub const LKL_ETH_P_IBOE: u32 = 35093;
pub const LKL_ETH_P_TDLS: u32 = 35085;
pub const LKL_ETH_P_FIP: u32 = 35092;
pub const LKL_ETH_P_80221: u32 = 35095;
pub const LKL_ETH_P_HSR: u32 = 35119;
pub const LKL_ETH_P_NSH: u32 = 35151;
pub const LKL_ETH_P_LOOPBACK: u32 = 36864;
pub const LKL_ETH_P_QINQ1: u32 = 37120;
pub const LKL_ETH_P_QINQ2: u32 = 37376;
pub const LKL_ETH_P_QINQ3: u32 = 37632;
pub const LKL_ETH_P_EDSA: u32 = 56026;
pub const LKL_ETH_P_DSA_8021Q: u32 = 56027;
pub const LKL_ETH_P_IFE: u32 = 60734;
pub const LKL_ETH_P_AF_IUCV: u32 = 64507;
pub const LKL_ETH_P_802_3_MIN: u32 = 1536;
pub const LKL_ETH_P_802_3: u32 = 1;
pub const LKL_ETH_P_AX25: u32 = 2;
pub const LKL_ETH_P_ALL: u32 = 3;
pub const LKL_ETH_P_802_2: u32 = 4;
pub const LKL_ETH_P_SNAP: u32 = 5;
pub const LKL_ETH_P_DDCMP: u32 = 6;
pub const LKL_ETH_P_WAN_PPP: u32 = 7;
pub const LKL_ETH_P_PPP_MP: u32 = 8;
pub const LKL_ETH_P_LOCALTALK: u32 = 9;
pub const LKL_ETH_P_CAN: u32 = 12;
pub const LKL_ETH_P_CANFD: u32 = 13;
pub const LKL_ETH_P_PPPTALK: u32 = 16;
pub const LKL_ETH_P_TR_802_2: u32 = 17;
pub const LKL_ETH_P_MOBITEX: u32 = 21;
pub const LKL_ETH_P_CONTROL: u32 = 22;
pub const LKL_ETH_P_IRDA: u32 = 23;
pub const LKL_ETH_P_ECONET: u32 = 24;
pub const LKL_ETH_P_HDLC: u32 = 25;
pub const LKL_ETH_P_ARCNET: u32 = 26;
pub const LKL_ETH_P_DSA: u32 = 27;
pub const LKL_ETH_P_TRAILER: u32 = 28;
pub const LKL_ETH_P_PHONET: u32 = 245;
pub const LKL_ETH_P_IEEE802154: u32 = 246;
pub const LKL_ETH_P_CAIF: u32 = 247;
pub const LKL_ETH_P_XDSA: u32 = 248;
pub const LKL_ETH_P_MAP: u32 = 249;
pub const __LKL__UAPI_DEF_ETHHDR: u32 = 1;
pub const LKL_VIRTIO_NET_F_CSUM: u32 = 0;
pub const LKL_VIRTIO_NET_F_GUEST_CSUM: u32 = 1;
pub const LKL_VIRTIO_NET_F_CTRL_GUEST_OFFLOADS: u32 = 2;
pub const LKL_VIRTIO_NET_F_MTU: u32 = 3;
pub const LKL_VIRTIO_NET_F_MAC: u32 = 5;
pub const LKL_VIRTIO_NET_F_GUEST_TSO4: u32 = 7;
pub const LKL_VIRTIO_NET_F_GUEST_TSO6: u32 = 8;
pub const LKL_VIRTIO_NET_F_GUEST_ECN: u32 = 9;
pub const LKL_VIRTIO_NET_F_GUEST_UFO: u32 = 10;
pub const LKL_VIRTIO_NET_F_HOST_TSO4: u32 = 11;
pub const LKL_VIRTIO_NET_F_HOST_TSO6: u32 = 12;
pub const LKL_VIRTIO_NET_F_HOST_ECN: u32 = 13;
pub const LKL_VIRTIO_NET_F_HOST_UFO: u32 = 14;
pub const LKL_VIRTIO_NET_F_MRG_RXBUF: u32 = 15;
pub const LKL_VIRTIO_NET_F_STATUS: u32 = 16;
pub const LKL_VIRTIO_NET_F_CTRL_VQ: u32 = 17;
pub const LKL_VIRTIO_NET_F_CTRL_RX: u32 = 18;
pub const LKL_VIRTIO_NET_F_CTRL_VLAN: u32 = 19;
pub const LKL_VIRTIO_NET_F_CTRL_RX_EXTRA: u32 = 20;
pub const LKL_VIRTIO_NET_F_GUEST_ANNOUNCE: u32 = 21;
pub const LKL_VIRTIO_NET_F_MQ: u32 = 22;
pub const LKL_VIRTIO_NET_F_CTRL_MAC_ADDR: u32 = 23;
pub const LKL_VIRTIO_NET_F_HASH_REPORT: u32 = 57;
pub const LKL_VIRTIO_NET_F_RSS: u32 = 60;
pub const LKL_VIRTIO_NET_F_RSC_EXT: u32 = 61;
pub const LKL_VIRTIO_NET_F_STANDBY: u32 = 62;
pub const LKL_VIRTIO_NET_F_SPEED_DUPLEX: u32 = 63;
pub const LKL_VIRTIO_NET_F_GSO: u32 = 6;
pub const LKL_VIRTIO_NET_S_LINK_UP: u32 = 1;
pub const LKL_VIRTIO_NET_S_ANNOUNCE: u32 = 2;
pub const lkl_VIRTIO_NET_RSS_HASH_TYPE_IPv4: u32 = 1;
pub const lkl_VIRTIO_NET_RSS_HASH_TYPE_TCPv4: u32 = 2;
pub const lkl_VIRTIO_NET_RSS_HASH_TYPE_UDPv4: u32 = 4;
pub const lkl_VIRTIO_NET_RSS_HASH_TYPE_IPv6: u32 = 8;
pub const lkl_VIRTIO_NET_RSS_HASH_TYPE_TCPv6: u32 = 16;
pub const lkl_VIRTIO_NET_RSS_HASH_TYPE_UDPv6: u32 = 32;
pub const LKL_VIRTIO_NET_RSS_HASH_TYPE_IP_EX: u32 = 64;
pub const LKL_VIRTIO_NET_RSS_HASH_TYPE_TCP_EX: u32 = 128;
pub const LKL_VIRTIO_NET_RSS_HASH_TYPE_UDP_EX: u32 = 256;
pub const LKL_VIRTIO_NET_HDR_F_NEEDS_CSUM: u32 = 1;
pub const LKL_VIRTIO_NET_HDR_F_DATA_VALID: u32 = 2;
pub const LKL_VIRTIO_NET_HDR_F_RSC_INFO: u32 = 4;
pub const LKL_VIRTIO_NET_HDR_GSO_NONE: u32 = 0;
pub const LKL_VIRTIO_NET_HDR_GSO_TCPV4: u32 = 1;
pub const LKL_VIRTIO_NET_HDR_GSO_UDP: u32 = 3;
pub const LKL_VIRTIO_NET_HDR_GSO_TCPV6: u32 = 4;
pub const LKL_VIRTIO_NET_HDR_GSO_ECN: u32 = 128;
pub const LKL_VIRTIO_NET_HASH_REPORT_NONE: u32 = 0;
pub const lkl_VIRTIO_NET_HASH_REPORT_IPv4: u32 = 1;
pub const lkl_VIRTIO_NET_HASH_REPORT_TCPv4: u32 = 2;
pub const lkl_VIRTIO_NET_HASH_REPORT_UDPv4: u32 = 3;
pub const lkl_VIRTIO_NET_HASH_REPORT_IPv6: u32 = 4;
pub const lkl_VIRTIO_NET_HASH_REPORT_TCPv6: u32 = 5;
pub const lkl_VIRTIO_NET_HASH_REPORT_UDPv6: u32 = 6;
pub const lkl_VIRTIO_NET_HASH_REPORT_IPv6_EX: u32 = 7;
pub const lkl_VIRTIO_NET_HASH_REPORT_TCPv6_EX: u32 = 8;
pub const lkl_VIRTIO_NET_HASH_REPORT_UDPv6_EX: u32 = 9;
pub const LKL_VIRTIO_NET_OK: u32 = 0;
pub const LKL_VIRTIO_NET_ERR: u32 = 1;
pub const LKL_VIRTIO_NET_CTRL_RX: u32 = 0;
pub const LKL_VIRTIO_NET_CTRL_RX_PROMISC: u32 = 0;
pub const LKL_VIRTIO_NET_CTRL_RX_ALLMULTI: u32 = 1;
pub const LKL_VIRTIO_NET_CTRL_RX_ALLUNI: u32 = 2;
pub const LKL_VIRTIO_NET_CTRL_RX_NOMULTI: u32 = 3;
pub const LKL_VIRTIO_NET_CTRL_RX_NOUNI: u32 = 4;
pub const LKL_VIRTIO_NET_CTRL_RX_NOBCAST: u32 = 5;
pub const LKL_VIRTIO_NET_CTRL_MAC: u32 = 1;
pub const LKL_VIRTIO_NET_CTRL_MAC_TABLE_SET: u32 = 0;
pub const LKL_VIRTIO_NET_CTRL_MAC_ADDR_SET: u32 = 1;
pub const LKL_VIRTIO_NET_CTRL_VLAN: u32 = 2;
pub const LKL_VIRTIO_NET_CTRL_VLAN_ADD: u32 = 0;
pub const LKL_VIRTIO_NET_CTRL_VLAN_DEL: u32 = 1;
pub const LKL_VIRTIO_NET_CTRL_ANNOUNCE: u32 = 3;
pub const LKL_VIRTIO_NET_CTRL_ANNOUNCE_ACK: u32 = 0;
pub const LKL_VIRTIO_NET_CTRL_MQ: u32 = 4;
pub const LKL_VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET: u32 = 0;
pub const LKL_VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN: u32 = 1;
pub const LKL_VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX: u32 = 32768;
pub const LKL_VIRTIO_NET_CTRL_MQ_RSS_CONFIG: u32 = 1;
pub const LKL_VIRTIO_NET_CTRL_MQ_HASH_CONFIG: u32 = 2;
pub const LKL_VIRTIO_NET_CTRL_GUEST_OFFLOADS: u32 = 5;
pub const LKL_VIRTIO_NET_CTRL_GUEST_OFFLOADS_SET: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const LKL_VRING_DESC_F_NEXT: u32 = 1;
pub const LKL_VRING_DESC_F_WRITE: u32 = 2;
pub const LKL_VRING_DESC_F_INDIRECT: u32 = 4;
pub const LKL_VRING_PACKED_DESC_F_AVAIL: u32 = 7;
pub const LKL_VRING_PACKED_DESC_F_USED: u32 = 15;
pub const LKL_VRING_USED_F_NO_NOTIFY: u32 = 1;
pub const LKL_VRING_AVAIL_F_NO_INTERRUPT: u32 = 1;
pub const LKL_VRING_PACKED_EVENT_FLAG_ENABLE: u32 = 0;
pub const LKL_VRING_PACKED_EVENT_FLAG_DISABLE: u32 = 1;
pub const LKL_VRING_PACKED_EVENT_FLAG_DESC: u32 = 2;
pub const LKL_VRING_PACKED_EVENT_F_WRAP_CTR: u32 = 15;
pub const LKL_VIRTIO_RING_F_INDIRECT_DESC: u32 = 28;
pub const LKL_VIRTIO_RING_F_EVENT_IDX: u32 = 29;
pub const LKL_VRING_AVAIL_ALIGN_SIZE: u32 = 2;
pub const LKL_VRING_USED_ALIGN_SIZE: u32 = 4;
pub const LKL_VRING_DESC_ALIGN_SIZE: u32 = 16;
pub const LKL_TC_PRIO_BESTEFFORT: u32 = 0;
pub const LKL_TC_PRIO_FILLER: u32 = 1;
pub const LKL_TC_PRIO_BULK: u32 = 2;
pub const LKL_TC_PRIO_INTERACTIVE_BULK: u32 = 4;
pub const LKL_TC_PRIO_INTERACTIVE: u32 = 6;
pub const LKL_TC_PRIO_CONTROL: u32 = 7;
pub const LKL_TC_PRIO_MAX: u32 = 15;
pub const LKL_TC_H_MAJ_MASK: u32 = 4294901760;
pub const LKL_TC_H_MIN_MASK: u32 = 65535;
pub const LKL_TC_H_UNSPEC: u32 = 0;
pub const LKL_TC_H_ROOT: u32 = 4294967295;
pub const LKL_TC_H_INGRESS: u32 = 4294967281;
pub const LKL_TC_H_CLSACT: u32 = 4294967281;
pub const LKL_TC_H_MIN_PRIORITY: u32 = 65504;
pub const LKL_TC_H_MIN_INGRESS: u32 = 65522;
pub const LKL_TC_H_MIN_EGRESS: u32 = 65523;
pub const LKL_TC_LINKLAYER_MASK: u32 = 15;
pub const LKL_TC_RTAB_SIZE: u32 = 1024;
pub const LKL_SKBPRIO_MAX_PRIORITY: u32 = 64;
pub const LKL_TCQ_PRIO_BANDS: u32 = 16;
pub const LKL_TCQ_MIN_PRIO_BANDS: u32 = 2;
pub const LKL_TCQ_PLUG_BUFFER: u32 = 0;
pub const LKL_TCQ_PLUG_RELEASE_ONE: u32 = 1;
pub const LKL_TCQ_PLUG_RELEASE_INDEFINITE: u32 = 2;
pub const LKL_TCQ_PLUG_LIMIT: u32 = 3;
pub const LKL_TC_RED_ECN: u32 = 1;
pub const LKL_TC_RED_HARDDROP: u32 = 2;
pub const LKL_TC_RED_ADAPTATIVE: u32 = 4;
pub const LKL_TC_RED_NODROP: u32 = 8;
pub const LKL_TC_RED_HISTORIC_FLAGS: u32 = 7;
pub const lkl_MAX_DPs: u32 = 16;
pub const LKL_TC_HTB_NUMPRIO: u32 = 8;
pub const LKL_TC_HTB_MAXDEPTH: u32 = 8;
pub const LKL_TC_HTB_PROTOVER: u32 = 3;
pub const LKL_TC_CBQ_MAXPRIO: u32 = 8;
pub const LKL_TC_CBQ_MAXLEVEL: u32 = 8;
pub const LKL_TC_CBQ_DEF_EWMA: u32 = 5;
pub const LKL_TCF_CBQ_LSS_BOUNDED: u32 = 1;
pub const LKL_TCF_CBQ_LSS_ISOLATED: u32 = 2;
pub const LKL_TCF_CBQ_LSS_FLAGS: u32 = 1;
pub const LKL_TCF_CBQ_LSS_EWMA: u32 = 2;
pub const LKL_TCF_CBQ_LSS_MAXIDLE: u32 = 4;
pub const LKL_TCF_CBQ_LSS_MINIDLE: u32 = 8;
pub const LKL_TCF_CBQ_LSS_OFFTIME: u32 = 16;
pub const LKL_TCF_CBQ_LSS_AVPKT: u32 = 32;
pub const LKL_TC_CBQ_OVL_CLASSIC: u32 = 0;
pub const LKL_TC_CBQ_OVL_DELAY: u32 = 1;
pub const LKL_TC_CBQ_OVL_LOWPRIO: u32 = 2;
pub const LKL_TC_CBQ_OVL_DROP: u32 = 3;
pub const LKL_TC_CBQ_OVL_RCLASSIC: u32 = 4;
pub const LKL_NETEM_DIST_SCALE: u32 = 8192;
pub const LKL_NETEM_DIST_MAX: u32 = 16384;
pub const LKL_TC_QOPT_BITMASK: u32 = 15;
pub const LKL_TC_QOPT_MAX_QUEUE: u32 = 16;
pub const LKL_TC_MQPRIO_F_MODE: u32 = 1;
pub const LKL_TC_MQPRIO_F_SHAPER: u32 = 2;
pub const LKL_TC_MQPRIO_F_MIN_RATE: u32 = 4;
pub const LKL_TC_MQPRIO_F_MAX_RATE: u32 = 8;
pub const LKL_SFB_MAX_PROB: u32 = 65535;
pub const LKL_TC_CAKE_MAX_TINS: u32 = 8;
pub const LKL_TCQ_ETS_MAX_BANDS: u32 = 16;
pub const LKL_IORING_SETUP_IOPOLL: u32 = 1;
pub const LKL_IORING_SETUP_SQPOLL: u32 = 2;
pub const LKL_IORING_SETUP_SQ_AFF: u32 = 4;
pub const LKL_IORING_SETUP_CQSIZE: u32 = 8;
pub const LKL_IORING_SETUP_CLAMP: u32 = 16;
pub const LKL_IORING_SETUP_ATTACH_WQ: u32 = 32;
pub const LKL_IORING_SETUP_R_DISABLED: u32 = 64;
pub const LKL_IORING_FSYNC_DATASYNC: u32 = 1;
pub const LKL_IORING_TIMEOUT_ABS: u32 = 1;
pub const LKL_SPLICE_F_FD_IN_FIXED: u32 = 2147483648;
pub const LKL_IORING_CQE_F_BUFFER: u32 = 1;
pub const LKL_IORING_OFF_SQ_RING: u32 = 0;
pub const LKL_IORING_OFF_CQ_RING: u32 = 134217728;
pub const LKL_IORING_OFF_SQES: u32 = 268435456;
pub const LKL_IORING_SQ_NEED_WAKEUP: u32 = 1;
pub const LKL_IORING_SQ_CQ_OVERFLOW: u32 = 2;
pub const LKL_IORING_CQ_EVENTFD_DISABLED: u32 = 1;
pub const LKL_IORING_ENTER_GETEVENTS: u32 = 1;
pub const LKL_IORING_ENTER_SQ_WAKEUP: u32 = 2;
pub const LKL_IORING_ENTER_SQ_WAIT: u32 = 4;
pub const LKL_IORING_FEAT_SINGLE_MMAP: u32 = 1;
pub const LKL_IORING_FEAT_NODROP: u32 = 2;
pub const LKL_IORING_FEAT_SUBMIT_STABLE: u32 = 4;
pub const LKL_IORING_FEAT_RW_CUR_POS: u32 = 8;
pub const LKL_IORING_FEAT_CUR_PERSONALITY: u32 = 16;
pub const LKL_IORING_FEAT_FAST_POLL: u32 = 32;
pub const LKL_IORING_FEAT_POLL_32BITS: u32 = 64;
pub const LKL_IO_URING_OP_SUPPORTED: u32 = 1;
pub const LKL_AF_UNSPEC: u32 = 0;
pub const LKL_AF_UNIX: u32 = 1;
pub const LKL_AF_LOCAL: u32 = 1;
pub const LKL_AF_INET: u32 = 2;
pub const LKL_AF_AX25: u32 = 3;
pub const LKL_AF_IPX: u32 = 4;
pub const LKL_AF_APPLETALK: u32 = 5;
pub const LKL_AF_NETROM: u32 = 6;
pub const LKL_AF_BRIDGE: u32 = 7;
pub const LKL_AF_ATMPVC: u32 = 8;
pub const LKL_AF_X25: u32 = 9;
pub const LKL_AF_INET6: u32 = 10;
pub const LKL_AF_ROSE: u32 = 11;
pub const lkl_AF_DECnet: u32 = 12;
pub const LKL_AF_NETBEUI: u32 = 13;
pub const LKL_AF_SECURITY: u32 = 14;
pub const LKL_AF_KEY: u32 = 15;
pub const LKL_AF_NETLINK: u32 = 16;
pub const LKL_AF_ROUTE: u32 = 16;
pub const LKL_AF_PACKET: u32 = 17;
pub const LKL_AF_ASH: u32 = 18;
pub const LKL_AF_ECONET: u32 = 19;
pub const LKL_AF_ATMSVC: u32 = 20;
pub const LKL_AF_RDS: u32 = 21;
pub const LKL_AF_SNA: u32 = 22;
pub const LKL_AF_IRDA: u32 = 23;
pub const LKL_AF_PPPOX: u32 = 24;
pub const LKL_AF_WANPIPE: u32 = 25;
pub const LKL_AF_LLC: u32 = 26;
pub const LKL_AF_IB: u32 = 27;
pub const LKL_AF_MPLS: u32 = 28;
pub const LKL_AF_CAN: u32 = 29;
pub const LKL_AF_TIPC: u32 = 30;
pub const LKL_AF_BLUETOOTH: u32 = 31;
pub const LKL_AF_IUCV: u32 = 32;
pub const LKL_AF_RXRPC: u32 = 33;
pub const LKL_AF_ISDN: u32 = 34;
pub const LKL_AF_PHONET: u32 = 35;
pub const LKL_AF_IEEE802154: u32 = 36;
pub const LKL_AF_CAIF: u32 = 37;
pub const LKL_AF_ALG: u32 = 38;
pub const LKL_AF_NFC: u32 = 39;
pub const LKL_AF_VSOCK: u32 = 40;
pub const LKL_SOCK_STREAM: u32 = 1;
pub const LKL_SOCK_DGRAM: u32 = 2;
pub const LKL_SOCK_RAW: u32 = 3;
pub const LKL_SOCK_RDM: u32 = 4;
pub const LKL_SOCK_SEQPACKET: u32 = 5;
pub const LKL_SOCK_DCCP: u32 = 6;
pub const LKL_SOCK_PACKET: u32 = 10;
pub const LKL_MSG_TRUNC: u32 = 32;
pub const LKL_MSG_DONTWAIT: u32 = 64;
pub const _SYS_UIO_H: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const LKL_DEV_BLK_TYPE_READ: u32 = 0;
pub const LKL_DEV_BLK_TYPE_WRITE: u32 = 1;
pub const LKL_DEV_BLK_TYPE_FLUSH: u32 = 4;
pub const LKL_DEV_BLK_TYPE_FLUSH_OUT: u32 = 5;
pub const LKL_DEV_BLK_STATUS_OK: u32 = 0;
pub const LKL_DEV_BLK_STATUS_IOERR: u32 = 1;
pub const LKL_DEV_BLK_STATUS_UNSUP: u32 = 2;
pub const LKL_DEV_NET_POLL_RX: u32 = 1;
pub const LKL_DEV_NET_POLL_TX: u32 = 2;
pub const LKL_DEV_NET_POLL_HUP: u32 = 4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_sem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tls_key {
    _unused: [u8; 0],
}
pub type lkl_thread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_jmp_buf {
    pub buf: [::std::os::raw::c_ulong; 128usize],
}
#[test]
fn bindgen_test_layout_lkl_jmp_buf() {
    assert_eq!(
        ::std::mem::size_of::<lkl_jmp_buf>(),
        1024usize,
        concat!("Size of: ", stringify!(lkl_jmp_buf))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_jmp_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_jmp_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_jmp_buf>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_jmp_buf),
            "::",
            stringify!(buf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_pci_dev {
    _unused: [u8; 0],
}
#[doc = " lkl_dev_pci_ops - PCI host operations"]
#[doc = ""]
#[doc = " These operations would be a wrapper of userspace PCI drvier and"]
#[doc = " must be provided by a host library or by the application."]
#[doc = ""]
#[doc = " @add - add a new PCI device; returns a handler or NULL if fails"]
#[doc = " @remove - release resources"]
#[doc = " @init_irq - allocate resources for interrupts"]
#[doc = " @read - read the PCI Configuration Space"]
#[doc = " @write - write the PCI Configuration Space"]
#[doc = " @resource_alloc - map BARx and return the mapped address. x is resource_index"]
#[doc = ""]
#[doc = " @map_page - return the DMA address of pages; vaddr might not be page-aligned"]
#[doc = " @unmap_page - cleanup DMA region if needed"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_dev_pci_ops {
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            kernel_ram: *mut ::std::os::raw::c_void,
            ram_size: ::std::os::raw::c_ulong,
        ) -> *mut lkl_pci_dev,
    >,
    pub remove: ::std::option::Option<unsafe extern "C" fn(dev: *mut lkl_pci_dev)>,
    pub irq_init: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut lkl_pci_dev,
            irq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut lkl_pci_dev,
            where_: ::std::os::raw::c_int,
            size: ::std::os::raw::c_int,
            val: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut lkl_pci_dev,
            where_: ::std::os::raw::c_int,
            size: ::std::os::raw::c_int,
            val: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub resource_alloc: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut lkl_pci_dev,
            resource_size: ::std::os::raw::c_ulong,
            resource_index: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub map_page: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut lkl_pci_dev,
            vaddr: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulonglong,
    >,
    pub unmap_page: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut lkl_pci_dev,
            dma_handle: ::std::os::raw::c_ulonglong,
            size: ::std::os::raw::c_ulong,
        ),
    >,
}
#[test]
fn bindgen_test_layout_lkl_dev_pci_ops() {
    assert_eq!(
        ::std::mem::size_of::<lkl_dev_pci_ops>(),
        64usize,
        concat!("Size of: ", stringify!(lkl_dev_pci_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_dev_pci_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_dev_pci_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_pci_ops>())).add as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_pci_ops),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_pci_ops>())).remove as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_pci_ops),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_pci_ops>())).irq_init as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_pci_ops),
            "::",
            stringify!(irq_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_pci_ops>())).read as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_pci_ops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_pci_ops>())).write as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_pci_ops),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_pci_ops>())).resource_alloc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_pci_ops),
            "::",
            stringify!(resource_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_pci_ops>())).map_page as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_pci_ops),
            "::",
            stringify!(map_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_pci_ops>())).unmap_page as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_pci_ops),
            "::",
            stringify!(unmap_page)
        )
    );
}
#[doc = " lkl_host_operations - host operations used by the Linux kernel"]
#[doc = ""]
#[doc = " These operations must be provided by a host library or by the application"]
#[doc = " itself."]
#[doc = ""]
#[doc = " @virtio_devices - string containg the list of virtio devices in virtio mmio"]
#[doc = " command line format. This string is appended to the kernel command line and"]
#[doc = " is provided here for convenience to be implemented by the host library."]
#[doc = ""]
#[doc = " @print - optional operation that receives console messages"]
#[doc = ""]
#[doc = " @panic - called during a kernel panic"]
#[doc = ""]
#[doc = " @sem_alloc - allocate a host semaphore an initialize it to count"]
#[doc = " @sem_free - free a host semaphore"]
#[doc = " @sem_up - perform an up operation on the semaphore"]
#[doc = " @sem_down - perform a down operation on the semaphore"]
#[doc = ""]
#[doc = " @mutex_alloc - allocate and initialize a host mutex; the recursive parameter"]
#[doc = " determines if the mutex is recursive or not"]
#[doc = " @mutex_free - free a host mutex"]
#[doc = " @mutex_lock - acquire the mutex"]
#[doc = " @mutex_unlock - release the mutex"]
#[doc = ""]
#[doc = " @thread_create - create a new thread and run f(arg) in its context; returns a"]
#[doc = " thread handle or 0 if the thread could not be created"]
#[doc = " @thread_detach - on POSIX systems, free up resources held by"]
#[doc = " pthreads. Noop on Win32."]
#[doc = " @thread_exit - terminates the current thread"]
#[doc = " @thread_join - wait for the given thread to terminate. Returns 0"]
#[doc = " for success, -1 otherwise"]
#[doc = ""]
#[doc = " @tls_alloc - allocate a thread local storage key; returns 0 if successful; if"]
#[doc = " destructor is not NULL it will be called when a thread terminates with its"]
#[doc = " argument set to the current thread local storage value"]
#[doc = " @tls_free - frees a thread local storage key; returns 0 if succesful"]
#[doc = " @tls_set - associate data to the thread local storage key; returns 0 if"]
#[doc = " successful"]
#[doc = " @tls_get - return data associated with the thread local storage key or NULL"]
#[doc = " on error"]
#[doc = ""]
#[doc = " @mem_alloc - allocate memory"]
#[doc = " @mem_free - free memory"]
#[doc = " @page_alloc - allocate page aligned memory"]
#[doc = " @page_free - free memory allocated by page_alloc"]
#[doc = ""]
#[doc = " @timer_create - allocate a host timer that runs fn(arg) when the timer"]
#[doc = " fires."]
#[doc = " @timer_free - disarms and free the timer"]
#[doc = " @timer_set_oneshot - arm the timer to fire once, after delta ns."]
#[doc = " @timer_set_periodic - arm the timer to fire periodically, with a period of"]
#[doc = " delta ns."]
#[doc = ""]
#[doc = " @ioremap - searches for an I/O memory region identified by addr and size and"]
#[doc = " returns a pointer to the start of the address range that can be used by"]
#[doc = " iomem_access"]
#[doc = " @iomem_acess - reads or writes to and I/O memory region; addr must be in the"]
#[doc = " range returned by ioremap"]
#[doc = ""]
#[doc = " @gettid - returns the host thread id of the caller, which need not"]
#[doc = " be the same as the handle returned by thread_create"]
#[doc = ""]
#[doc = " @jmp_buf_set - runs the give function and setups a jump back point by saving"]
#[doc = " the context in the jump buffer; jmp_buf_longjmp can be called from the give"]
#[doc = " function or any callee in that function to return back to the jump back"]
#[doc = " point"]
#[doc = ""]
#[doc = " NOTE: we can't return from jmp_buf_set before calling jmp_buf_longjmp or"]
#[doc = " otherwise the saved context (stack) is not going to be valid, so we must pass"]
#[doc = " the function that will eventually call longjmp here"]
#[doc = ""]
#[doc = " @jmp_buf_longjmp - perform a jump back to the saved jump buffer"]
#[doc = ""]
#[doc = " @memcpy - copy memory"]
#[doc = " @pci_ops - pointer to PCI host operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_host_operations {
    pub virtio_devices: *const ::std::os::raw::c_char,
    pub print: ::std::option::Option<
        unsafe extern "C" fn(str_: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int),
    >,
    pub panic: ::std::option::Option<unsafe extern "C" fn()>,
    pub sem_alloc:
        ::std::option::Option<unsafe extern "C" fn(count: ::std::os::raw::c_int) -> *mut lkl_sem>,
    pub sem_free: ::std::option::Option<unsafe extern "C" fn(sem: *mut lkl_sem)>,
    pub sem_up: ::std::option::Option<unsafe extern "C" fn(sem: *mut lkl_sem)>,
    pub sem_down: ::std::option::Option<unsafe extern "C" fn(sem: *mut lkl_sem)>,
    pub mutex_alloc: ::std::option::Option<
        unsafe extern "C" fn(recursive: ::std::os::raw::c_int) -> *mut lkl_mutex,
    >,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut lkl_mutex)>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut lkl_mutex)>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut lkl_mutex)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            f: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
            arg: *mut ::std::os::raw::c_void,
        ) -> lkl_thread_t,
    >,
    pub thread_detach: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join:
        ::std::option::Option<unsafe extern "C" fn(tid: lkl_thread_t) -> ::std::os::raw::c_int>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn() -> lkl_thread_t>,
    pub thread_equal: ::std::option::Option<
        unsafe extern "C" fn(a: lkl_thread_t, b: lkl_thread_t) -> ::std::os::raw::c_int,
    >,
    pub tls_alloc: ::std::option::Option<
        unsafe extern "C" fn(
            destructor: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
            >,
        ) -> *mut lkl_tls_key,
    >,
    pub tls_free: ::std::option::Option<unsafe extern "C" fn(key: *mut lkl_tls_key)>,
    pub tls_set: ::std::option::Option<
        unsafe extern "C" fn(
            key: *mut lkl_tls_key,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub tls_get: ::std::option::Option<
        unsafe extern "C" fn(key: *mut lkl_tls_key) -> *mut ::std::os::raw::c_void,
    >,
    pub mem_alloc: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void,
    >,
    pub mem_free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub page_alloc: ::std::option::Option<
        unsafe extern "C" fn(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void,
    >,
    pub page_free: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_ulong),
    >,
    pub time: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulonglong>,
    pub timer_alloc: ::std::option::Option<
        unsafe extern "C" fn(
            fn_: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
            arg: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub timer_set_oneshot: ::std::option::Option<
        unsafe extern "C" fn(
            timer: *mut ::std::os::raw::c_void,
            delta: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int,
    >,
    pub timer_free: ::std::option::Option<unsafe extern "C" fn(timer: *mut ::std::os::raw::c_void)>,
    pub ioremap: ::std::option::Option<
        unsafe extern "C" fn(
            addr: ::std::os::raw::c_long,
            size: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub iomem_access: ::std::option::Option<
        unsafe extern "C" fn(
            addr: *const ::std::os::raw::c_void,
            val: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_int,
            write: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub gettid: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>,
    pub jmp_buf_set: ::std::option::Option<
        unsafe extern "C" fn(
            jmpb: *mut lkl_jmp_buf,
            f: ::std::option::Option<unsafe extern "C" fn()>,
        ),
    >,
    pub jmp_buf_longjmp: ::std::option::Option<
        unsafe extern "C" fn(jmpb: *mut lkl_jmp_buf, val: ::std::os::raw::c_int),
    >,
    pub memcpy: ::std::option::Option<
        unsafe extern "C" fn(
            dest: *mut ::std::os::raw::c_void,
            src: *const ::std::os::raw::c_void,
            count: ::std::os::raw::c_ulong,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub pci_ops: *mut lkl_dev_pci_ops,
}
#[test]
fn bindgen_test_layout_lkl_host_operations() {
    assert_eq!(
        ::std::mem::size_of::<lkl_host_operations>(),
        288usize,
        concat!("Size of: ", stringify!(lkl_host_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_host_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_host_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_host_operations>())).virtio_devices as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(virtio_devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).print as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(print)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).panic as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(panic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).sem_alloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(sem_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).sem_free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(sem_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).sem_up as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(sem_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).sem_down as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(sem_down)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).mutex_alloc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(mutex_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).mutex_free as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(mutex_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).mutex_lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(mutex_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_host_operations>())).mutex_unlock as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(mutex_unlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_host_operations>())).thread_create as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(thread_create)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_host_operations>())).thread_detach as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(thread_detach)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).thread_exit as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(thread_exit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).thread_join as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(thread_join)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).thread_self as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(thread_self)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_host_operations>())).thread_equal as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(thread_equal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).tls_alloc as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(tls_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).tls_free as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(tls_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).tls_set as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(tls_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).tls_get as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(tls_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).mem_alloc as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(mem_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).mem_free as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(mem_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).page_alloc as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(page_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).page_free as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(page_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).time as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).timer_alloc as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(timer_alloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_host_operations>())).timer_set_oneshot as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(timer_set_oneshot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).timer_free as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(timer_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).ioremap as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(ioremap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_host_operations>())).iomem_access as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(iomem_access)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).gettid as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(gettid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).jmp_buf_set as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(jmp_buf_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_host_operations>())).jmp_buf_longjmp as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(jmp_buf_longjmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).memcpy as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(memcpy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_host_operations>())).pci_ops as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_host_operations),
            "::",
            stringify!(pci_ops)
        )
    );
}
extern "C" {
    #[doc = " lkl_start_kernel - registers the host operations and starts the kernel"]
    #[doc = ""]
    #[doc = " The function returns only after the kernel is shutdown with lkl_sys_halt."]
    #[doc = ""]
    #[doc = " @lkl_ops - pointer to host operations"]
    #[doc = " @cmd_line - format for command line string that is going to be used to"]
    #[doc = " generate the Linux kernel command line"]
    pub fn lkl_start_kernel(
        lkl_ops: *mut lkl_host_operations,
        cmd_line: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_is_running - returns 1 if the kernel is currently running"]
    pub fn lkl_is_running() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_printf - print a message via the host print operation"]
    #[doc = ""]
    #[doc = " @fmt: printf like format string"]
    pub fn lkl_printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lkl_bug(arg1: *const ::std::os::raw::c_char, ...);
}
pub type __lkl__s8 = ::std::os::raw::c_schar;
pub type __lkl__u8 = ::std::os::raw::c_uchar;
pub type __lkl__s16 = ::std::os::raw::c_short;
pub type __lkl__u16 = ::std::os::raw::c_ushort;
pub type __lkl__s32 = ::std::os::raw::c_int;
pub type __lkl__u32 = ::std::os::raw::c_uint;
pub type __lkl__s64 = ::std::os::raw::c_longlong;
pub type __lkl__u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___lkl__kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__lkl__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __lkl__kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __lkl__kernel_key_t = ::std::os::raw::c_int;
pub type __lkl__kernel_mqd_t = ::std::os::raw::c_int;
pub type __lkl__kernel_long_t = ::std::os::raw::c_long;
pub type __lkl__kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __lkl__kernel_ino_t = __lkl__kernel_ulong_t;
pub type __lkl__kernel_mode_t = ::std::os::raw::c_uint;
pub type __lkl__kernel_pid_t = ::std::os::raw::c_int;
pub type __lkl__kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __lkl__kernel_uid_t = ::std::os::raw::c_uint;
pub type __lkl__kernel_gid_t = ::std::os::raw::c_uint;
pub type __lkl__kernel_suseconds_t = __lkl__kernel_long_t;
pub type __lkl__kernel_daddr_t = ::std::os::raw::c_int;
pub type __lkl__kernel_uid32_t = ::std::os::raw::c_uint;
pub type __lkl__kernel_gid32_t = ::std::os::raw::c_uint;
pub type __lkl__kernel_old_uid_t = __lkl__kernel_uid_t;
pub type __lkl__kernel_old_gid_t = __lkl__kernel_gid_t;
pub type __lkl__kernel_old_dev_t = ::std::os::raw::c_uint;
pub type __lkl__kernel_size_t = __lkl__kernel_ulong_t;
pub type __lkl__kernel_ssize_t = __lkl__kernel_long_t;
pub type __lkl__kernel_ptrdiff_t = __lkl__kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___lkl__kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__lkl__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__lkl__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __lkl__kernel_off_t = __lkl__kernel_long_t;
pub type __lkl__kernel_loff_t = ::std::os::raw::c_longlong;
pub type __lkl__kernel_old_time_t = __lkl__kernel_long_t;
pub type __lkl__kernel_time_t = __lkl__kernel_long_t;
pub type __lkl__kernel_time64_t = ::std::os::raw::c_longlong;
pub type __lkl__kernel_clock_t = __lkl__kernel_long_t;
pub type __lkl__kernel_timer_t = ::std::os::raw::c_int;
pub type __lkl__kernel_clockid_t = ::std::os::raw::c_int;
pub type __lkl__kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __lkl__kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __lkl__kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __lkl__le16 = __lkl__u16;
pub type __lkl__be16 = __lkl__u16;
pub type __lkl__le32 = __lkl__u32;
pub type __lkl__be32 = __lkl__u32;
pub type __lkl__le64 = __lkl__u64;
pub type __lkl__be64 = __lkl__u64;
pub type __lkl__sum16 = __lkl__u16;
pub type __lkl__wsum = __lkl__u32;
pub type __lkl__poll_t = ::std::os::raw::c_uint;
pub type lkl_qid_t = __lkl__kernel_uid32_t;
pub type lkl_fd_set = __lkl__kernel_fd_set;
pub type lkl_mode_t = __lkl__kernel_mode_t;
pub type lkl_umode_t = ::std::os::raw::c_ushort;
pub type lkl_nlink_t = __lkl__u32;
pub type lkl_off_t = __lkl__kernel_off_t;
pub type lkl_pid_t = __lkl__kernel_pid_t;
pub type lkl_key_t = __lkl__kernel_key_t;
pub type lkl_suseconds_t = __lkl__kernel_suseconds_t;
pub type lkl_timer_t = __lkl__kernel_timer_t;
pub type lkl_clockid_t = __lkl__kernel_clockid_t;
pub type lkl_mqd_t = __lkl__kernel_mqd_t;
pub type lkl_uid_t = __lkl__kernel_uid32_t;
pub type lkl_gid_t = __lkl__kernel_gid32_t;
pub type lkl_uid16_t = __lkl__kernel_uid16_t;
pub type lkl_gid16_t = __lkl__kernel_gid16_t;
pub type lkl_uintptr_t = ::std::os::raw::c_ulong;
pub type lkl_loff_t = __lkl__kernel_loff_t;
pub type lkl_size_t = __lkl__kernel_size_t;
pub type lkl_ssize_t = __lkl__kernel_ssize_t;
pub type lkl_time_t = __lkl__kernel_time_t;
pub type lkl_clock_t = __lkl__kernel_clock_t;
pub type lkl_u32 = __lkl__u32;
pub type lkl_s32 = __lkl__s32;
pub type lkl_u64 = __lkl__u64;
pub type lkl_s64 = __lkl__s64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__kernel_timespec {
    pub tv_sec: __lkl__kernel_time64_t,
    pub tv_nsec: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___lkl__kernel_timespec() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__lkl__kernel_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__kernel_timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__kernel_itimerspec {
    pub it_interval: __lkl__kernel_timespec,
    pub it_value: __lkl__kernel_timespec,
}
#[test]
fn bindgen_test_layout___lkl__kernel_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(__lkl__kernel_itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__kernel_itimerspec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_itimerspec>())).it_interval as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_itimerspec>())).it_value as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__kernel_old_timeval {
    pub tv_sec: __lkl__kernel_long_t,
    pub tv_usec: __lkl__kernel_long_t,
}
#[test]
fn bindgen_test_layout___lkl__kernel_old_timeval() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_old_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(__lkl__kernel_old_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_old_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__kernel_old_timeval))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_old_timeval>())).tv_sec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_old_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_old_timeval>())).tv_usec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_old_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__kernel_old_timespec {
    pub tv_sec: __lkl__kernel_old_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout___lkl__kernel_old_timespec() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_old_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__lkl__kernel_old_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_old_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__kernel_old_timespec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_old_timespec>())).tv_sec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_old_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_old_timespec>())).tv_nsec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_old_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__kernel_old_itimerval {
    pub it_interval: __lkl__kernel_old_timeval,
    pub it_value: __lkl__kernel_old_timeval,
}
#[test]
fn bindgen_test_layout___lkl__kernel_old_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_old_itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(__lkl__kernel_old_itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_old_itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__kernel_old_itimerval))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_old_itimerval>())).it_interval as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_old_itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_old_itimerval>())).it_value as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_old_itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__kernel_sock_timeval {
    pub tv_sec: __lkl__s64,
    pub tv_usec: __lkl__s64,
}
#[test]
fn bindgen_test_layout___lkl__kernel_sock_timeval() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_sock_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(__lkl__kernel_sock_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_sock_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__kernel_sock_timeval))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_sock_timeval>())).tv_sec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_sock_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_sock_timeval>())).tv_usec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_sock_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_timespec {
    pub tv_sec: __lkl__kernel_old_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_lkl_timespec() {
    assert_eq!(
        ::std::mem::size_of::<lkl_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_timeval {
    pub tv_sec: __lkl__kernel_old_time_t,
    pub tv_usec: __lkl__kernel_suseconds_t,
}
#[test]
fn bindgen_test_layout_lkl_timeval() {
    assert_eq!(
        ::std::mem::size_of::<lkl_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_itimerspec {
    pub it_interval: lkl_timespec,
    pub it_value: lkl_timespec,
}
#[test]
fn bindgen_test_layout_lkl_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<lkl_itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_itimerval {
    pub it_interval: lkl_timeval,
    pub it_value: lkl_timeval,
}
#[test]
fn bindgen_test_layout_lkl_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<lkl_itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lkl_timezone() {
    assert_eq!(
        ::std::mem::size_of::<lkl_timezone>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tms {
    pub tms_utime: __lkl__kernel_clock_t,
    pub tms_stime: __lkl__kernel_clock_t,
    pub tms_cutime: __lkl__kernel_clock_t,
    pub tms_cstime: __lkl__kernel_clock_t,
}
#[test]
fn bindgen_test_layout_lkl_tms() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tms>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_tms))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tms>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_tms))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tms>())).tms_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tms),
            "::",
            stringify!(tms_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tms>())).tms_stime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tms),
            "::",
            stringify!(tms_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tms>())).tms_cutime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tms),
            "::",
            stringify!(tms_cutime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tms>())).tms_cstime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tms),
            "::",
            stringify!(tms_cstime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_timex {
    pub modes: ::std::os::raw::c_uint,
    pub offset: __lkl__kernel_long_t,
    pub freq: __lkl__kernel_long_t,
    pub maxerror: __lkl__kernel_long_t,
    pub esterror: __lkl__kernel_long_t,
    pub status: ::std::os::raw::c_int,
    pub constant: __lkl__kernel_long_t,
    pub precision: __lkl__kernel_long_t,
    pub tolerance: __lkl__kernel_long_t,
    pub time: lkl_timeval,
    pub tick: __lkl__kernel_long_t,
    pub ppsfreq: __lkl__kernel_long_t,
    pub jitter: __lkl__kernel_long_t,
    pub shift: ::std::os::raw::c_int,
    pub stabil: __lkl__kernel_long_t,
    pub jitcnt: __lkl__kernel_long_t,
    pub calcnt: __lkl__kernel_long_t,
    pub errcnt: __lkl__kernel_long_t,
    pub stbcnt: __lkl__kernel_long_t,
    pub tai: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize]>,
}
#[test]
fn bindgen_test_layout_lkl_timex() {
    assert_eq!(
        ::std::mem::size_of::<lkl_timex>(),
        208usize,
        concat!("Size of: ", stringify!(lkl_timex))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_timex>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_timex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).modes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).freq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).maxerror as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(maxerror)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).esterror as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(esterror)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).status as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).constant as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).precision as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).tolerance as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).time as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).tick as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).ppsfreq as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(ppsfreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).jitter as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(jitter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).shift as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).stabil as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(stabil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).jitcnt as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(jitcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).calcnt as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(calcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).errcnt as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(errcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).stbcnt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(stbcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_timex>())).tai as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_timex),
            "::",
            stringify!(tai)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__kernel_timex_timeval {
    pub tv_sec: __lkl__kernel_time64_t,
    pub tv_usec: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___lkl__kernel_timex_timeval() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_timex_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(__lkl__kernel_timex_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_timex_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__kernel_timex_timeval))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_timex_timeval>())).tv_sec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_timex_timeval>())).tv_usec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lkl__kernel_timex {
    pub modes: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub offset: ::std::os::raw::c_longlong,
    pub freq: ::std::os::raw::c_longlong,
    pub maxerror: ::std::os::raw::c_longlong,
    pub esterror: ::std::os::raw::c_longlong,
    pub status: ::std::os::raw::c_int,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub constant: ::std::os::raw::c_longlong,
    pub precision: ::std::os::raw::c_longlong,
    pub tolerance: ::std::os::raw::c_longlong,
    pub time: __lkl__kernel_timex_timeval,
    pub tick: ::std::os::raw::c_longlong,
    pub ppsfreq: ::std::os::raw::c_longlong,
    pub jitter: ::std::os::raw::c_longlong,
    pub shift: ::std::os::raw::c_int,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub stabil: ::std::os::raw::c_longlong,
    pub jitcnt: ::std::os::raw::c_longlong,
    pub calcnt: ::std::os::raw::c_longlong,
    pub errcnt: ::std::os::raw::c_longlong,
    pub stbcnt: ::std::os::raw::c_longlong,
    pub tai: ::std::os::raw::c_int,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 44usize]>,
}
#[test]
fn bindgen_test_layout___lkl__kernel_timex() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_timex>(),
        208usize,
        concat!("Size of: ", stringify!(__lkl__kernel_timex))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_timex>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__kernel_timex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).modes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).freq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).maxerror as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(maxerror)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).esterror as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(esterror)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).status as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).constant as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).precision as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).tolerance as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).time as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).tick as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).ppsfreq as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(ppsfreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).jitter as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(jitter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).shift as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).stabil as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(stabil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).jitcnt as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(jitcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).calcnt as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(calcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).errcnt as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(errcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).stbcnt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(stbcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__kernel_timex>())).tai as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_timex),
            "::",
            stringify!(tai)
        )
    );
}
impl __lkl__kernel_timex {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__user_cap_header_struct {
    pub version: __lkl__u32,
    pub pid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___lkl__user_cap_header_struct() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__user_cap_header_struct>(),
        8usize,
        concat!("Size of: ", stringify!(__lkl__user_cap_header_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__user_cap_header_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(__lkl__user_cap_header_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__user_cap_header_struct>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__user_cap_header_struct),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__user_cap_header_struct>())).pid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__user_cap_header_struct),
            "::",
            stringify!(pid)
        )
    );
}
pub type lkl_cap_user_header_t = *mut __lkl__user_cap_header_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__user_cap_data_struct {
    pub effective: __lkl__u32,
    pub permitted: __lkl__u32,
    pub inheritable: __lkl__u32,
}
#[test]
fn bindgen_test_layout___lkl__user_cap_data_struct() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__user_cap_data_struct>(),
        12usize,
        concat!("Size of: ", stringify!(__lkl__user_cap_data_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__user_cap_data_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(__lkl__user_cap_data_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__user_cap_data_struct>())).effective as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__user_cap_data_struct),
            "::",
            stringify!(effective)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__user_cap_data_struct>())).permitted as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__user_cap_data_struct),
            "::",
            stringify!(permitted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__user_cap_data_struct>())).inheritable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__user_cap_data_struct),
            "::",
            stringify!(inheritable)
        )
    );
}
pub type lkl_cap_user_data_t = *mut __lkl__user_cap_data_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_vfs_cap_data {
    pub magic_etc: __lkl__le32,
    pub data: [lkl_vfs_cap_data__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_vfs_cap_data__bindgen_ty_1 {
    pub permitted: __lkl__le32,
    pub inheritable: __lkl__le32,
}
#[test]
fn bindgen_test_layout_lkl_vfs_cap_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_vfs_cap_data__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_vfs_cap_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_vfs_cap_data__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_vfs_cap_data__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_vfs_cap_data__bindgen_ty_1>())).permitted as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vfs_cap_data__bindgen_ty_1),
            "::",
            stringify!(permitted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_vfs_cap_data__bindgen_ty_1>())).inheritable as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vfs_cap_data__bindgen_ty_1),
            "::",
            stringify!(inheritable)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_vfs_cap_data() {
    assert_eq!(
        ::std::mem::size_of::<lkl_vfs_cap_data>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_vfs_cap_data))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_vfs_cap_data>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_vfs_cap_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vfs_cap_data>())).magic_etc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vfs_cap_data),
            "::",
            stringify!(magic_etc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vfs_cap_data>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vfs_cap_data),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_vfs_ns_cap_data {
    pub magic_etc: __lkl__le32,
    pub data: [lkl_vfs_ns_cap_data__bindgen_ty_1; 2usize],
    pub rootid: __lkl__le32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_vfs_ns_cap_data__bindgen_ty_1 {
    pub permitted: __lkl__le32,
    pub inheritable: __lkl__le32,
}
#[test]
fn bindgen_test_layout_lkl_vfs_ns_cap_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_vfs_ns_cap_data__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_vfs_ns_cap_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_vfs_ns_cap_data__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_vfs_ns_cap_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_vfs_ns_cap_data__bindgen_ty_1>())).permitted as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vfs_ns_cap_data__bindgen_ty_1),
            "::",
            stringify!(permitted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_vfs_ns_cap_data__bindgen_ty_1>())).inheritable as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vfs_ns_cap_data__bindgen_ty_1),
            "::",
            stringify!(inheritable)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_vfs_ns_cap_data() {
    assert_eq!(
        ::std::mem::size_of::<lkl_vfs_ns_cap_data>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_vfs_ns_cap_data))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_vfs_ns_cap_data>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_vfs_ns_cap_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vfs_ns_cap_data>())).magic_etc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vfs_ns_cap_data),
            "::",
            stringify!(magic_etc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vfs_ns_cap_data>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vfs_ns_cap_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vfs_ns_cap_data>())).rootid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vfs_ns_cap_data),
            "::",
            stringify!(rootid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_statx_timestamp {
    pub tv_sec: __lkl__s64,
    pub tv_nsec: __lkl__u32,
    pub __reserved: __lkl__s32,
}
#[test]
fn bindgen_test_layout_lkl_statx_timestamp() {
    assert_eq!(
        ::std::mem::size_of::<lkl_statx_timestamp>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_statx_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_statx_timestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_statx_timestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx_timestamp>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx_timestamp),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx_timestamp>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx_timestamp),
            "::",
            stringify!(tv_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx_timestamp>())).__reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx_timestamp),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_statx {
    pub stx_mask: __lkl__u32,
    pub stx_blksize: __lkl__u32,
    pub stx_attributes: __lkl__u64,
    pub stx_nlink: __lkl__u32,
    pub stx_uid: __lkl__u32,
    pub stx_gid: __lkl__u32,
    pub stx_mode: __lkl__u16,
    pub __spare0: [__lkl__u16; 1usize],
    pub stx_ino: __lkl__u64,
    pub stx_size: __lkl__u64,
    pub stx_blocks: __lkl__u64,
    pub stx_attributes_mask: __lkl__u64,
    pub stx_atime: lkl_statx_timestamp,
    pub stx_btime: lkl_statx_timestamp,
    pub stx_ctime: lkl_statx_timestamp,
    pub stx_mtime: lkl_statx_timestamp,
    pub stx_rdev_major: __lkl__u32,
    pub stx_rdev_minor: __lkl__u32,
    pub stx_dev_major: __lkl__u32,
    pub stx_dev_minor: __lkl__u32,
    pub stx_mnt_id: __lkl__u64,
    pub __spare2: __lkl__u64,
    pub __spare3: [__lkl__u64; 12usize],
}
#[test]
fn bindgen_test_layout_lkl_statx() {
    assert_eq!(
        ::std::mem::size_of::<lkl_statx>(),
        256usize,
        concat!("Size of: ", stringify!(lkl_statx))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_statx>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_statx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_blksize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_attributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_uid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_gid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_mode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).__spare0 as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(__spare0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_ino as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_blocks as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_attributes_mask as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_attributes_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_atime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_btime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_ctime as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_mtime as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_rdev_major as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_rdev_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_rdev_minor as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_rdev_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_dev_major as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_dev_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_dev_minor as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_dev_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).stx_mnt_id as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(stx_mnt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).__spare2 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(__spare2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statx>())).__spare3 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statx),
            "::",
            stringify!(__spare3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_f_owner_ex {
    pub type_: ::std::os::raw::c_int,
    pub pid: __lkl__kernel_pid_t,
}
#[test]
fn bindgen_test_layout_lkl_f_owner_ex() {
    assert_eq!(
        ::std::mem::size_of::<lkl_f_owner_ex>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_f_owner_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_f_owner_ex>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_f_owner_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_f_owner_ex>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_f_owner_ex),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_f_owner_ex>())).pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_f_owner_ex),
            "::",
            stringify!(pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __lkl__kernel_off_t,
    pub l_len: __lkl__kernel_off_t,
    pub l_pid: __lkl__kernel_pid_t,
}
#[test]
fn bindgen_test_layout_lkl_flock() {
    assert_eq!(
        ::std::mem::size_of::<lkl_flock>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_flock))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_flock>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_flock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_flock>())).l_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_flock>())).l_whence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_flock),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_flock>())).l_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_flock>())).l_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_flock>())).l_pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_flock),
            "::",
            stringify!(l_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_flock64 {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __lkl__kernel_loff_t,
    pub l_len: __lkl__kernel_loff_t,
    pub l_pid: __lkl__kernel_pid_t,
}
#[test]
fn bindgen_test_layout_lkl_flock64() {
    assert_eq!(
        ::std::mem::size_of::<lkl_flock64>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_flock64))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_flock64>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_flock64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_flock64>())).l_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_flock64),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_flock64>())).l_whence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_flock64),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_flock64>())).l_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_flock64),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_flock64>())).l_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_flock64),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_flock64>())).l_pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_flock64),
            "::",
            stringify!(l_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_open_how {
    pub flags: __lkl__u64,
    pub mode: __lkl__u64,
    pub resolve: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_open_how() {
    assert_eq!(
        ::std::mem::size_of::<lkl_open_how>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_open_how))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_open_how>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_open_how))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_open_how>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_open_how),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_open_how>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_open_how),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_open_how>())).resolve as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_open_how),
            "::",
            stringify!(resolve)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_fscrypt_policy_v1 {
    pub version: __lkl__u8,
    pub contents_encryption_mode: __lkl__u8,
    pub filenames_encryption_mode: __lkl__u8,
    pub flags: __lkl__u8,
    pub master_key_descriptor: [__lkl__u8; 8usize],
}
#[test]
fn bindgen_test_layout_lkl_fscrypt_policy_v1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fscrypt_policy_v1>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_fscrypt_policy_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fscrypt_policy_v1>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_fscrypt_policy_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fscrypt_policy_v1>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_policy_v1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_policy_v1>())).contents_encryption_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_policy_v1),
            "::",
            stringify!(contents_encryption_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_policy_v1>())).filenames_encryption_mode as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_policy_v1),
            "::",
            stringify!(filenames_encryption_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fscrypt_policy_v1>())).flags as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_policy_v1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_policy_v1>())).master_key_descriptor as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_policy_v1),
            "::",
            stringify!(master_key_descriptor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_fscrypt_key {
    pub mode: __lkl__u32,
    pub raw: [__lkl__u8; 64usize],
    pub size: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_fscrypt_key() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fscrypt_key>(),
        72usize,
        concat!("Size of: ", stringify!(lkl_fscrypt_key))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fscrypt_key>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_fscrypt_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fscrypt_key>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_key),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fscrypt_key>())).raw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_key),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fscrypt_key>())).size as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_key),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_fscrypt_policy_v2 {
    pub version: __lkl__u8,
    pub contents_encryption_mode: __lkl__u8,
    pub filenames_encryption_mode: __lkl__u8,
    pub flags: __lkl__u8,
    pub __reserved: [__lkl__u8; 4usize],
    pub master_key_identifier: [__lkl__u8; 16usize],
}
#[test]
fn bindgen_test_layout_lkl_fscrypt_policy_v2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fscrypt_policy_v2>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_fscrypt_policy_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fscrypt_policy_v2>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_fscrypt_policy_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fscrypt_policy_v2>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_policy_v2),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_policy_v2>())).contents_encryption_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_policy_v2),
            "::",
            stringify!(contents_encryption_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_policy_v2>())).filenames_encryption_mode as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_policy_v2),
            "::",
            stringify!(filenames_encryption_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fscrypt_policy_v2>())).flags as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_policy_v2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_policy_v2>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_policy_v2),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_policy_v2>())).master_key_identifier as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_policy_v2),
            "::",
            stringify!(master_key_identifier)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_fscrypt_get_policy_ex_arg {
    pub policy_size: __lkl__u64,
    pub policy: lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1 {
    pub version: __lkl__u8,
    pub v1: lkl_fscrypt_policy_v1,
    pub v2: lkl_fscrypt_policy_v2,
}
#[test]
fn bindgen_test_layout_lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1>())).version
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1>())).v1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1>())).v2 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_get_policy_ex_arg__bindgen_ty_1),
            "::",
            stringify!(v2)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_fscrypt_get_policy_ex_arg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fscrypt_get_policy_ex_arg>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_fscrypt_get_policy_ex_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fscrypt_get_policy_ex_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_fscrypt_get_policy_ex_arg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_get_policy_ex_arg>())).policy_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_get_policy_ex_arg),
            "::",
            stringify!(policy_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_get_policy_ex_arg>())).policy as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_get_policy_ex_arg),
            "::",
            stringify!(policy)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_fscrypt_key_specifier {
    pub type_: __lkl__u32,
    pub __reserved: __lkl__u32,
    pub u: lkl_fscrypt_key_specifier__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_fscrypt_key_specifier__bindgen_ty_1 {
    pub __reserved: [__lkl__u8; 32usize],
    pub descriptor: [__lkl__u8; 8usize],
    pub identifier: [__lkl__u8; 16usize],
}
#[test]
fn bindgen_test_layout_lkl_fscrypt_key_specifier__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fscrypt_key_specifier__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(lkl_fscrypt_key_specifier__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fscrypt_key_specifier__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_fscrypt_key_specifier__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_key_specifier__bindgen_ty_1>())).__reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_key_specifier__bindgen_ty_1),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_key_specifier__bindgen_ty_1>())).descriptor
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_key_specifier__bindgen_ty_1),
            "::",
            stringify!(descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_key_specifier__bindgen_ty_1>())).identifier
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_key_specifier__bindgen_ty_1),
            "::",
            stringify!(identifier)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_fscrypt_key_specifier() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fscrypt_key_specifier>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_fscrypt_key_specifier))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fscrypt_key_specifier>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_fscrypt_key_specifier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fscrypt_key_specifier>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_key_specifier),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_key_specifier>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_key_specifier),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fscrypt_key_specifier>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_key_specifier),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_fscrypt_provisioning_key_payload {
    pub type_: __lkl__u32,
    pub __reserved: __lkl__u32,
    pub raw: __IncompleteArrayField<__lkl__u8>,
}
#[test]
fn bindgen_test_layout_lkl_fscrypt_provisioning_key_payload() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fscrypt_provisioning_key_payload>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lkl_fscrypt_provisioning_key_payload)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fscrypt_provisioning_key_payload>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_fscrypt_provisioning_key_payload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_provisioning_key_payload>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_provisioning_key_payload),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_provisioning_key_payload>())).__reserved as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_provisioning_key_payload),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_provisioning_key_payload>())).raw as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_provisioning_key_payload),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
pub struct lkl_fscrypt_add_key_arg {
    pub key_spec: lkl_fscrypt_key_specifier,
    pub raw_size: __lkl__u32,
    pub key_id: __lkl__u32,
    pub __reserved: [__lkl__u32; 8usize],
    pub raw: __IncompleteArrayField<__lkl__u8>,
}
#[test]
fn bindgen_test_layout_lkl_fscrypt_add_key_arg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fscrypt_add_key_arg>(),
        80usize,
        concat!("Size of: ", stringify!(lkl_fscrypt_add_key_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fscrypt_add_key_arg>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_fscrypt_add_key_arg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_add_key_arg>())).key_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_add_key_arg),
            "::",
            stringify!(key_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_add_key_arg>())).raw_size as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_add_key_arg),
            "::",
            stringify!(raw_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fscrypt_add_key_arg>())).key_id as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_add_key_arg),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_add_key_arg>())).__reserved as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_add_key_arg),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fscrypt_add_key_arg>())).raw as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_add_key_arg),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_fscrypt_remove_key_arg {
    pub key_spec: lkl_fscrypt_key_specifier,
    pub removal_status_flags: __lkl__u32,
    pub __reserved: [__lkl__u32; 5usize],
}
#[test]
fn bindgen_test_layout_lkl_fscrypt_remove_key_arg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fscrypt_remove_key_arg>(),
        64usize,
        concat!("Size of: ", stringify!(lkl_fscrypt_remove_key_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fscrypt_remove_key_arg>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_fscrypt_remove_key_arg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_remove_key_arg>())).key_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_remove_key_arg),
            "::",
            stringify!(key_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_remove_key_arg>())).removal_status_flags as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_remove_key_arg),
            "::",
            stringify!(removal_status_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_remove_key_arg>())).__reserved as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_remove_key_arg),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_fscrypt_get_key_status_arg {
    pub key_spec: lkl_fscrypt_key_specifier,
    pub __reserved: [__lkl__u32; 6usize],
    pub status: __lkl__u32,
    pub status_flags: __lkl__u32,
    pub user_count: __lkl__u32,
    pub __out_reserved: [__lkl__u32; 13usize],
}
#[test]
fn bindgen_test_layout_lkl_fscrypt_get_key_status_arg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fscrypt_get_key_status_arg>(),
        128usize,
        concat!("Size of: ", stringify!(lkl_fscrypt_get_key_status_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fscrypt_get_key_status_arg>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_fscrypt_get_key_status_arg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_get_key_status_arg>())).key_spec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_get_key_status_arg),
            "::",
            stringify!(key_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_get_key_status_arg>())).__reserved as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_get_key_status_arg),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_get_key_status_arg>())).status as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_get_key_status_arg),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_get_key_status_arg>())).status_flags as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_get_key_status_arg),
            "::",
            stringify!(status_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_get_key_status_arg>())).user_count as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_get_key_status_arg),
            "::",
            stringify!(user_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_fscrypt_get_key_status_arg>())).__out_reserved as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fscrypt_get_key_status_arg),
            "::",
            stringify!(__out_reserved)
        )
    );
}
pub const lkl_fsconfig_command_LKL_FSCONFIG_SET_FLAG: lkl_fsconfig_command = 0;
pub const lkl_fsconfig_command_LKL_FSCONFIG_SET_STRING: lkl_fsconfig_command = 1;
pub const lkl_fsconfig_command_LKL_FSCONFIG_SET_BINARY: lkl_fsconfig_command = 2;
pub const lkl_fsconfig_command_LKL_FSCONFIG_SET_PATH: lkl_fsconfig_command = 3;
pub const lkl_fsconfig_command_LKL_FSCONFIG_SET_PATH_EMPTY: lkl_fsconfig_command = 4;
pub const lkl_fsconfig_command_LKL_FSCONFIG_SET_FD: lkl_fsconfig_command = 5;
pub const lkl_fsconfig_command_LKL_FSCONFIG_CMD_CREATE: lkl_fsconfig_command = 6;
pub const lkl_fsconfig_command_LKL_FSCONFIG_CMD_RECONFIGURE: lkl_fsconfig_command = 7;
pub type lkl_fsconfig_command = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_file_clone_range {
    pub src_fd: __lkl__s64,
    pub src_offset: __lkl__u64,
    pub src_length: __lkl__u64,
    pub dest_offset: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_file_clone_range() {
    assert_eq!(
        ::std::mem::size_of::<lkl_file_clone_range>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_file_clone_range))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_file_clone_range>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_file_clone_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_file_clone_range>())).src_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_clone_range),
            "::",
            stringify!(src_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_file_clone_range>())).src_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_clone_range),
            "::",
            stringify!(src_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_file_clone_range>())).src_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_clone_range),
            "::",
            stringify!(src_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_file_clone_range>())).dest_offset as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_clone_range),
            "::",
            stringify!(dest_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_fstrim_range {
    pub start: __lkl__u64,
    pub len: __lkl__u64,
    pub minlen: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_fstrim_range() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fstrim_range>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_fstrim_range))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fstrim_range>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_fstrim_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fstrim_range>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fstrim_range),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fstrim_range>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fstrim_range),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fstrim_range>())).minlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fstrim_range),
            "::",
            stringify!(minlen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_file_dedupe_range_info {
    pub dest_fd: __lkl__s64,
    pub dest_offset: __lkl__u64,
    pub bytes_deduped: __lkl__u64,
    pub status: __lkl__s32,
    pub reserved: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_file_dedupe_range_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_file_dedupe_range_info>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_file_dedupe_range_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_file_dedupe_range_info>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_file_dedupe_range_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_file_dedupe_range_info>())).dest_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_dedupe_range_info),
            "::",
            stringify!(dest_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_file_dedupe_range_info>())).dest_offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_dedupe_range_info),
            "::",
            stringify!(dest_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_file_dedupe_range_info>())).bytes_deduped as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_dedupe_range_info),
            "::",
            stringify!(bytes_deduped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_file_dedupe_range_info>())).status as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_dedupe_range_info),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_file_dedupe_range_info>())).reserved as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_dedupe_range_info),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_file_dedupe_range {
    pub src_offset: __lkl__u64,
    pub src_length: __lkl__u64,
    pub dest_count: __lkl__u16,
    pub reserved1: __lkl__u16,
    pub reserved2: __lkl__u32,
    pub info: __IncompleteArrayField<lkl_file_dedupe_range_info>,
}
#[test]
fn bindgen_test_layout_lkl_file_dedupe_range() {
    assert_eq!(
        ::std::mem::size_of::<lkl_file_dedupe_range>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_file_dedupe_range))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_file_dedupe_range>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_file_dedupe_range))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_file_dedupe_range>())).src_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_dedupe_range),
            "::",
            stringify!(src_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_file_dedupe_range>())).src_length as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_dedupe_range),
            "::",
            stringify!(src_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_file_dedupe_range>())).dest_count as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_dedupe_range),
            "::",
            stringify!(dest_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_file_dedupe_range>())).reserved1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_dedupe_range),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_file_dedupe_range>())).reserved2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_dedupe_range),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_file_dedupe_range>())).info as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_file_dedupe_range),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_files_stat_struct {
    pub nr_files: ::std::os::raw::c_ulong,
    pub nr_free_files: ::std::os::raw::c_ulong,
    pub max_files: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_lkl_files_stat_struct() {
    assert_eq!(
        ::std::mem::size_of::<lkl_files_stat_struct>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_files_stat_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_files_stat_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_files_stat_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_files_stat_struct>())).nr_files as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_files_stat_struct),
            "::",
            stringify!(nr_files)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_files_stat_struct>())).nr_free_files as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_files_stat_struct),
            "::",
            stringify!(nr_free_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_files_stat_struct>())).max_files as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_files_stat_struct),
            "::",
            stringify!(max_files)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_inodes_stat_t {
    pub nr_inodes: ::std::os::raw::c_long,
    pub nr_unused: ::std::os::raw::c_long,
    pub dummy: [::std::os::raw::c_long; 5usize],
}
#[test]
fn bindgen_test_layout_lkl_inodes_stat_t() {
    assert_eq!(
        ::std::mem::size_of::<lkl_inodes_stat_t>(),
        56usize,
        concat!("Size of: ", stringify!(lkl_inodes_stat_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_inodes_stat_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_inodes_stat_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_inodes_stat_t>())).nr_inodes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_inodes_stat_t),
            "::",
            stringify!(nr_inodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_inodes_stat_t>())).nr_unused as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_inodes_stat_t),
            "::",
            stringify!(nr_unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_inodes_stat_t>())).dummy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_inodes_stat_t),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_fsxattr {
    pub fsx_xflags: __lkl__u32,
    pub fsx_extsize: __lkl__u32,
    pub fsx_nextents: __lkl__u32,
    pub fsx_projid: __lkl__u32,
    pub fsx_cowextsize: __lkl__u32,
    pub fsx_pad: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_lkl_fsxattr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fsxattr>(),
        28usize,
        concat!("Size of: ", stringify!(lkl_fsxattr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fsxattr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_fsxattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fsxattr>())).fsx_xflags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fsxattr),
            "::",
            stringify!(fsx_xflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fsxattr>())).fsx_extsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fsxattr),
            "::",
            stringify!(fsx_extsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fsxattr>())).fsx_nextents as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fsxattr),
            "::",
            stringify!(fsx_nextents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fsxattr>())).fsx_projid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fsxattr),
            "::",
            stringify!(fsx_projid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fsxattr>())).fsx_cowextsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fsxattr),
            "::",
            stringify!(fsx_cowextsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fsxattr>())).fsx_pad as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fsxattr),
            "::",
            stringify!(fsx_pad)
        )
    );
}
pub type __lkl__kernel_rwf_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_statfs {
    pub f_type: __lkl__kernel_long_t,
    pub f_bsize: __lkl__kernel_long_t,
    pub f_blocks: __lkl__kernel_long_t,
    pub f_bfree: __lkl__kernel_long_t,
    pub f_bavail: __lkl__kernel_long_t,
    pub f_files: __lkl__kernel_long_t,
    pub f_ffree: __lkl__kernel_long_t,
    pub f_fsid: __lkl__kernel_fsid_t,
    pub f_namelen: __lkl__kernel_long_t,
    pub f_frsize: __lkl__kernel_long_t,
    pub f_flags: __lkl__kernel_long_t,
    pub f_spare: [__lkl__kernel_long_t; 4usize],
}
#[test]
fn bindgen_test_layout_lkl_statfs() {
    assert_eq!(
        ::std::mem::size_of::<lkl_statfs>(),
        120usize,
        concat!("Size of: ", stringify!(lkl_statfs))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_statfs>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_statfs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_bsize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_bsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_blocks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_bfree as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_bfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_bavail as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_bavail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_files as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_ffree as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_ffree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_fsid as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_fsid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_namelen as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_frsize as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_frsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs>())).f_spare as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs),
            "::",
            stringify!(f_spare)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_statfs64 {
    pub f_type: __lkl__kernel_long_t,
    pub f_bsize: __lkl__kernel_long_t,
    pub f_blocks: __lkl__u64,
    pub f_bfree: __lkl__u64,
    pub f_bavail: __lkl__u64,
    pub f_files: __lkl__u64,
    pub f_ffree: __lkl__u64,
    pub f_fsid: __lkl__kernel_fsid_t,
    pub f_namelen: __lkl__kernel_long_t,
    pub f_frsize: __lkl__kernel_long_t,
    pub f_flags: __lkl__kernel_long_t,
    pub f_spare: [__lkl__kernel_long_t; 4usize],
}
#[test]
fn bindgen_test_layout_lkl_statfs64() {
    assert_eq!(
        ::std::mem::size_of::<lkl_statfs64>(),
        120usize,
        concat!("Size of: ", stringify!(lkl_statfs64))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_statfs64>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_statfs64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_bsize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_bsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_blocks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_bfree as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_bfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_bavail as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_bavail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_files as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_ffree as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_ffree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_fsid as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_fsid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_namelen as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_frsize as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_frsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_statfs64>())).f_spare as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_statfs64),
            "::",
            stringify!(f_spare)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_compat_statfs64 {
    pub f_type: __lkl__u32,
    pub f_bsize: __lkl__u32,
    pub f_blocks: __lkl__u64,
    pub f_bfree: __lkl__u64,
    pub f_bavail: __lkl__u64,
    pub f_files: __lkl__u64,
    pub f_ffree: __lkl__u64,
    pub f_fsid: __lkl__kernel_fsid_t,
    pub f_namelen: __lkl__u32,
    pub f_frsize: __lkl__u32,
    pub f_flags: __lkl__u32,
    pub f_spare: [__lkl__u32; 4usize],
}
#[test]
fn bindgen_test_layout_lkl_compat_statfs64() {
    assert_eq!(
        ::std::mem::size_of::<lkl_compat_statfs64>(),
        88usize,
        concat!("Size of: ", stringify!(lkl_compat_statfs64))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_compat_statfs64>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_compat_statfs64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_bsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_bsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_blocks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_bfree as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_bfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_bavail as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_bavail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_files as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_ffree as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_ffree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_fsid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_fsid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_namelen as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_frsize as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_frsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_compat_statfs64>())).f_spare as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_compat_statfs64),
            "::",
            stringify!(f_spare)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_stat {
    pub st_dev: ::std::os::raw::c_ulong,
    pub st_ino: ::std::os::raw::c_ulong,
    pub st_mode: ::std::os::raw::c_uint,
    pub st_nlink: ::std::os::raw::c_uint,
    pub st_uid: ::std::os::raw::c_uint,
    pub st_gid: ::std::os::raw::c_uint,
    pub st_rdev: ::std::os::raw::c_ulong,
    pub __pad1: ::std::os::raw::c_ulong,
    pub st_size: ::std::os::raw::c_long,
    pub st_blksize: ::std::os::raw::c_int,
    pub __pad2: ::std::os::raw::c_int,
    pub st_blocks: ::std::os::raw::c_long,
    pub lkl_st_atime: ::std::os::raw::c_long,
    pub st_atime_nsec: ::std::os::raw::c_ulong,
    pub lkl_st_mtime: ::std::os::raw::c_long,
    pub st_mtime_nsec: ::std::os::raw::c_ulong,
    pub lkl_st_ctime: ::std::os::raw::c_long,
    pub st_ctime_nsec: ::std::os::raw::c_ulong,
    pub __unused4: ::std::os::raw::c_uint,
    pub __unused5: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_stat() {
    assert_eq!(
        ::std::mem::size_of::<lkl_stat>(),
        128usize,
        concat!("Size of: ", stringify!(lkl_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_nlink as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_uid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_gid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_rdev as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).__pad1 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).__pad2 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).lkl_st_atime as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(lkl_st_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_atime_nsec as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_atime_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).lkl_st_mtime as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(lkl_st_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_mtime_nsec as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_mtime_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).lkl_st_ctime as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(lkl_st_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).st_ctime_nsec as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(st_ctime_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).__unused4 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(__unused4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat>())).__unused5 as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat),
            "::",
            stringify!(__unused5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_stat64 {
    pub st_dev: ::std::os::raw::c_ulonglong,
    pub st_ino: ::std::os::raw::c_ulonglong,
    pub st_mode: ::std::os::raw::c_uint,
    pub st_nlink: ::std::os::raw::c_uint,
    pub st_uid: ::std::os::raw::c_uint,
    pub st_gid: ::std::os::raw::c_uint,
    pub st_rdev: ::std::os::raw::c_ulonglong,
    pub __pad1: ::std::os::raw::c_ulonglong,
    pub st_size: ::std::os::raw::c_longlong,
    pub st_blksize: ::std::os::raw::c_int,
    pub __pad2: ::std::os::raw::c_int,
    pub st_blocks: ::std::os::raw::c_longlong,
    pub lkl_st_atime: ::std::os::raw::c_int,
    pub st_atime_nsec: ::std::os::raw::c_uint,
    pub lkl_st_mtime: ::std::os::raw::c_int,
    pub st_mtime_nsec: ::std::os::raw::c_uint,
    pub lkl_st_ctime: ::std::os::raw::c_int,
    pub st_ctime_nsec: ::std::os::raw::c_uint,
    pub __unused4: ::std::os::raw::c_uint,
    pub __unused5: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_stat64() {
    assert_eq!(
        ::std::mem::size_of::<lkl_stat64>(),
        104usize,
        concat!("Size of: ", stringify!(lkl_stat64))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_stat64>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_stat64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_nlink as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_uid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_gid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_rdev as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).__pad1 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).__pad2 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).lkl_st_atime as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(lkl_st_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_atime_nsec as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_atime_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).lkl_st_mtime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(lkl_st_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_mtime_nsec as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_mtime_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).lkl_st_ctime as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(lkl_st_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).st_ctime_nsec as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(st_ctime_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).__unused4 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(__unused4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_stat64>())).__unused5 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_stat64),
            "::",
            stringify!(__unused5)
        )
    );
}
pub const LKL_BPF_REG_0: ::std::os::raw::c_uint = 0;
pub const LKL_BPF_REG_1: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_REG_2: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_REG_3: ::std::os::raw::c_uint = 3;
pub const LKL_BPF_REG_4: ::std::os::raw::c_uint = 4;
pub const LKL_BPF_REG_5: ::std::os::raw::c_uint = 5;
pub const LKL_BPF_REG_6: ::std::os::raw::c_uint = 6;
pub const LKL_BPF_REG_7: ::std::os::raw::c_uint = 7;
pub const LKL_BPF_REG_8: ::std::os::raw::c_uint = 8;
pub const LKL_BPF_REG_9: ::std::os::raw::c_uint = 9;
pub const LKL_BPF_REG_10: ::std::os::raw::c_uint = 10;
pub const __LKL__MAX_BPF_REG: ::std::os::raw::c_uint = 11;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_insn {
    pub code: __lkl__u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub off: __lkl__s16,
    pub imm: __lkl__s32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_insn() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_insn>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_insn))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_insn>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_insn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_insn>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_insn),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_insn>())).off as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_insn),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_insn>())).imm as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_insn),
            "::",
            stringify!(imm)
        )
    );
}
impl lkl_bpf_insn {
    #[inline]
    pub fn dst_reg(&self) -> __lkl__u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_dst_reg(&mut self, val: __lkl__u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn src_reg(&self) -> __lkl__u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_src_reg(&mut self, val: __lkl__u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dst_reg: __lkl__u8,
        src_reg: __lkl__u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let dst_reg: u8 = unsafe { ::std::mem::transmute(dst_reg) };
            dst_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let src_reg: u8 = unsafe { ::std::mem::transmute(src_reg) };
            src_reg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_bpf_lpm_trie_key {
    pub prefixlen: __lkl__u32,
    pub data: __IncompleteArrayField<__lkl__u8>,
}
#[test]
fn bindgen_test_layout_lkl_bpf_lpm_trie_key() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_lpm_trie_key>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_bpf_lpm_trie_key))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_lpm_trie_key>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_lpm_trie_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_lpm_trie_key>())).prefixlen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_lpm_trie_key),
            "::",
            stringify!(prefixlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_lpm_trie_key>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_lpm_trie_key),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_cgroup_storage_key {
    pub cgroup_inode_id: __lkl__u64,
    pub attach_type: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_cgroup_storage_key() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_cgroup_storage_key>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_cgroup_storage_key))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_cgroup_storage_key>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_cgroup_storage_key))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_cgroup_storage_key>())).cgroup_inode_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_cgroup_storage_key),
            "::",
            stringify!(cgroup_inode_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_cgroup_storage_key>())).attach_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_cgroup_storage_key),
            "::",
            stringify!(attach_type)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_iter_link_info {
    pub map: lkl_bpf_iter_link_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_iter_link_info__bindgen_ty_1 {
    pub map_fd: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_iter_link_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_iter_link_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_iter_link_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_iter_link_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_iter_link_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_iter_link_info__bindgen_ty_1>())).map_fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_iter_link_info__bindgen_ty_1),
            "::",
            stringify!(map_fd)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_iter_link_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_iter_link_info>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_bpf_iter_link_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_iter_link_info>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_iter_link_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_iter_link_info>())).map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_iter_link_info),
            "::",
            stringify!(map)
        )
    );
}
pub const lkl_bpf_cmd_LKL_BPF_MAP_CREATE: lkl_bpf_cmd = 0;
pub const lkl_bpf_cmd_LKL_BPF_MAP_LOOKUP_ELEM: lkl_bpf_cmd = 1;
pub const lkl_bpf_cmd_LKL_BPF_MAP_UPDATE_ELEM: lkl_bpf_cmd = 2;
pub const lkl_bpf_cmd_LKL_BPF_MAP_DELETE_ELEM: lkl_bpf_cmd = 3;
pub const lkl_bpf_cmd_LKL_BPF_MAP_GET_NEXT_KEY: lkl_bpf_cmd = 4;
pub const lkl_bpf_cmd_LKL_BPF_PROG_LOAD: lkl_bpf_cmd = 5;
pub const lkl_bpf_cmd_LKL_BPF_OBJ_PIN: lkl_bpf_cmd = 6;
pub const lkl_bpf_cmd_LKL_BPF_OBJ_GET: lkl_bpf_cmd = 7;
pub const lkl_bpf_cmd_LKL_BPF_PROG_ATTACH: lkl_bpf_cmd = 8;
pub const lkl_bpf_cmd_LKL_BPF_PROG_DETACH: lkl_bpf_cmd = 9;
pub const lkl_bpf_cmd_LKL_BPF_PROG_TEST_RUN: lkl_bpf_cmd = 10;
pub const lkl_bpf_cmd_LKL_BPF_PROG_GET_NEXT_ID: lkl_bpf_cmd = 11;
pub const lkl_bpf_cmd_LKL_BPF_MAP_GET_NEXT_ID: lkl_bpf_cmd = 12;
pub const lkl_bpf_cmd_LKL_BPF_PROG_GET_FD_BY_ID: lkl_bpf_cmd = 13;
pub const lkl_bpf_cmd_LKL_BPF_MAP_GET_FD_BY_ID: lkl_bpf_cmd = 14;
pub const lkl_bpf_cmd_LKL_BPF_OBJ_GET_INFO_BY_FD: lkl_bpf_cmd = 15;
pub const lkl_bpf_cmd_LKL_BPF_PROG_QUERY: lkl_bpf_cmd = 16;
pub const lkl_bpf_cmd_LKL_BPF_RAW_TRACEPOINT_OPEN: lkl_bpf_cmd = 17;
pub const lkl_bpf_cmd_LKL_BPF_BTF_LOAD: lkl_bpf_cmd = 18;
pub const lkl_bpf_cmd_LKL_BPF_BTF_GET_FD_BY_ID: lkl_bpf_cmd = 19;
pub const lkl_bpf_cmd_LKL_BPF_TASK_FD_QUERY: lkl_bpf_cmd = 20;
pub const lkl_bpf_cmd_LKL_BPF_MAP_LOOKUP_AND_DELETE_ELEM: lkl_bpf_cmd = 21;
pub const lkl_bpf_cmd_LKL_BPF_MAP_FREEZE: lkl_bpf_cmd = 22;
pub const lkl_bpf_cmd_LKL_BPF_BTF_GET_NEXT_ID: lkl_bpf_cmd = 23;
pub const lkl_bpf_cmd_LKL_BPF_MAP_LOOKUP_BATCH: lkl_bpf_cmd = 24;
pub const lkl_bpf_cmd_LKL_BPF_MAP_LOOKUP_AND_DELETE_BATCH: lkl_bpf_cmd = 25;
pub const lkl_bpf_cmd_LKL_BPF_MAP_UPDATE_BATCH: lkl_bpf_cmd = 26;
pub const lkl_bpf_cmd_LKL_BPF_MAP_DELETE_BATCH: lkl_bpf_cmd = 27;
pub const lkl_bpf_cmd_LKL_BPF_LINK_CREATE: lkl_bpf_cmd = 28;
pub const lkl_bpf_cmd_LKL_BPF_LINK_UPDATE: lkl_bpf_cmd = 29;
pub const lkl_bpf_cmd_LKL_BPF_LINK_GET_FD_BY_ID: lkl_bpf_cmd = 30;
pub const lkl_bpf_cmd_LKL_BPF_LINK_GET_NEXT_ID: lkl_bpf_cmd = 31;
pub const lkl_bpf_cmd_LKL_BPF_ENABLE_STATS: lkl_bpf_cmd = 32;
pub const lkl_bpf_cmd_LKL_BPF_ITER_CREATE: lkl_bpf_cmd = 33;
pub const lkl_bpf_cmd_LKL_BPF_LINK_DETACH: lkl_bpf_cmd = 34;
pub const lkl_bpf_cmd_LKL_BPF_PROG_BIND_MAP: lkl_bpf_cmd = 35;
pub type lkl_bpf_cmd = ::std::os::raw::c_uint;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_UNSPEC: lkl_bpf_map_type = 0;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_HASH: lkl_bpf_map_type = 1;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_ARRAY: lkl_bpf_map_type = 2;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_PROG_ARRAY: lkl_bpf_map_type = 3;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_PERF_EVENT_ARRAY: lkl_bpf_map_type = 4;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_PERCPU_HASH: lkl_bpf_map_type = 5;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_PERCPU_ARRAY: lkl_bpf_map_type = 6;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_STACK_TRACE: lkl_bpf_map_type = 7;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_CGROUP_ARRAY: lkl_bpf_map_type = 8;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_LRU_HASH: lkl_bpf_map_type = 9;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_LRU_PERCPU_HASH: lkl_bpf_map_type = 10;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_LPM_TRIE: lkl_bpf_map_type = 11;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_ARRAY_OF_MAPS: lkl_bpf_map_type = 12;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_HASH_OF_MAPS: lkl_bpf_map_type = 13;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_DEVMAP: lkl_bpf_map_type = 14;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_SOCKMAP: lkl_bpf_map_type = 15;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_CPUMAP: lkl_bpf_map_type = 16;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_XSKMAP: lkl_bpf_map_type = 17;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_SOCKHASH: lkl_bpf_map_type = 18;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_CGROUP_STORAGE: lkl_bpf_map_type = 19;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_REUSEPORT_SOCKARRAY: lkl_bpf_map_type = 20;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE: lkl_bpf_map_type = 21;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_QUEUE: lkl_bpf_map_type = 22;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_STACK: lkl_bpf_map_type = 23;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_SK_STORAGE: lkl_bpf_map_type = 24;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_DEVMAP_HASH: lkl_bpf_map_type = 25;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_STRUCT_OPS: lkl_bpf_map_type = 26;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_RINGBUF: lkl_bpf_map_type = 27;
pub const lkl_bpf_map_type_LKL_BPF_MAP_TYPE_INODE_STORAGE: lkl_bpf_map_type = 28;
pub type lkl_bpf_map_type = ::std::os::raw::c_uint;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_UNSPEC: lkl_bpf_prog_type = 0;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_SOCKET_FILTER: lkl_bpf_prog_type = 1;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_KPROBE: lkl_bpf_prog_type = 2;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_SCHED_CLS: lkl_bpf_prog_type = 3;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_SCHED_ACT: lkl_bpf_prog_type = 4;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_TRACEPOINT: lkl_bpf_prog_type = 5;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_XDP: lkl_bpf_prog_type = 6;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_PERF_EVENT: lkl_bpf_prog_type = 7;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_CGROUP_SKB: lkl_bpf_prog_type = 8;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_CGROUP_SOCK: lkl_bpf_prog_type = 9;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_LWT_IN: lkl_bpf_prog_type = 10;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_LWT_OUT: lkl_bpf_prog_type = 11;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_LWT_XMIT: lkl_bpf_prog_type = 12;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_SOCK_OPS: lkl_bpf_prog_type = 13;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_SK_SKB: lkl_bpf_prog_type = 14;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_CGROUP_DEVICE: lkl_bpf_prog_type = 15;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_SK_MSG: lkl_bpf_prog_type = 16;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_RAW_TRACEPOINT: lkl_bpf_prog_type = 17;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_CGROUP_SOCK_ADDR: lkl_bpf_prog_type = 18;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_LWT_SEG6LOCAL: lkl_bpf_prog_type = 19;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_LIRC_MODE2: lkl_bpf_prog_type = 20;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_SK_REUSEPORT: lkl_bpf_prog_type = 21;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_FLOW_DISSECTOR: lkl_bpf_prog_type = 22;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_CGROUP_SYSCTL: lkl_bpf_prog_type = 23;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE: lkl_bpf_prog_type = 24;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_CGROUP_SOCKOPT: lkl_bpf_prog_type = 25;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_TRACING: lkl_bpf_prog_type = 26;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_STRUCT_OPS: lkl_bpf_prog_type = 27;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_EXT: lkl_bpf_prog_type = 28;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_LSM: lkl_bpf_prog_type = 29;
pub const lkl_bpf_prog_type_LKL_BPF_PROG_TYPE_SK_LOOKUP: lkl_bpf_prog_type = 30;
pub type lkl_bpf_prog_type = ::std::os::raw::c_uint;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET_INGRESS: lkl_bpf_attach_type = 0;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET_EGRESS: lkl_bpf_attach_type = 1;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET_SOCK_CREATE: lkl_bpf_attach_type = 2;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_SOCK_OPS: lkl_bpf_attach_type = 3;
pub const lkl_bpf_attach_type_LKL_BPF_SK_SKB_STREAM_PARSER: lkl_bpf_attach_type = 4;
pub const lkl_bpf_attach_type_LKL_BPF_SK_SKB_STREAM_VERDICT: lkl_bpf_attach_type = 5;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_DEVICE: lkl_bpf_attach_type = 6;
pub const lkl_bpf_attach_type_LKL_BPF_SK_MSG_VERDICT: lkl_bpf_attach_type = 7;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET4_BIND: lkl_bpf_attach_type = 8;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET6_BIND: lkl_bpf_attach_type = 9;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET4_CONNECT: lkl_bpf_attach_type = 10;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET6_CONNECT: lkl_bpf_attach_type = 11;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET4_POST_BIND: lkl_bpf_attach_type = 12;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET6_POST_BIND: lkl_bpf_attach_type = 13;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_UDP4_SENDMSG: lkl_bpf_attach_type = 14;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_UDP6_SENDMSG: lkl_bpf_attach_type = 15;
pub const lkl_bpf_attach_type_LKL_BPF_LIRC_MODE2: lkl_bpf_attach_type = 16;
pub const lkl_bpf_attach_type_LKL_BPF_FLOW_DISSECTOR: lkl_bpf_attach_type = 17;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_SYSCTL: lkl_bpf_attach_type = 18;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_UDP4_RECVMSG: lkl_bpf_attach_type = 19;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_UDP6_RECVMSG: lkl_bpf_attach_type = 20;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_GETSOCKOPT: lkl_bpf_attach_type = 21;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_SETSOCKOPT: lkl_bpf_attach_type = 22;
pub const lkl_bpf_attach_type_LKL_BPF_TRACE_RAW_TP: lkl_bpf_attach_type = 23;
pub const lkl_bpf_attach_type_LKL_BPF_TRACE_FENTRY: lkl_bpf_attach_type = 24;
pub const lkl_bpf_attach_type_LKL_BPF_TRACE_FEXIT: lkl_bpf_attach_type = 25;
pub const lkl_bpf_attach_type_LKL_BPF_MODIFY_RETURN: lkl_bpf_attach_type = 26;
pub const lkl_bpf_attach_type_LKL_BPF_LSM_MAC: lkl_bpf_attach_type = 27;
pub const lkl_bpf_attach_type_LKL_BPF_TRACE_ITER: lkl_bpf_attach_type = 28;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET4_GETPEERNAME: lkl_bpf_attach_type = 29;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET6_GETPEERNAME: lkl_bpf_attach_type = 30;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET4_GETSOCKNAME: lkl_bpf_attach_type = 31;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET6_GETSOCKNAME: lkl_bpf_attach_type = 32;
pub const lkl_bpf_attach_type_LKL_BPF_XDP_DEVMAP: lkl_bpf_attach_type = 33;
pub const lkl_bpf_attach_type_LKL_BPF_CGROUP_INET_SOCK_RELEASE: lkl_bpf_attach_type = 34;
pub const lkl_bpf_attach_type_LKL_BPF_XDP_CPUMAP: lkl_bpf_attach_type = 35;
pub const lkl_bpf_attach_type_LKL_BPF_SK_LOOKUP: lkl_bpf_attach_type = 36;
pub const lkl_bpf_attach_type_LKL_BPF_XDP: lkl_bpf_attach_type = 37;
pub const lkl_bpf_attach_type___LKL__MAX_BPF_ATTACH_TYPE: lkl_bpf_attach_type = 38;
pub type lkl_bpf_attach_type = ::std::os::raw::c_uint;
pub const lkl_bpf_link_type_LKL_BPF_LINK_TYPE_UNSPEC: lkl_bpf_link_type = 0;
pub const lkl_bpf_link_type_LKL_BPF_LINK_TYPE_RAW_TRACEPOINT: lkl_bpf_link_type = 1;
pub const lkl_bpf_link_type_LKL_BPF_LINK_TYPE_TRACING: lkl_bpf_link_type = 2;
pub const lkl_bpf_link_type_LKL_BPF_LINK_TYPE_CGROUP: lkl_bpf_link_type = 3;
pub const lkl_bpf_link_type_LKL_BPF_LINK_TYPE_ITER: lkl_bpf_link_type = 4;
pub const lkl_bpf_link_type_LKL_BPF_LINK_TYPE_NETNS: lkl_bpf_link_type = 5;
pub const lkl_bpf_link_type_LKL_BPF_LINK_TYPE_XDP: lkl_bpf_link_type = 6;
pub const lkl_bpf_link_type_LKL_MAX_BPF_LINK_TYPE: lkl_bpf_link_type = 7;
pub type lkl_bpf_link_type = ::std::os::raw::c_uint;
pub const LKL_BPF_ANY: ::std::os::raw::c_uint = 0;
pub const LKL_BPF_NOEXIST: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_EXIST: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_F_LOCK: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const LKL_BPF_F_NO_PREALLOC: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_F_NO_COMMON_LRU: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_F_NUMA_NODE: ::std::os::raw::c_uint = 4;
pub const LKL_BPF_F_RDONLY: ::std::os::raw::c_uint = 8;
pub const LKL_BPF_F_WRONLY: ::std::os::raw::c_uint = 16;
pub const LKL_BPF_F_STACK_BUILD_ID: ::std::os::raw::c_uint = 32;
pub const LKL_BPF_F_ZERO_SEED: ::std::os::raw::c_uint = 64;
pub const LKL_BPF_F_RDONLY_PROG: ::std::os::raw::c_uint = 128;
pub const LKL_BPF_F_WRONLY_PROG: ::std::os::raw::c_uint = 256;
pub const LKL_BPF_F_CLONE: ::std::os::raw::c_uint = 512;
pub const LKL_BPF_F_MMAPABLE: ::std::os::raw::c_uint = 1024;
pub const LKL_BPF_F_PRESERVE_ELEMS: ::std::os::raw::c_uint = 2048;
pub const LKL_BPF_F_INNER_MAP: ::std::os::raw::c_uint = 4096;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const lkl_bpf_stats_type_LKL_BPF_STATS_RUN_TIME: lkl_bpf_stats_type = 0;
pub type lkl_bpf_stats_type = ::std::os::raw::c_uint;
pub const lkl_bpf_stack_build_id_status_LKL_BPF_STACK_BUILD_ID_EMPTY:
    lkl_bpf_stack_build_id_status = 0;
pub const lkl_bpf_stack_build_id_status_LKL_BPF_STACK_BUILD_ID_VALID:
    lkl_bpf_stack_build_id_status = 1;
pub const lkl_bpf_stack_build_id_status_LKL_BPF_STACK_BUILD_ID_IP: lkl_bpf_stack_build_id_status =
    2;
pub type lkl_bpf_stack_build_id_status = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_stack_build_id {
    pub status: __lkl__s32,
    pub build_id: [::std::os::raw::c_uchar; 20usize],
    pub __bindgen_anon_1: lkl_bpf_stack_build_id__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_stack_build_id__bindgen_ty_1 {
    pub offset: __lkl__u64,
    pub ip: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_bpf_stack_build_id__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_stack_build_id__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_stack_build_id__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_stack_build_id__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_stack_build_id__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_stack_build_id__bindgen_ty_1>())).offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_stack_build_id__bindgen_ty_1),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_stack_build_id__bindgen_ty_1>())).ip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_stack_build_id__bindgen_ty_1),
            "::",
            stringify!(ip)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_stack_build_id() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_stack_build_id>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_bpf_stack_build_id))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_stack_build_id>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_stack_build_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_stack_build_id>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_stack_build_id),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_stack_build_id>())).build_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_stack_build_id),
            "::",
            stringify!(build_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_attr {
    pub __bindgen_anon_1: lkl_bpf_attr__bindgen_ty_1,
    pub __bindgen_anon_2: lkl_bpf_attr__bindgen_ty_2,
    pub batch: lkl_bpf_attr__bindgen_ty_3,
    pub __bindgen_anon_3: lkl_bpf_attr__bindgen_ty_4,
    pub __bindgen_anon_4: lkl_bpf_attr__bindgen_ty_5,
    pub __bindgen_anon_5: lkl_bpf_attr__bindgen_ty_6,
    pub test: lkl_bpf_attr__bindgen_ty_7,
    pub __bindgen_anon_6: lkl_bpf_attr__bindgen_ty_8,
    pub info: lkl_bpf_attr__bindgen_ty_9,
    pub query: lkl_bpf_attr__bindgen_ty_10,
    pub raw_tracepoint: lkl_bpf_attr__bindgen_ty_11,
    pub __bindgen_anon_7: lkl_bpf_attr__bindgen_ty_12,
    pub task_fd_query: lkl_bpf_attr__bindgen_ty_13,
    pub link_create: lkl_bpf_attr__bindgen_ty_14,
    pub link_update: lkl_bpf_attr__bindgen_ty_15,
    pub link_detach: lkl_bpf_attr__bindgen_ty_16,
    pub enable_stats: lkl_bpf_attr__bindgen_ty_17,
    pub iter_create: lkl_bpf_attr__bindgen_ty_18,
    pub prog_bind_map: lkl_bpf_attr__bindgen_ty_19,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_1 {
    pub map_type: __lkl__u32,
    pub key_size: __lkl__u32,
    pub value_size: __lkl__u32,
    pub max_entries: __lkl__u32,
    pub map_flags: __lkl__u32,
    pub inner_map_fd: __lkl__u32,
    pub numa_node: __lkl__u32,
    pub map_name: [::std::os::raw::c_char; 16usize],
    pub map_ifindex: __lkl__u32,
    pub btf_fd: __lkl__u32,
    pub btf_key_type_id: __lkl__u32,
    pub btf_value_type_id: __lkl__u32,
    pub btf_vmlinux_value_type_id: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).map_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(map_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).key_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(key_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).value_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(value_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).max_entries as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(max_entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).map_flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(map_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).inner_map_fd as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(inner_map_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).numa_node as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).map_name as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(map_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).map_ifindex as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(map_ifindex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).btf_fd as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(btf_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).btf_key_type_id as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(btf_key_type_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).btf_value_type_id as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(btf_value_type_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_1>())).btf_vmlinux_value_type_id
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_1),
            "::",
            stringify!(btf_vmlinux_value_type_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_2 {
    pub map_fd: __lkl__u32,
    pub key: __lkl__u64,
    pub __bindgen_anon_1: lkl_bpf_attr__bindgen_ty_2__bindgen_ty_1,
    pub flags: __lkl__u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    pub value: __lkl__u64,
    pub next_key: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_attr__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_attr__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_2__bindgen_ty_1>())).value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_2__bindgen_ty_1>())).next_key
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(next_key)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_2>())).map_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_2),
            "::",
            stringify!(map_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_2>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_2),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_2>())).flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_2),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_3 {
    pub in_batch: __lkl__u64,
    pub out_batch: __lkl__u64,
    pub keys: __lkl__u64,
    pub values: __lkl__u64,
    pub count: __lkl__u32,
    pub map_fd: __lkl__u32,
    pub elem_flags: __lkl__u64,
    pub flags: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_3>(),
        56usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_3>())).in_batch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_3),
            "::",
            stringify!(in_batch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_3>())).out_batch as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_3),
            "::",
            stringify!(out_batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_3>())).keys as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_3),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_3>())).values as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_3),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_3>())).count as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_3),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_3>())).map_fd as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_3),
            "::",
            stringify!(map_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_3>())).elem_flags as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_3),
            "::",
            stringify!(elem_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_3>())).flags as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_3),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_4 {
    pub prog_type: __lkl__u32,
    pub insn_cnt: __lkl__u32,
    pub insns: __lkl__u64,
    pub license: __lkl__u64,
    pub log_level: __lkl__u32,
    pub log_size: __lkl__u32,
    pub log_buf: __lkl__u64,
    pub kern_version: __lkl__u32,
    pub prog_flags: __lkl__u32,
    pub prog_name: [::std::os::raw::c_char; 16usize],
    pub prog_ifindex: __lkl__u32,
    pub expected_attach_type: __lkl__u32,
    pub prog_btf_fd: __lkl__u32,
    pub func_info_rec_size: __lkl__u32,
    pub func_info: __lkl__u64,
    pub func_info_cnt: __lkl__u32,
    pub line_info_rec_size: __lkl__u32,
    pub line_info: __lkl__u64,
    pub line_info_cnt: __lkl__u32,
    pub attach_btf_id: __lkl__u32,
    pub attach_prog_fd: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_4>(),
        120usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).prog_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(prog_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).insn_cnt as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(insn_cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).insns as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(insns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).license as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(license)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).log_level as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).log_size as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(log_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).log_buf as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(log_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).kern_version as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(kern_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).prog_flags as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(prog_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).prog_name as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(prog_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).prog_ifindex as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(prog_ifindex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).expected_attach_type as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(expected_attach_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).prog_btf_fd as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(prog_btf_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).func_info_rec_size as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(func_info_rec_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).func_info as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(func_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).func_info_cnt as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(func_info_cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).line_info_rec_size as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(line_info_rec_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).line_info as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(line_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).line_info_cnt as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(line_info_cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).attach_btf_id as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(attach_btf_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_4>())).attach_prog_fd as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_4),
            "::",
            stringify!(attach_prog_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_5 {
    pub pathname: __lkl__u64,
    pub bpf_fd: __lkl__u32,
    pub file_flags: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_5>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_5))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_5>())).pathname as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_5),
            "::",
            stringify!(pathname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_5>())).bpf_fd as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_5),
            "::",
            stringify!(bpf_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_5>())).file_flags as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_5),
            "::",
            stringify!(file_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_6 {
    pub target_fd: __lkl__u32,
    pub attach_bpf_fd: __lkl__u32,
    pub attach_type: __lkl__u32,
    pub attach_flags: __lkl__u32,
    pub replace_bpf_fd: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_6>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_6))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_6>())).target_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_6),
            "::",
            stringify!(target_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_6>())).attach_bpf_fd as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_6),
            "::",
            stringify!(attach_bpf_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_6>())).attach_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_6),
            "::",
            stringify!(attach_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_6>())).attach_flags as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_6),
            "::",
            stringify!(attach_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_6>())).replace_bpf_fd as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_6),
            "::",
            stringify!(replace_bpf_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_7 {
    pub prog_fd: __lkl__u32,
    pub retval: __lkl__u32,
    pub data_size_in: __lkl__u32,
    pub data_size_out: __lkl__u32,
    pub data_in: __lkl__u64,
    pub data_out: __lkl__u64,
    pub repeat: __lkl__u32,
    pub duration: __lkl__u32,
    pub ctx_size_in: __lkl__u32,
    pub ctx_size_out: __lkl__u32,
    pub ctx_in: __lkl__u64,
    pub ctx_out: __lkl__u64,
    pub flags: __lkl__u32,
    pub cpu: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_7>(),
        72usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_7>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_7))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).prog_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(prog_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).retval as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(retval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).data_size_in as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(data_size_in)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).data_size_out as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(data_size_out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).data_in as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(data_in)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).data_out as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(data_out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).repeat as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(repeat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).duration as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).ctx_size_in as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(ctx_size_in)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).ctx_size_out as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(ctx_size_out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).ctx_in as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(ctx_in)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).ctx_out as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(ctx_out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).flags as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_7>())).cpu as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_7),
            "::",
            stringify!(cpu)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_8 {
    pub __bindgen_anon_1: lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1,
    pub next_id: __lkl__u32,
    pub open_flags: __lkl__u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1 {
    pub start_id: __lkl__u32,
    pub prog_id: __lkl__u32,
    pub map_id: __lkl__u32,
    pub btf_id: __lkl__u32,
    pub link_id: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1>())).start_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(start_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1>())).prog_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(prog_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1>())).map_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(map_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1>())).btf_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(btf_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1>())).link_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(link_id)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_8>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_8>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_8))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_8>())).next_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_8),
            "::",
            stringify!(next_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_8>())).open_flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_8),
            "::",
            stringify!(open_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_9 {
    pub bpf_fd: __lkl__u32,
    pub info_len: __lkl__u32,
    pub info: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_9>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_9>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_9))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_9>())).bpf_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_9),
            "::",
            stringify!(bpf_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_9>())).info_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_9),
            "::",
            stringify!(info_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_9>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_9),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_10 {
    pub target_fd: __lkl__u32,
    pub attach_type: __lkl__u32,
    pub query_flags: __lkl__u32,
    pub attach_flags: __lkl__u32,
    pub prog_ids: __lkl__u64,
    pub prog_cnt: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_10>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_10>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_10))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_10>())).target_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_10),
            "::",
            stringify!(target_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_10>())).attach_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_10),
            "::",
            stringify!(attach_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_10>())).query_flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_10),
            "::",
            stringify!(query_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_10>())).attach_flags as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_10),
            "::",
            stringify!(attach_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_10>())).prog_ids as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_10),
            "::",
            stringify!(prog_ids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_10>())).prog_cnt as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_10),
            "::",
            stringify!(prog_cnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_11 {
    pub name: __lkl__u64,
    pub prog_fd: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_11>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_11))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_11>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_11))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_11>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_11),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_11>())).prog_fd as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_11),
            "::",
            stringify!(prog_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_12 {
    pub btf: __lkl__u64,
    pub btf_log_buf: __lkl__u64,
    pub btf_size: __lkl__u32,
    pub btf_log_size: __lkl__u32,
    pub btf_log_level: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_12>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_12))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_12>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_12))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_12>())).btf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_12),
            "::",
            stringify!(btf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_12>())).btf_log_buf as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_12),
            "::",
            stringify!(btf_log_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_12>())).btf_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_12),
            "::",
            stringify!(btf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_12>())).btf_log_size as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_12),
            "::",
            stringify!(btf_log_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_12>())).btf_log_level as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_12),
            "::",
            stringify!(btf_log_level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_13 {
    pub pid: __lkl__u32,
    pub fd: __lkl__u32,
    pub flags: __lkl__u32,
    pub buf_len: __lkl__u32,
    pub buf: __lkl__u64,
    pub prog_id: __lkl__u32,
    pub fd_type: __lkl__u32,
    pub probe_offset: __lkl__u64,
    pub probe_addr: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_13() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_13>(),
        48usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_13))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_13>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_13))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_13>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_13),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_13>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_13),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_13>())).flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_13),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_13>())).buf_len as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_13),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_13>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_13),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_13>())).prog_id as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_13),
            "::",
            stringify!(prog_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_13>())).fd_type as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_13),
            "::",
            stringify!(fd_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_13>())).probe_offset as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_13),
            "::",
            stringify!(probe_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_13>())).probe_addr as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_13),
            "::",
            stringify!(probe_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_14 {
    pub prog_fd: __lkl__u32,
    pub __bindgen_anon_1: lkl_bpf_attr__bindgen_ty_14__bindgen_ty_1,
    pub attach_type: __lkl__u32,
    pub flags: __lkl__u32,
    pub __bindgen_anon_2: lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_attr__bindgen_ty_14__bindgen_ty_1 {
    pub target_fd: __lkl__u32,
    pub target_ifindex: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_14__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_14__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_attr__bindgen_ty_14__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_14__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_attr__bindgen_ty_14__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_14__bindgen_ty_1>())).target_fd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_14__bindgen_ty_1),
            "::",
            stringify!(target_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_14__bindgen_ty_1>())).target_ifindex
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_14__bindgen_ty_1),
            "::",
            stringify!(target_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2 {
    pub target_btf_id: __lkl__u32,
    pub __bindgen_anon_1: lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1 {
    pub iter_info: __lkl__u64,
    pub iter_info_len: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1>()))
                .iter_info as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(iter_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1>()))
                .iter_info_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(iter_info_len)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2>())).target_btf_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_14__bindgen_ty_2),
            "::",
            stringify!(target_btf_id)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_14() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_14>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_14))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_14>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_14))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_14>())).prog_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_14),
            "::",
            stringify!(prog_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_14>())).attach_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_14),
            "::",
            stringify!(attach_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_14>())).flags as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_14),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_15 {
    pub link_fd: __lkl__u32,
    pub new_prog_fd: __lkl__u32,
    pub flags: __lkl__u32,
    pub old_prog_fd: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_15() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_15>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_15))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_15>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_15))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_15>())).link_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_15),
            "::",
            stringify!(link_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_15>())).new_prog_fd as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_15),
            "::",
            stringify!(new_prog_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_15>())).flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_15),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_15>())).old_prog_fd as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_15),
            "::",
            stringify!(old_prog_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_16 {
    pub link_fd: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_16() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_16>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_16))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_16>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_16))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_16>())).link_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_16),
            "::",
            stringify!(link_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_17 {
    pub type_: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_17() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_17>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_17))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_17>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_17))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_17>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_17),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_18 {
    pub link_fd: __lkl__u32,
    pub flags: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_18() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_18>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_18))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_18>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_18))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_18>())).link_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_18),
            "::",
            stringify!(link_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_18>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_18),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_attr__bindgen_ty_19 {
    pub prog_fd: __lkl__u32,
    pub map_fd: __lkl__u32,
    pub flags: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr__bindgen_ty_19() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr__bindgen_ty_19>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr__bindgen_ty_19))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr__bindgen_ty_19>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr__bindgen_ty_19))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_19>())).prog_fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_19),
            "::",
            stringify!(prog_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_19>())).map_fd as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_19),
            "::",
            stringify!(map_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_attr__bindgen_ty_19>())).flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr__bindgen_ty_19),
            "::",
            stringify!(flags)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_attr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_attr>(),
        120usize,
        concat!("Size of: ", stringify!(lkl_bpf_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).batch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).test as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(test)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).query as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).raw_tracepoint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(raw_tracepoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).task_fd_query as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(task_fd_query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).link_create as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(link_create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).link_update as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(link_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).link_detach as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(link_detach)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).enable_stats as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(enable_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).iter_create as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(iter_create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_attr>())).prog_bind_map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_attr),
            "::",
            stringify!(prog_bind_map)
        )
    );
}
pub const lkl_bpf_func_id_BPF_FUNC_unspec: lkl_bpf_func_id = 0;
pub const lkl_bpf_func_id_BPF_FUNC_map_lookup_elem: lkl_bpf_func_id = 1;
pub const lkl_bpf_func_id_BPF_FUNC_map_update_elem: lkl_bpf_func_id = 2;
pub const lkl_bpf_func_id_BPF_FUNC_map_delete_elem: lkl_bpf_func_id = 3;
pub const lkl_bpf_func_id_BPF_FUNC_probe_read: lkl_bpf_func_id = 4;
pub const lkl_bpf_func_id_BPF_FUNC_ktime_get_ns: lkl_bpf_func_id = 5;
pub const lkl_bpf_func_id_BPF_FUNC_trace_printk: lkl_bpf_func_id = 6;
pub const lkl_bpf_func_id_BPF_FUNC_get_prandom_u32: lkl_bpf_func_id = 7;
pub const lkl_bpf_func_id_BPF_FUNC_get_smp_processor_id: lkl_bpf_func_id = 8;
pub const lkl_bpf_func_id_BPF_FUNC_skb_store_bytes: lkl_bpf_func_id = 9;
pub const lkl_bpf_func_id_BPF_FUNC_l3_csum_replace: lkl_bpf_func_id = 10;
pub const lkl_bpf_func_id_BPF_FUNC_l4_csum_replace: lkl_bpf_func_id = 11;
pub const lkl_bpf_func_id_BPF_FUNC_tail_call: lkl_bpf_func_id = 12;
pub const lkl_bpf_func_id_BPF_FUNC_clone_redirect: lkl_bpf_func_id = 13;
pub const lkl_bpf_func_id_BPF_FUNC_get_current_pid_tgid: lkl_bpf_func_id = 14;
pub const lkl_bpf_func_id_BPF_FUNC_get_current_uid_gid: lkl_bpf_func_id = 15;
pub const lkl_bpf_func_id_BPF_FUNC_get_current_comm: lkl_bpf_func_id = 16;
pub const lkl_bpf_func_id_BPF_FUNC_get_cgroup_classid: lkl_bpf_func_id = 17;
pub const lkl_bpf_func_id_BPF_FUNC_skb_vlan_push: lkl_bpf_func_id = 18;
pub const lkl_bpf_func_id_BPF_FUNC_skb_vlan_pop: lkl_bpf_func_id = 19;
pub const lkl_bpf_func_id_BPF_FUNC_skb_get_tunnel_key: lkl_bpf_func_id = 20;
pub const lkl_bpf_func_id_BPF_FUNC_skb_set_tunnel_key: lkl_bpf_func_id = 21;
pub const lkl_bpf_func_id_BPF_FUNC_perf_event_read: lkl_bpf_func_id = 22;
pub const lkl_bpf_func_id_BPF_FUNC_redirect: lkl_bpf_func_id = 23;
pub const lkl_bpf_func_id_BPF_FUNC_get_route_realm: lkl_bpf_func_id = 24;
pub const lkl_bpf_func_id_BPF_FUNC_perf_event_output: lkl_bpf_func_id = 25;
pub const lkl_bpf_func_id_BPF_FUNC_skb_load_bytes: lkl_bpf_func_id = 26;
pub const lkl_bpf_func_id_BPF_FUNC_get_stackid: lkl_bpf_func_id = 27;
pub const lkl_bpf_func_id_BPF_FUNC_csum_diff: lkl_bpf_func_id = 28;
pub const lkl_bpf_func_id_BPF_FUNC_skb_get_tunnel_opt: lkl_bpf_func_id = 29;
pub const lkl_bpf_func_id_BPF_FUNC_skb_set_tunnel_opt: lkl_bpf_func_id = 30;
pub const lkl_bpf_func_id_BPF_FUNC_skb_change_proto: lkl_bpf_func_id = 31;
pub const lkl_bpf_func_id_BPF_FUNC_skb_change_type: lkl_bpf_func_id = 32;
pub const lkl_bpf_func_id_BPF_FUNC_skb_under_cgroup: lkl_bpf_func_id = 33;
pub const lkl_bpf_func_id_BPF_FUNC_get_hash_recalc: lkl_bpf_func_id = 34;
pub const lkl_bpf_func_id_BPF_FUNC_get_current_task: lkl_bpf_func_id = 35;
pub const lkl_bpf_func_id_BPF_FUNC_probe_write_user: lkl_bpf_func_id = 36;
pub const lkl_bpf_func_id_BPF_FUNC_current_task_under_cgroup: lkl_bpf_func_id = 37;
pub const lkl_bpf_func_id_BPF_FUNC_skb_change_tail: lkl_bpf_func_id = 38;
pub const lkl_bpf_func_id_BPF_FUNC_skb_pull_data: lkl_bpf_func_id = 39;
pub const lkl_bpf_func_id_BPF_FUNC_csum_update: lkl_bpf_func_id = 40;
pub const lkl_bpf_func_id_BPF_FUNC_set_hash_invalid: lkl_bpf_func_id = 41;
pub const lkl_bpf_func_id_BPF_FUNC_get_numa_node_id: lkl_bpf_func_id = 42;
pub const lkl_bpf_func_id_BPF_FUNC_skb_change_head: lkl_bpf_func_id = 43;
pub const lkl_bpf_func_id_BPF_FUNC_xdp_adjust_head: lkl_bpf_func_id = 44;
pub const lkl_bpf_func_id_BPF_FUNC_probe_read_str: lkl_bpf_func_id = 45;
pub const lkl_bpf_func_id_BPF_FUNC_get_socket_cookie: lkl_bpf_func_id = 46;
pub const lkl_bpf_func_id_BPF_FUNC_get_socket_uid: lkl_bpf_func_id = 47;
pub const lkl_bpf_func_id_BPF_FUNC_set_hash: lkl_bpf_func_id = 48;
pub const lkl_bpf_func_id_BPF_FUNC_setsockopt: lkl_bpf_func_id = 49;
pub const lkl_bpf_func_id_BPF_FUNC_skb_adjust_room: lkl_bpf_func_id = 50;
pub const lkl_bpf_func_id_BPF_FUNC_redirect_map: lkl_bpf_func_id = 51;
pub const lkl_bpf_func_id_BPF_FUNC_sk_redirect_map: lkl_bpf_func_id = 52;
pub const lkl_bpf_func_id_BPF_FUNC_sock_map_update: lkl_bpf_func_id = 53;
pub const lkl_bpf_func_id_BPF_FUNC_xdp_adjust_meta: lkl_bpf_func_id = 54;
pub const lkl_bpf_func_id_BPF_FUNC_perf_event_read_value: lkl_bpf_func_id = 55;
pub const lkl_bpf_func_id_BPF_FUNC_perf_prog_read_value: lkl_bpf_func_id = 56;
pub const lkl_bpf_func_id_BPF_FUNC_getsockopt: lkl_bpf_func_id = 57;
pub const lkl_bpf_func_id_BPF_FUNC_override_return: lkl_bpf_func_id = 58;
pub const lkl_bpf_func_id_BPF_FUNC_sock_ops_cb_flags_set: lkl_bpf_func_id = 59;
pub const lkl_bpf_func_id_BPF_FUNC_msg_redirect_map: lkl_bpf_func_id = 60;
pub const lkl_bpf_func_id_BPF_FUNC_msg_apply_bytes: lkl_bpf_func_id = 61;
pub const lkl_bpf_func_id_BPF_FUNC_msg_cork_bytes: lkl_bpf_func_id = 62;
pub const lkl_bpf_func_id_BPF_FUNC_msg_pull_data: lkl_bpf_func_id = 63;
pub const lkl_bpf_func_id_BPF_FUNC_bind: lkl_bpf_func_id = 64;
pub const lkl_bpf_func_id_BPF_FUNC_xdp_adjust_tail: lkl_bpf_func_id = 65;
pub const lkl_bpf_func_id_BPF_FUNC_skb_get_xfrm_state: lkl_bpf_func_id = 66;
pub const lkl_bpf_func_id_BPF_FUNC_get_stack: lkl_bpf_func_id = 67;
pub const lkl_bpf_func_id_BPF_FUNC_skb_load_bytes_relative: lkl_bpf_func_id = 68;
pub const lkl_bpf_func_id_BPF_FUNC_fib_lookup: lkl_bpf_func_id = 69;
pub const lkl_bpf_func_id_BPF_FUNC_sock_hash_update: lkl_bpf_func_id = 70;
pub const lkl_bpf_func_id_BPF_FUNC_msg_redirect_hash: lkl_bpf_func_id = 71;
pub const lkl_bpf_func_id_BPF_FUNC_sk_redirect_hash: lkl_bpf_func_id = 72;
pub const lkl_bpf_func_id_BPF_FUNC_lwt_push_encap: lkl_bpf_func_id = 73;
pub const lkl_bpf_func_id_BPF_FUNC_lwt_seg6_store_bytes: lkl_bpf_func_id = 74;
pub const lkl_bpf_func_id_BPF_FUNC_lwt_seg6_adjust_srh: lkl_bpf_func_id = 75;
pub const lkl_bpf_func_id_BPF_FUNC_lwt_seg6_action: lkl_bpf_func_id = 76;
pub const lkl_bpf_func_id_BPF_FUNC_rc_repeat: lkl_bpf_func_id = 77;
pub const lkl_bpf_func_id_BPF_FUNC_rc_keydown: lkl_bpf_func_id = 78;
pub const lkl_bpf_func_id_BPF_FUNC_skb_cgroup_id: lkl_bpf_func_id = 79;
pub const lkl_bpf_func_id_BPF_FUNC_get_current_cgroup_id: lkl_bpf_func_id = 80;
pub const lkl_bpf_func_id_BPF_FUNC_get_local_storage: lkl_bpf_func_id = 81;
pub const lkl_bpf_func_id_BPF_FUNC_sk_select_reuseport: lkl_bpf_func_id = 82;
pub const lkl_bpf_func_id_BPF_FUNC_skb_ancestor_cgroup_id: lkl_bpf_func_id = 83;
pub const lkl_bpf_func_id_BPF_FUNC_sk_lookup_tcp: lkl_bpf_func_id = 84;
pub const lkl_bpf_func_id_BPF_FUNC_sk_lookup_udp: lkl_bpf_func_id = 85;
pub const lkl_bpf_func_id_BPF_FUNC_sk_release: lkl_bpf_func_id = 86;
pub const lkl_bpf_func_id_BPF_FUNC_map_push_elem: lkl_bpf_func_id = 87;
pub const lkl_bpf_func_id_BPF_FUNC_map_pop_elem: lkl_bpf_func_id = 88;
pub const lkl_bpf_func_id_BPF_FUNC_map_peek_elem: lkl_bpf_func_id = 89;
pub const lkl_bpf_func_id_BPF_FUNC_msg_push_data: lkl_bpf_func_id = 90;
pub const lkl_bpf_func_id_BPF_FUNC_msg_pop_data: lkl_bpf_func_id = 91;
pub const lkl_bpf_func_id_BPF_FUNC_rc_pointer_rel: lkl_bpf_func_id = 92;
pub const lkl_bpf_func_id_BPF_FUNC_spin_lock: lkl_bpf_func_id = 93;
pub const lkl_bpf_func_id_BPF_FUNC_spin_unlock: lkl_bpf_func_id = 94;
pub const lkl_bpf_func_id_BPF_FUNC_sk_fullsock: lkl_bpf_func_id = 95;
pub const lkl_bpf_func_id_BPF_FUNC_tcp_sock: lkl_bpf_func_id = 96;
pub const lkl_bpf_func_id_BPF_FUNC_skb_ecn_set_ce: lkl_bpf_func_id = 97;
pub const lkl_bpf_func_id_BPF_FUNC_get_listener_sock: lkl_bpf_func_id = 98;
pub const lkl_bpf_func_id_BPF_FUNC_skc_lookup_tcp: lkl_bpf_func_id = 99;
pub const lkl_bpf_func_id_BPF_FUNC_tcp_check_syncookie: lkl_bpf_func_id = 100;
pub const lkl_bpf_func_id_BPF_FUNC_sysctl_get_name: lkl_bpf_func_id = 101;
pub const lkl_bpf_func_id_BPF_FUNC_sysctl_get_current_value: lkl_bpf_func_id = 102;
pub const lkl_bpf_func_id_BPF_FUNC_sysctl_get_new_value: lkl_bpf_func_id = 103;
pub const lkl_bpf_func_id_BPF_FUNC_sysctl_set_new_value: lkl_bpf_func_id = 104;
pub const lkl_bpf_func_id_BPF_FUNC_strtol: lkl_bpf_func_id = 105;
pub const lkl_bpf_func_id_BPF_FUNC_strtoul: lkl_bpf_func_id = 106;
pub const lkl_bpf_func_id_BPF_FUNC_sk_storage_get: lkl_bpf_func_id = 107;
pub const lkl_bpf_func_id_BPF_FUNC_sk_storage_delete: lkl_bpf_func_id = 108;
pub const lkl_bpf_func_id_BPF_FUNC_send_signal: lkl_bpf_func_id = 109;
pub const lkl_bpf_func_id_BPF_FUNC_tcp_gen_syncookie: lkl_bpf_func_id = 110;
pub const lkl_bpf_func_id_BPF_FUNC_skb_output: lkl_bpf_func_id = 111;
pub const lkl_bpf_func_id_BPF_FUNC_probe_read_user: lkl_bpf_func_id = 112;
pub const lkl_bpf_func_id_BPF_FUNC_probe_read_kernel: lkl_bpf_func_id = 113;
pub const lkl_bpf_func_id_BPF_FUNC_probe_read_user_str: lkl_bpf_func_id = 114;
pub const lkl_bpf_func_id_BPF_FUNC_probe_read_kernel_str: lkl_bpf_func_id = 115;
pub const lkl_bpf_func_id_BPF_FUNC_tcp_send_ack: lkl_bpf_func_id = 116;
pub const lkl_bpf_func_id_BPF_FUNC_send_signal_thread: lkl_bpf_func_id = 117;
pub const lkl_bpf_func_id_BPF_FUNC_jiffies64: lkl_bpf_func_id = 118;
pub const lkl_bpf_func_id_BPF_FUNC_read_branch_records: lkl_bpf_func_id = 119;
pub const lkl_bpf_func_id_BPF_FUNC_get_ns_current_pid_tgid: lkl_bpf_func_id = 120;
pub const lkl_bpf_func_id_BPF_FUNC_xdp_output: lkl_bpf_func_id = 121;
pub const lkl_bpf_func_id_BPF_FUNC_get_netns_cookie: lkl_bpf_func_id = 122;
pub const lkl_bpf_func_id_BPF_FUNC_get_current_ancestor_cgroup_id: lkl_bpf_func_id = 123;
pub const lkl_bpf_func_id_BPF_FUNC_sk_assign: lkl_bpf_func_id = 124;
pub const lkl_bpf_func_id_BPF_FUNC_ktime_get_boot_ns: lkl_bpf_func_id = 125;
pub const lkl_bpf_func_id_BPF_FUNC_seq_printf: lkl_bpf_func_id = 126;
pub const lkl_bpf_func_id_BPF_FUNC_seq_write: lkl_bpf_func_id = 127;
pub const lkl_bpf_func_id_BPF_FUNC_sk_cgroup_id: lkl_bpf_func_id = 128;
pub const lkl_bpf_func_id_BPF_FUNC_sk_ancestor_cgroup_id: lkl_bpf_func_id = 129;
pub const lkl_bpf_func_id_BPF_FUNC_ringbuf_output: lkl_bpf_func_id = 130;
pub const lkl_bpf_func_id_BPF_FUNC_ringbuf_reserve: lkl_bpf_func_id = 131;
pub const lkl_bpf_func_id_BPF_FUNC_ringbuf_submit: lkl_bpf_func_id = 132;
pub const lkl_bpf_func_id_BPF_FUNC_ringbuf_discard: lkl_bpf_func_id = 133;
pub const lkl_bpf_func_id_BPF_FUNC_ringbuf_query: lkl_bpf_func_id = 134;
pub const lkl_bpf_func_id_BPF_FUNC_csum_level: lkl_bpf_func_id = 135;
pub const lkl_bpf_func_id_BPF_FUNC_skc_to_tcp6_sock: lkl_bpf_func_id = 136;
pub const lkl_bpf_func_id_BPF_FUNC_skc_to_tcp_sock: lkl_bpf_func_id = 137;
pub const lkl_bpf_func_id_BPF_FUNC_skc_to_tcp_timewait_sock: lkl_bpf_func_id = 138;
pub const lkl_bpf_func_id_BPF_FUNC_skc_to_tcp_request_sock: lkl_bpf_func_id = 139;
pub const lkl_bpf_func_id_BPF_FUNC_skc_to_udp6_sock: lkl_bpf_func_id = 140;
pub const lkl_bpf_func_id_BPF_FUNC_get_task_stack: lkl_bpf_func_id = 141;
pub const lkl_bpf_func_id_BPF_FUNC_load_hdr_opt: lkl_bpf_func_id = 142;
pub const lkl_bpf_func_id_BPF_FUNC_store_hdr_opt: lkl_bpf_func_id = 143;
pub const lkl_bpf_func_id_BPF_FUNC_reserve_hdr_opt: lkl_bpf_func_id = 144;
pub const lkl_bpf_func_id_BPF_FUNC_inode_storage_get: lkl_bpf_func_id = 145;
pub const lkl_bpf_func_id_BPF_FUNC_inode_storage_delete: lkl_bpf_func_id = 146;
pub const lkl_bpf_func_id_BPF_FUNC_d_path: lkl_bpf_func_id = 147;
pub const lkl_bpf_func_id_BPF_FUNC_copy_from_user: lkl_bpf_func_id = 148;
pub const lkl_bpf_func_id_BPF_FUNC_snprintf_btf: lkl_bpf_func_id = 149;
pub const lkl_bpf_func_id_BPF_FUNC_seq_printf_btf: lkl_bpf_func_id = 150;
pub const lkl_bpf_func_id_BPF_FUNC_skb_cgroup_classid: lkl_bpf_func_id = 151;
pub const lkl_bpf_func_id_BPF_FUNC_redirect_neigh: lkl_bpf_func_id = 152;
pub const lkl_bpf_func_id_BPF_FUNC_per_cpu_ptr: lkl_bpf_func_id = 153;
pub const lkl_bpf_func_id_BPF_FUNC_this_cpu_ptr: lkl_bpf_func_id = 154;
pub const lkl_bpf_func_id_BPF_FUNC_redirect_peer: lkl_bpf_func_id = 155;
pub const lkl_bpf_func_id___LKL__BPF_FUNC_MAX_ID: lkl_bpf_func_id = 156;
pub type lkl_bpf_func_id = ::std::os::raw::c_uint;
pub const LKL_BPF_F_RECOMPUTE_CSUM: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_F_INVALIDATE_HASH: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const LKL_BPF_F_HDR_FIELD_MASK: ::std::os::raw::c_uint = 15;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const LKL_BPF_F_PSEUDO_HDR: ::std::os::raw::c_uint = 16;
pub const LKL_BPF_F_MARK_MANGLED_0: ::std::os::raw::c_uint = 32;
pub const LKL_BPF_F_MARK_ENFORCE: ::std::os::raw::c_uint = 64;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const LKL_BPF_F_INGRESS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const LKL_BPF_F_TUNINFO_IPV6: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const LKL_BPF_F_SKIP_FIELD_MASK: ::std::os::raw::c_uint = 255;
pub const LKL_BPF_F_USER_STACK: ::std::os::raw::c_uint = 256;
pub const LKL_BPF_F_FAST_STACK_CMP: ::std::os::raw::c_uint = 512;
pub const LKL_BPF_F_REUSE_STACKID: ::std::os::raw::c_uint = 1024;
pub const LKL_BPF_F_USER_BUILD_ID: ::std::os::raw::c_uint = 2048;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const LKL_BPF_F_ZERO_CSUM_TX: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_F_DONT_FRAGMENT: ::std::os::raw::c_uint = 4;
pub const LKL_BPF_F_SEQ_NUMBER: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const LKL_BPF_F_INDEX_MASK: ::std::os::raw::c_ulong = 4294967295;
pub const LKL_BPF_F_CURRENT_CPU: ::std::os::raw::c_ulong = 4294967295;
pub const LKL_BPF_F_CTXLEN_MASK: ::std::os::raw::c_ulong = 4503595332403200;
pub type _bindgen_ty_11 = ::std::os::raw::c_ulong;
pub const LKL_BPF_F_CURRENT_NETNS: ::std::os::raw::c_int = -1;
pub type _bindgen_ty_12 = ::std::os::raw::c_int;
pub const LKL_BPF_CSUM_LEVEL_QUERY: ::std::os::raw::c_uint = 0;
pub const LKL_BPF_CSUM_LEVEL_INC: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_CSUM_LEVEL_DEC: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_CSUM_LEVEL_RESET: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const LKL_BPF_F_ADJ_ROOM_FIXED_GSO: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_F_ADJ_ROOM_ENCAP_L3_IPV4: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_F_ADJ_ROOM_ENCAP_L3_IPV6: ::std::os::raw::c_uint = 4;
pub const LKL_BPF_F_ADJ_ROOM_ENCAP_L4_GRE: ::std::os::raw::c_uint = 8;
pub const LKL_BPF_F_ADJ_ROOM_ENCAP_L4_UDP: ::std::os::raw::c_uint = 16;
pub const LKL_BPF_F_ADJ_ROOM_NO_CSUM_RESET: ::std::os::raw::c_uint = 32;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const LKL_BPF_ADJ_ROOM_ENCAP_L2_MASK: ::std::os::raw::c_uint = 255;
pub const LKL_BPF_ADJ_ROOM_ENCAP_L2_SHIFT: ::std::os::raw::c_uint = 56;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const LKL_BPF_F_SYSCTL_BASE_NAME: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const LKL_BPF_LOCAL_STORAGE_GET_F_CREATE: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_SK_STORAGE_GET_F_CREATE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const LKL_BPF_F_GET_BRANCH_RECORDS_SIZE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const LKL_BPF_RB_NO_WAKEUP: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_RB_FORCE_WAKEUP: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const LKL_BPF_RB_AVAIL_DATA: ::std::os::raw::c_uint = 0;
pub const LKL_BPF_RB_RING_SIZE: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_RB_CONS_POS: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_RB_PROD_POS: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
pub const LKL_BPF_RINGBUF_BUSY_BIT: ::std::os::raw::c_uint = 2147483648;
pub const LKL_BPF_RINGBUF_DISCARD_BIT: ::std::os::raw::c_uint = 1073741824;
pub const LKL_BPF_RINGBUF_HDR_SZ: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const LKL_BPF_SK_LOOKUP_F_REPLACE: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_SK_LOOKUP_F_NO_REUSEPORT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const lkl_bpf_adj_room_mode_LKL_BPF_ADJ_ROOM_NET: lkl_bpf_adj_room_mode = 0;
pub const lkl_bpf_adj_room_mode_LKL_BPF_ADJ_ROOM_MAC: lkl_bpf_adj_room_mode = 1;
pub type lkl_bpf_adj_room_mode = ::std::os::raw::c_uint;
pub const lkl_bpf_hdr_start_off_LKL_BPF_HDR_START_MAC: lkl_bpf_hdr_start_off = 0;
pub const lkl_bpf_hdr_start_off_LKL_BPF_HDR_START_NET: lkl_bpf_hdr_start_off = 1;
pub type lkl_bpf_hdr_start_off = ::std::os::raw::c_uint;
pub const lkl_bpf_lwt_encap_mode_LKL_BPF_LWT_ENCAP_SEG6: lkl_bpf_lwt_encap_mode = 0;
pub const lkl_bpf_lwt_encap_mode_LKL_BPF_LWT_ENCAP_SEG6_INLINE: lkl_bpf_lwt_encap_mode = 1;
pub const lkl_bpf_lwt_encap_mode_LKL_BPF_LWT_ENCAP_IP: lkl_bpf_lwt_encap_mode = 2;
pub type lkl_bpf_lwt_encap_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lkl__sk_buff {
    pub len: __lkl__u32,
    pub pkt_type: __lkl__u32,
    pub mark: __lkl__u32,
    pub queue_mapping: __lkl__u32,
    pub protocol: __lkl__u32,
    pub vlan_present: __lkl__u32,
    pub vlan_tci: __lkl__u32,
    pub vlan_proto: __lkl__u32,
    pub priority: __lkl__u32,
    pub ingress_ifindex: __lkl__u32,
    pub ifindex: __lkl__u32,
    pub tc_index: __lkl__u32,
    pub cb: [__lkl__u32; 5usize],
    pub hash: __lkl__u32,
    pub tc_classid: __lkl__u32,
    pub data: __lkl__u32,
    pub data_end: __lkl__u32,
    pub napi_id: __lkl__u32,
    pub family: __lkl__u32,
    pub remote_ip4: __lkl__u32,
    pub local_ip4: __lkl__u32,
    pub remote_ip6: [__lkl__u32; 4usize],
    pub local_ip6: [__lkl__u32; 4usize],
    pub remote_port: __lkl__u32,
    pub local_port: __lkl__u32,
    pub data_meta: __lkl__u32,
    pub __bindgen_anon_1: __lkl__sk_buff__bindgen_ty_1,
    pub tstamp: __lkl__u64,
    pub wire_len: __lkl__u32,
    pub gso_segs: __lkl__u32,
    pub __bindgen_anon_2: __lkl__sk_buff__bindgen_ty_2,
    pub gso_size: __lkl__u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __lkl__sk_buff__bindgen_ty_1 {
    pub flow_keys: *mut lkl_bpf_flow_keys,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout___lkl__sk_buff__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sk_buff__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__lkl__sk_buff__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sk_buff__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__sk_buff__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sk_buff__bindgen_ty_1>())).flow_keys as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff__bindgen_ty_1),
            "::",
            stringify!(flow_keys)
        )
    );
}
impl __lkl__sk_buff__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __lkl__sk_buff__bindgen_ty_2 {
    pub sk: *mut lkl_bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout___lkl__sk_buff__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sk_buff__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__lkl__sk_buff__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sk_buff__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__sk_buff__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff__bindgen_ty_2>())).sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff__bindgen_ty_2),
            "::",
            stringify!(sk)
        )
    );
}
impl __lkl__sk_buff__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout___lkl__sk_buff() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sk_buff>(),
        184usize,
        concat!("Size of: ", stringify!(__lkl__sk_buff))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sk_buff>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__sk_buff))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).pkt_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(pkt_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).mark as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).queue_mapping as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(queue_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).protocol as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).vlan_present as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(vlan_present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).vlan_tci as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).vlan_proto as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(vlan_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).priority as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).ingress_ifindex as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(ingress_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).ifindex as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).tc_index as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(tc_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).cb as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).hash as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).tc_classid as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(tc_classid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).data as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).data_end as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(data_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).napi_id as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(napi_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).family as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).remote_ip4 as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(remote_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).local_ip4 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(local_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).remote_ip6 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(remote_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).local_ip6 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(local_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).remote_port as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).local_port as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).data_meta as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(data_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).tstamp as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(tstamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).wire_len as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(wire_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).gso_segs as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(gso_segs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sk_buff>())).gso_size as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sk_buff),
            "::",
            stringify!(gso_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_tunnel_key {
    pub tunnel_id: __lkl__u32,
    pub __bindgen_anon_1: lkl_bpf_tunnel_key__bindgen_ty_1,
    pub tunnel_tos: __lkl__u8,
    pub tunnel_ttl: __lkl__u8,
    pub tunnel_ext: __lkl__u16,
    pub tunnel_label: __lkl__u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_tunnel_key__bindgen_ty_1 {
    pub remote_ipv4: __lkl__u32,
    pub remote_ipv6: [__lkl__u32; 4usize],
}
#[test]
fn bindgen_test_layout_lkl_bpf_tunnel_key__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_tunnel_key__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_tunnel_key__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_tunnel_key__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_tunnel_key__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_tunnel_key__bindgen_ty_1>())).remote_ipv4 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tunnel_key__bindgen_ty_1),
            "::",
            stringify!(remote_ipv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_tunnel_key__bindgen_ty_1>())).remote_ipv6 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tunnel_key__bindgen_ty_1),
            "::",
            stringify!(remote_ipv6)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_tunnel_key() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_tunnel_key>(),
        28usize,
        concat!("Size of: ", stringify!(lkl_bpf_tunnel_key))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_tunnel_key>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_tunnel_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tunnel_key>())).tunnel_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tunnel_key),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tunnel_key>())).tunnel_tos as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tunnel_key),
            "::",
            stringify!(tunnel_tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tunnel_key>())).tunnel_ttl as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tunnel_key),
            "::",
            stringify!(tunnel_ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tunnel_key>())).tunnel_ext as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tunnel_key),
            "::",
            stringify!(tunnel_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tunnel_key>())).tunnel_label as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tunnel_key),
            "::",
            stringify!(tunnel_label)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_xfrm_state {
    pub reqid: __lkl__u32,
    pub spi: __lkl__u32,
    pub family: __lkl__u16,
    pub ext: __lkl__u16,
    pub __bindgen_anon_1: lkl_bpf_xfrm_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_xfrm_state__bindgen_ty_1 {
    pub remote_ipv4: __lkl__u32,
    pub remote_ipv6: [__lkl__u32; 4usize],
}
#[test]
fn bindgen_test_layout_lkl_bpf_xfrm_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_xfrm_state__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_xfrm_state__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_xfrm_state__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_xfrm_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_xfrm_state__bindgen_ty_1>())).remote_ipv4 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_xfrm_state__bindgen_ty_1),
            "::",
            stringify!(remote_ipv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_xfrm_state__bindgen_ty_1>())).remote_ipv6 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_xfrm_state__bindgen_ty_1),
            "::",
            stringify!(remote_ipv6)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_xfrm_state() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_xfrm_state>(),
        28usize,
        concat!("Size of: ", stringify!(lkl_bpf_xfrm_state))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_xfrm_state>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_xfrm_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_xfrm_state>())).reqid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_xfrm_state),
            "::",
            stringify!(reqid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_xfrm_state>())).spi as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_xfrm_state),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_xfrm_state>())).family as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_xfrm_state),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_xfrm_state>())).ext as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_xfrm_state),
            "::",
            stringify!(ext)
        )
    );
}
pub const lkl_bpf_ret_code_LKL_BPF_OK: lkl_bpf_ret_code = 0;
pub const lkl_bpf_ret_code_LKL_BPF_DROP: lkl_bpf_ret_code = 2;
pub const lkl_bpf_ret_code_LKL_BPF_REDIRECT: lkl_bpf_ret_code = 7;
pub const lkl_bpf_ret_code_LKL_BPF_LWT_REROUTE: lkl_bpf_ret_code = 128;
pub type lkl_bpf_ret_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_sock {
    pub bound_dev_if: __lkl__u32,
    pub family: __lkl__u32,
    pub type_: __lkl__u32,
    pub protocol: __lkl__u32,
    pub mark: __lkl__u32,
    pub priority: __lkl__u32,
    pub src_ip4: __lkl__u32,
    pub src_ip6: [__lkl__u32; 4usize],
    pub src_port: __lkl__u32,
    pub dst_port: __lkl__u32,
    pub dst_ip4: __lkl__u32,
    pub dst_ip6: [__lkl__u32; 4usize],
    pub state: __lkl__u32,
    pub rx_queue_mapping: __lkl__s32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock>(),
        80usize,
        concat!("Size of: ", stringify!(lkl_bpf_sock))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).bound_dev_if as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(bound_dev_if)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).protocol as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).mark as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).priority as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).src_ip4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(src_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).src_ip6 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(src_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).src_port as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).dst_port as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).dst_ip4 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(dst_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).dst_ip6 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(dst_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock>())).rx_queue_mapping as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock),
            "::",
            stringify!(rx_queue_mapping)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_tcp_sock {
    pub snd_cwnd: __lkl__u32,
    pub srtt_us: __lkl__u32,
    pub rtt_min: __lkl__u32,
    pub snd_ssthresh: __lkl__u32,
    pub rcv_nxt: __lkl__u32,
    pub snd_nxt: __lkl__u32,
    pub snd_una: __lkl__u32,
    pub mss_cache: __lkl__u32,
    pub ecn_flags: __lkl__u32,
    pub rate_delivered: __lkl__u32,
    pub rate_interval_us: __lkl__u32,
    pub packets_out: __lkl__u32,
    pub retrans_out: __lkl__u32,
    pub total_retrans: __lkl__u32,
    pub segs_in: __lkl__u32,
    pub data_segs_in: __lkl__u32,
    pub segs_out: __lkl__u32,
    pub data_segs_out: __lkl__u32,
    pub lost_out: __lkl__u32,
    pub sacked_out: __lkl__u32,
    pub bytes_received: __lkl__u64,
    pub bytes_acked: __lkl__u64,
    pub dsack_dups: __lkl__u32,
    pub delivered: __lkl__u32,
    pub delivered_ce: __lkl__u32,
    pub icsk_retransmits: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_tcp_sock() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_tcp_sock>(),
        112usize,
        concat!("Size of: ", stringify!(lkl_bpf_tcp_sock))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_tcp_sock>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_tcp_sock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).snd_cwnd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(snd_cwnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).srtt_us as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(srtt_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).rtt_min as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(rtt_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).snd_ssthresh as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(snd_ssthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).rcv_nxt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(rcv_nxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).snd_nxt as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(snd_nxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).snd_una as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(snd_una)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).mss_cache as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(mss_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).ecn_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(ecn_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).rate_delivered as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(rate_delivered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).rate_interval_us as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(rate_interval_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).packets_out as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(packets_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).retrans_out as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(retrans_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).total_retrans as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(total_retrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).segs_in as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(segs_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).data_segs_in as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(data_segs_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).segs_out as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(segs_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).data_segs_out as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(data_segs_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).lost_out as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(lost_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).sacked_out as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(sacked_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).bytes_received as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(bytes_received)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).bytes_acked as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(bytes_acked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).dsack_dups as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(dsack_dups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).delivered as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(delivered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).delivered_ce as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(delivered_ce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_tcp_sock>())).icsk_retransmits as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_tcp_sock),
            "::",
            stringify!(icsk_retransmits)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_sock_tuple {
    pub __bindgen_anon_1: lkl_bpf_sock_tuple__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_sock_tuple__bindgen_ty_1 {
    pub ipv4: lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1,
    pub ipv6: lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1 {
    pub saddr: __lkl__be32,
    pub daddr: __lkl__be32,
    pub sport: __lkl__be16,
    pub dport: __lkl__be16,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>())).saddr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>())).daddr
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(daddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>())).sport
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>())).dport
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dport)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2 {
    pub saddr: [__lkl__be32; 4usize],
    pub daddr: [__lkl__be32; 4usize],
    pub sport: __lkl__be16,
    pub dport: __lkl__be16,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>())).saddr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>())).daddr
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(daddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>())).sport
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(sport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>())).dport
                as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dport)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock_tuple__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock_tuple__bindgen_ty_1>(),
        36usize,
        concat!("Size of: ", stringify!(lkl_bpf_sock_tuple__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock_tuple__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_tuple__bindgen_ty_1>())).ipv4 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_tuple__bindgen_ty_1>())).ipv6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_tuple__bindgen_ty_1),
            "::",
            stringify!(ipv6)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock_tuple() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock_tuple>(),
        36usize,
        concat!("Size of: ", stringify!(lkl_bpf_sock_tuple))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock_tuple>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sock_tuple))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_xdp_sock {
    pub queue_id: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_xdp_sock() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_xdp_sock>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_bpf_xdp_sock))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_xdp_sock>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_xdp_sock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_xdp_sock>())).queue_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_xdp_sock),
            "::",
            stringify!(queue_id)
        )
    );
}
pub const lkl_xdp_action_LKL_XDP_ABORTED: lkl_xdp_action = 0;
pub const lkl_xdp_action_LKL_XDP_DROP: lkl_xdp_action = 1;
pub const lkl_xdp_action_LKL_XDP_PASS: lkl_xdp_action = 2;
pub const lkl_xdp_action_LKL_XDP_TX: lkl_xdp_action = 3;
pub const lkl_xdp_action_LKL_XDP_REDIRECT: lkl_xdp_action = 4;
pub type lkl_xdp_action = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_xdp_md {
    pub data: __lkl__u32,
    pub data_end: __lkl__u32,
    pub data_meta: __lkl__u32,
    pub ingress_ifindex: __lkl__u32,
    pub rx_queue_index: __lkl__u32,
    pub egress_ifindex: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_xdp_md() {
    assert_eq!(
        ::std::mem::size_of::<lkl_xdp_md>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_xdp_md))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_xdp_md>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_xdp_md))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_xdp_md>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_xdp_md),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_xdp_md>())).data_end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_xdp_md),
            "::",
            stringify!(data_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_xdp_md>())).data_meta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_xdp_md),
            "::",
            stringify!(data_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_xdp_md>())).ingress_ifindex as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_xdp_md),
            "::",
            stringify!(ingress_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_xdp_md>())).rx_queue_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_xdp_md),
            "::",
            stringify!(rx_queue_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_xdp_md>())).egress_ifindex as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_xdp_md),
            "::",
            stringify!(egress_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_devmap_val {
    pub ifindex: __lkl__u32,
    pub bpf_prog: lkl_bpf_devmap_val__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_devmap_val__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub id: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_devmap_val__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_devmap_val__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_bpf_devmap_val__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_devmap_val__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_devmap_val__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_devmap_val__bindgen_ty_1>())).fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_devmap_val__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_devmap_val__bindgen_ty_1>())).id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_devmap_val__bindgen_ty_1),
            "::",
            stringify!(id)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_devmap_val() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_devmap_val>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_devmap_val))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_devmap_val>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_devmap_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_devmap_val>())).ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_devmap_val),
            "::",
            stringify!(ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_devmap_val>())).bpf_prog as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_devmap_val),
            "::",
            stringify!(bpf_prog)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_cpumap_val {
    pub qsize: __lkl__u32,
    pub bpf_prog: lkl_bpf_cpumap_val__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_cpumap_val__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub id: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_cpumap_val__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_cpumap_val__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_bpf_cpumap_val__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_cpumap_val__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_cpumap_val__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_cpumap_val__bindgen_ty_1>())).fd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_cpumap_val__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_cpumap_val__bindgen_ty_1>())).id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_cpumap_val__bindgen_ty_1),
            "::",
            stringify!(id)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_cpumap_val() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_cpumap_val>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_cpumap_val))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_cpumap_val>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_cpumap_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_cpumap_val>())).qsize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_cpumap_val),
            "::",
            stringify!(qsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_cpumap_val>())).bpf_prog as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_cpumap_val),
            "::",
            stringify!(bpf_prog)
        )
    );
}
pub const lkl_sk_action_LKL_SK_DROP: lkl_sk_action = 0;
pub const lkl_sk_action_LKL_SK_PASS: lkl_sk_action = 1;
pub type lkl_sk_action = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_sk_msg_md {
    pub __bindgen_anon_1: lkl_sk_msg_md__bindgen_ty_1,
    pub __bindgen_anon_2: lkl_sk_msg_md__bindgen_ty_2,
    pub family: __lkl__u32,
    pub remote_ip4: __lkl__u32,
    pub local_ip4: __lkl__u32,
    pub remote_ip6: [__lkl__u32; 4usize],
    pub local_ip6: [__lkl__u32; 4usize],
    pub remote_port: __lkl__u32,
    pub local_port: __lkl__u32,
    pub size: __lkl__u32,
    pub __bindgen_anon_3: lkl_sk_msg_md__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_sk_msg_md__bindgen_ty_1 {
    pub data: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_sk_msg_md__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sk_msg_md__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_sk_msg_md__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sk_msg_md__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sk_msg_md__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_sk_msg_md__bindgen_ty_1>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_msg_md__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
impl lkl_sk_msg_md__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_sk_msg_md__bindgen_ty_2 {
    pub data_end: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_sk_msg_md__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sk_msg_md__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_sk_msg_md__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sk_msg_md__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sk_msg_md__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_sk_msg_md__bindgen_ty_2>())).data_end as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_msg_md__bindgen_ty_2),
            "::",
            stringify!(data_end)
        )
    );
}
impl lkl_sk_msg_md__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_sk_msg_md__bindgen_ty_3 {
    pub sk: *mut lkl_bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_sk_msg_md__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sk_msg_md__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_sk_msg_md__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sk_msg_md__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sk_msg_md__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_msg_md__bindgen_ty_3>())).sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_msg_md__bindgen_ty_3),
            "::",
            stringify!(sk)
        )
    );
}
impl lkl_sk_msg_md__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_lkl_sk_msg_md() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sk_msg_md>(),
        80usize,
        concat!("Size of: ", stringify!(lkl_sk_msg_md))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sk_msg_md>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sk_msg_md))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_msg_md>())).family as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_msg_md),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_msg_md>())).remote_ip4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_msg_md),
            "::",
            stringify!(remote_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_msg_md>())).local_ip4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_msg_md),
            "::",
            stringify!(local_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_msg_md>())).remote_ip6 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_msg_md),
            "::",
            stringify!(remote_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_msg_md>())).local_ip6 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_msg_md),
            "::",
            stringify!(local_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_msg_md>())).remote_port as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_msg_md),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_msg_md>())).local_port as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_msg_md),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_msg_md>())).size as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_msg_md),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_sk_reuseport_md {
    pub __bindgen_anon_1: lkl_sk_reuseport_md__bindgen_ty_1,
    pub __bindgen_anon_2: lkl_sk_reuseport_md__bindgen_ty_2,
    pub len: __lkl__u32,
    pub eth_protocol: __lkl__u32,
    pub ip_protocol: __lkl__u32,
    pub bind_inany: __lkl__u32,
    pub hash: __lkl__u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_sk_reuseport_md__bindgen_ty_1 {
    pub data: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_sk_reuseport_md__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sk_reuseport_md__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_sk_reuseport_md__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sk_reuseport_md__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_sk_reuseport_md__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_sk_reuseport_md__bindgen_ty_1>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_reuseport_md__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
impl lkl_sk_reuseport_md__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_sk_reuseport_md__bindgen_ty_2 {
    pub data_end: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_sk_reuseport_md__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sk_reuseport_md__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_sk_reuseport_md__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sk_reuseport_md__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_sk_reuseport_md__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_sk_reuseport_md__bindgen_ty_2>())).data_end as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_reuseport_md__bindgen_ty_2),
            "::",
            stringify!(data_end)
        )
    );
}
impl lkl_sk_reuseport_md__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_lkl_sk_reuseport_md() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sk_reuseport_md>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_sk_reuseport_md))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sk_reuseport_md>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sk_reuseport_md))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_reuseport_md>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_reuseport_md),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_sk_reuseport_md>())).eth_protocol as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_reuseport_md),
            "::",
            stringify!(eth_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_reuseport_md>())).ip_protocol as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_reuseport_md),
            "::",
            stringify!(ip_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_reuseport_md>())).bind_inany as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_reuseport_md),
            "::",
            stringify!(bind_inany)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sk_reuseport_md>())).hash as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sk_reuseport_md),
            "::",
            stringify!(hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_prog_info {
    pub type_: __lkl__u32,
    pub id: __lkl__u32,
    pub tag: [__lkl__u8; 8usize],
    pub jited_prog_len: __lkl__u32,
    pub xlated_prog_len: __lkl__u32,
    pub jited_prog_insns: __lkl__u64,
    pub xlated_prog_insns: __lkl__u64,
    pub load_time: __lkl__u64,
    pub created_by_uid: __lkl__u32,
    pub nr_map_ids: __lkl__u32,
    pub map_ids: __lkl__u64,
    pub name: [::std::os::raw::c_char; 16usize],
    pub ifindex: __lkl__u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub netns_dev: __lkl__u64,
    pub netns_ino: __lkl__u64,
    pub nr_jited_ksyms: __lkl__u32,
    pub nr_jited_func_lens: __lkl__u32,
    pub jited_ksyms: __lkl__u64,
    pub jited_func_lens: __lkl__u64,
    pub btf_id: __lkl__u32,
    pub func_info_rec_size: __lkl__u32,
    pub func_info: __lkl__u64,
    pub nr_func_info: __lkl__u32,
    pub nr_line_info: __lkl__u32,
    pub line_info: __lkl__u64,
    pub jited_line_info: __lkl__u64,
    pub nr_jited_line_info: __lkl__u32,
    pub line_info_rec_size: __lkl__u32,
    pub jited_line_info_rec_size: __lkl__u32,
    pub nr_prog_tags: __lkl__u32,
    pub prog_tags: __lkl__u64,
    pub run_time_ns: __lkl__u64,
    pub run_cnt: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_bpf_prog_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_prog_info>(),
        208usize,
        concat!("Size of: ", stringify!(lkl_bpf_prog_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_prog_info>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_prog_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).jited_prog_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(jited_prog_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).xlated_prog_len as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(xlated_prog_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).jited_prog_insns as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(jited_prog_insns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).xlated_prog_insns as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(xlated_prog_insns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).load_time as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(load_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).created_by_uid as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(created_by_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).nr_map_ids as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(nr_map_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).map_ids as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(map_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).name as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).ifindex as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).netns_dev as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(netns_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).netns_ino as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(netns_ino)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).nr_jited_ksyms as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(nr_jited_ksyms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).nr_jited_func_lens as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(nr_jited_func_lens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).jited_ksyms as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(jited_ksyms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).jited_func_lens as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(jited_func_lens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).btf_id as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(btf_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).func_info_rec_size as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(func_info_rec_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).func_info as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(func_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).nr_func_info as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(nr_func_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).nr_line_info as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(nr_line_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).line_info as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(line_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).jited_line_info as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(jited_line_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).nr_jited_line_info as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(nr_jited_line_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).line_info_rec_size as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(line_info_rec_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_prog_info>())).jited_line_info_rec_size as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(jited_line_info_rec_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).nr_prog_tags as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(nr_prog_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).prog_tags as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(prog_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).run_time_ns as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(run_time_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_prog_info>())).run_cnt as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_prog_info),
            "::",
            stringify!(run_cnt)
        )
    );
}
impl lkl_bpf_prog_info {
    #[inline]
    pub fn gpl_compatible(&self) -> __lkl__u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpl_compatible(&mut self, val: __lkl__u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(gpl_compatible: __lkl__u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gpl_compatible: u32 = unsafe { ::std::mem::transmute(gpl_compatible) };
            gpl_compatible as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_map_info {
    pub type_: __lkl__u32,
    pub id: __lkl__u32,
    pub key_size: __lkl__u32,
    pub value_size: __lkl__u32,
    pub max_entries: __lkl__u32,
    pub map_flags: __lkl__u32,
    pub name: [::std::os::raw::c_char; 16usize],
    pub ifindex: __lkl__u32,
    pub btf_vmlinux_value_type_id: __lkl__u32,
    pub netns_dev: __lkl__u64,
    pub netns_ino: __lkl__u64,
    pub btf_id: __lkl__u32,
    pub btf_key_type_id: __lkl__u32,
    pub btf_value_type_id: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_map_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_map_info>(),
        80usize,
        concat!("Size of: ", stringify!(lkl_bpf_map_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_map_info>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_map_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_map_info>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_map_info>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_map_info>())).key_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(key_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_map_info>())).value_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(value_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_map_info>())).max_entries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(max_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_map_info>())).map_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(map_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_map_info>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_map_info>())).ifindex as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(ifindex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_map_info>())).btf_vmlinux_value_type_id as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(btf_vmlinux_value_type_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_map_info>())).netns_dev as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(netns_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_map_info>())).netns_ino as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(netns_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_map_info>())).btf_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(btf_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_map_info>())).btf_key_type_id as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(btf_key_type_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_map_info>())).btf_value_type_id as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_map_info),
            "::",
            stringify!(btf_value_type_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_btf_info {
    pub btf: __lkl__u64,
    pub btf_size: __lkl__u32,
    pub id: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_btf_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_btf_info>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_btf_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_btf_info>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_btf_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_btf_info>())).btf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_btf_info),
            "::",
            stringify!(btf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_btf_info>())).btf_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_btf_info),
            "::",
            stringify!(btf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_btf_info>())).id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_btf_info),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_link_info {
    pub type_: __lkl__u32,
    pub id: __lkl__u32,
    pub prog_id: __lkl__u32,
    pub __bindgen_anon_1: lkl_bpf_link_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_link_info__bindgen_ty_1 {
    pub raw_tracepoint: lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_1,
    pub tracing: lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_2,
    pub cgroup: lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_3,
    pub iter: lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4,
    pub netns: lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_5,
    pub xdp: lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_1 {
    pub tp_name: __lkl__u64,
    pub tp_name_len: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_1>())).tp_name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(tp_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_1>())).tp_name_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(tp_name_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_2 {
    pub attach_type: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_2>())).attach_type
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(attach_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_3 {
    pub cgroup_id: __lkl__u64,
    pub attach_type: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_3>())).cgroup_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(cgroup_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_3>())).attach_type
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(attach_type)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4 {
    pub target_name: __lkl__u64,
    pub target_name_len: __lkl__u32,
    pub __bindgen_anon_1: lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub map: lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub map_id: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<
            lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
            >()))
            .map_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(map_id)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>()))
                .map as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4>())).target_name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(target_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4>()))
                .target_name_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(target_name_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_5 {
    pub netns_ino: __lkl__u32,
    pub attach_type: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_5>())).netns_ino
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(netns_ino)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_5>())).attach_type
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(attach_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_6 {
    pub ifindex: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_6>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_6>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_6>())).ifindex
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(ifindex)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_link_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_link_info__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_link_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_link_info__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_link_info__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1>())).raw_tracepoint as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1),
            "::",
            stringify!(raw_tracepoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1>())).tracing as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1),
            "::",
            stringify!(tracing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1>())).cgroup as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1),
            "::",
            stringify!(cgroup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1>())).iter as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1),
            "::",
            stringify!(iter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1>())).netns as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1),
            "::",
            stringify!(netns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_link_info__bindgen_ty_1>())).xdp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info__bindgen_ty_1),
            "::",
            stringify!(xdp)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_link_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_link_info>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_bpf_link_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_link_info>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_link_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_link_info>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_link_info>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_link_info>())).prog_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_link_info),
            "::",
            stringify!(prog_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_sock_addr {
    pub user_family: __lkl__u32,
    pub user_ip4: __lkl__u32,
    pub user_ip6: [__lkl__u32; 4usize],
    pub user_port: __lkl__u32,
    pub family: __lkl__u32,
    pub type_: __lkl__u32,
    pub protocol: __lkl__u32,
    pub msg_src_ip4: __lkl__u32,
    pub msg_src_ip6: [__lkl__u32; 4usize],
    pub __bindgen_anon_1: lkl_bpf_sock_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_sock_addr__bindgen_ty_1 {
    pub sk: *mut lkl_bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock_addr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_sock_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock_addr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sock_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_addr__bindgen_ty_1>())).sk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_addr__bindgen_ty_1),
            "::",
            stringify!(sk)
        )
    );
}
impl lkl_bpf_sock_addr__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock_addr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock_addr>(),
        72usize,
        concat!("Size of: ", stringify!(lkl_bpf_sock_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sock_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_addr>())).user_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_addr),
            "::",
            stringify!(user_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_addr>())).user_ip4 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_addr),
            "::",
            stringify!(user_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_addr>())).user_ip6 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_addr),
            "::",
            stringify!(user_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_addr>())).user_port as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_addr),
            "::",
            stringify!(user_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_addr>())).family as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_addr),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_addr>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_addr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_addr>())).protocol as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_addr),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_addr>())).msg_src_ip4 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_addr),
            "::",
            stringify!(msg_src_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_addr>())).msg_src_ip6 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_addr),
            "::",
            stringify!(msg_src_ip6)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_sock_ops {
    pub op: __lkl__u32,
    pub __bindgen_anon_1: lkl_bpf_sock_ops__bindgen_ty_1,
    pub family: __lkl__u32,
    pub remote_ip4: __lkl__u32,
    pub local_ip4: __lkl__u32,
    pub remote_ip6: [__lkl__u32; 4usize],
    pub local_ip6: [__lkl__u32; 4usize],
    pub remote_port: __lkl__u32,
    pub local_port: __lkl__u32,
    pub is_fullsock: __lkl__u32,
    pub snd_cwnd: __lkl__u32,
    pub srtt_us: __lkl__u32,
    pub bpf_sock_ops_cb_flags: __lkl__u32,
    pub state: __lkl__u32,
    pub rtt_min: __lkl__u32,
    pub snd_ssthresh: __lkl__u32,
    pub rcv_nxt: __lkl__u32,
    pub snd_nxt: __lkl__u32,
    pub snd_una: __lkl__u32,
    pub mss_cache: __lkl__u32,
    pub ecn_flags: __lkl__u32,
    pub rate_delivered: __lkl__u32,
    pub rate_interval_us: __lkl__u32,
    pub packets_out: __lkl__u32,
    pub retrans_out: __lkl__u32,
    pub total_retrans: __lkl__u32,
    pub segs_in: __lkl__u32,
    pub data_segs_in: __lkl__u32,
    pub segs_out: __lkl__u32,
    pub data_segs_out: __lkl__u32,
    pub lost_out: __lkl__u32,
    pub sacked_out: __lkl__u32,
    pub sk_txhash: __lkl__u32,
    pub bytes_received: __lkl__u64,
    pub bytes_acked: __lkl__u64,
    pub __bindgen_anon_2: lkl_bpf_sock_ops__bindgen_ty_2,
    pub __bindgen_anon_3: lkl_bpf_sock_ops__bindgen_ty_3,
    pub __bindgen_anon_4: lkl_bpf_sock_ops__bindgen_ty_4,
    pub skb_len: __lkl__u32,
    pub skb_tcp_flags: __lkl__u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_sock_ops__bindgen_ty_1 {
    pub args: [__lkl__u32; 4usize],
    pub reply: __lkl__u32,
    pub replylong: [__lkl__u32; 4usize],
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock_ops__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock_ops__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_sock_ops__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock_ops__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sock_ops__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_ops__bindgen_ty_1>())).args as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops__bindgen_ty_1),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_ops__bindgen_ty_1>())).reply as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops__bindgen_ty_1),
            "::",
            stringify!(reply)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_ops__bindgen_ty_1>())).replylong as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops__bindgen_ty_1),
            "::",
            stringify!(replylong)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_sock_ops__bindgen_ty_2 {
    pub sk: *mut lkl_bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock_ops__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock_ops__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_sock_ops__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock_ops__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sock_ops__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_ops__bindgen_ty_2>())).sk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops__bindgen_ty_2),
            "::",
            stringify!(sk)
        )
    );
}
impl lkl_bpf_sock_ops__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_sock_ops__bindgen_ty_3 {
    pub skb_data: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock_ops__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock_ops__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_sock_ops__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock_ops__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sock_ops__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_ops__bindgen_ty_3>())).skb_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops__bindgen_ty_3),
            "::",
            stringify!(skb_data)
        )
    );
}
impl lkl_bpf_sock_ops__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_sock_ops__bindgen_ty_4 {
    pub skb_data_end: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock_ops__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock_ops__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_sock_ops__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock_ops__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sock_ops__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_ops__bindgen_ty_4>())).skb_data_end as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops__bindgen_ty_4),
            "::",
            stringify!(skb_data_end)
        )
    );
}
impl lkl_bpf_sock_ops__bindgen_ty_4 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_lkl_bpf_sock_ops() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sock_ops>(),
        216usize,
        concat!("Size of: ", stringify!(lkl_bpf_sock_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sock_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sock_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).family as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).remote_ip4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(remote_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).local_ip4 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(local_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).remote_ip6 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(remote_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).local_ip6 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(local_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).remote_port as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).local_port as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(local_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).is_fullsock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(is_fullsock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).snd_cwnd as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(snd_cwnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).srtt_us as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(srtt_us)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).bpf_sock_ops_cb_flags as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(bpf_sock_ops_cb_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).state as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).rtt_min as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(rtt_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).snd_ssthresh as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(snd_ssthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).rcv_nxt as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(rcv_nxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).snd_nxt as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(snd_nxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).snd_una as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(snd_una)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).mss_cache as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(mss_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).ecn_flags as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(ecn_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).rate_delivered as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(rate_delivered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).rate_interval_us as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(rate_interval_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).packets_out as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(packets_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).retrans_out as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(retrans_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).total_retrans as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(total_retrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).segs_in as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(segs_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).data_segs_in as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(data_segs_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).segs_out as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(segs_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).data_segs_out as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(data_segs_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).lost_out as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(lost_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).sacked_out as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(sacked_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).sk_txhash as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(sk_txhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).bytes_received as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(bytes_received)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).bytes_acked as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(bytes_acked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).skb_len as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(skb_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sock_ops>())).skb_tcp_flags as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sock_ops),
            "::",
            stringify!(skb_tcp_flags)
        )
    );
}
pub const LKL_BPF_SOCK_OPS_RTO_CB_FLAG: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_SOCK_OPS_RETRANS_CB_FLAG: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_SOCK_OPS_STATE_CB_FLAG: ::std::os::raw::c_uint = 4;
pub const LKL_BPF_SOCK_OPS_RTT_CB_FLAG: ::std::os::raw::c_uint = 8;
pub const LKL_BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG: ::std::os::raw::c_uint = 16;
pub const LKL_BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG: ::std::os::raw::c_uint = 32;
pub const LKL_BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG: ::std::os::raw::c_uint = 64;
pub const LKL_BPF_SOCK_OPS_ALL_CB_FLAGS: ::std::os::raw::c_uint = 127;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const LKL_BPF_SOCK_OPS_VOID: ::std::os::raw::c_uint = 0;
pub const LKL_BPF_SOCK_OPS_TIMEOUT_INIT: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_SOCK_OPS_RWND_INIT: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_SOCK_OPS_TCP_CONNECT_CB: ::std::os::raw::c_uint = 3;
pub const LKL_BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB: ::std::os::raw::c_uint = 4;
pub const LKL_BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB: ::std::os::raw::c_uint = 5;
pub const LKL_BPF_SOCK_OPS_NEEDS_ECN: ::std::os::raw::c_uint = 6;
pub const LKL_BPF_SOCK_OPS_BASE_RTT: ::std::os::raw::c_uint = 7;
pub const LKL_BPF_SOCK_OPS_RTO_CB: ::std::os::raw::c_uint = 8;
pub const LKL_BPF_SOCK_OPS_RETRANS_CB: ::std::os::raw::c_uint = 9;
pub const LKL_BPF_SOCK_OPS_STATE_CB: ::std::os::raw::c_uint = 10;
pub const LKL_BPF_SOCK_OPS_TCP_LISTEN_CB: ::std::os::raw::c_uint = 11;
pub const LKL_BPF_SOCK_OPS_RTT_CB: ::std::os::raw::c_uint = 12;
pub const LKL_BPF_SOCK_OPS_PARSE_HDR_OPT_CB: ::std::os::raw::c_uint = 13;
pub const LKL_BPF_SOCK_OPS_HDR_OPT_LEN_CB: ::std::os::raw::c_uint = 14;
pub const LKL_BPF_SOCK_OPS_WRITE_HDR_OPT_CB: ::std::os::raw::c_uint = 15;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const LKL_BPF_TCP_ESTABLISHED: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_TCP_SYN_SENT: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_TCP_SYN_RECV: ::std::os::raw::c_uint = 3;
pub const LKL_BPF_TCP_FIN_WAIT1: ::std::os::raw::c_uint = 4;
pub const LKL_BPF_TCP_FIN_WAIT2: ::std::os::raw::c_uint = 5;
pub const LKL_BPF_TCP_TIME_WAIT: ::std::os::raw::c_uint = 6;
pub const LKL_BPF_TCP_CLOSE: ::std::os::raw::c_uint = 7;
pub const LKL_BPF_TCP_CLOSE_WAIT: ::std::os::raw::c_uint = 8;
pub const LKL_BPF_TCP_LAST_ACK: ::std::os::raw::c_uint = 9;
pub const LKL_BPF_TCP_LISTEN: ::std::os::raw::c_uint = 10;
pub const LKL_BPF_TCP_CLOSING: ::std::os::raw::c_uint = 11;
pub const LKL_BPF_TCP_NEW_SYN_RECV: ::std::os::raw::c_uint = 12;
pub const LKL_BPF_TCP_MAX_STATES: ::std::os::raw::c_uint = 13;
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const LKL_TCP_BPF_IW: ::std::os::raw::c_uint = 1001;
pub const LKL_TCP_BPF_SNDCWND_CLAMP: ::std::os::raw::c_uint = 1002;
pub const LKL_TCP_BPF_DELACK_MAX: ::std::os::raw::c_uint = 1003;
pub const LKL_TCP_BPF_RTO_MIN: ::std::os::raw::c_uint = 1004;
pub const LKL_TCP_BPF_SYN: ::std::os::raw::c_uint = 1005;
pub const LKL_TCP_BPF_SYN_IP: ::std::os::raw::c_uint = 1006;
pub const LKL_TCP_BPF_SYN_MAC: ::std::os::raw::c_uint = 1007;
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
pub const LKL_BPF_LOAD_HDR_OPT_TCP_SYN: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const LKL_BPF_WRITE_HDR_TCP_CURRENT_MSS: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_WRITE_HDR_TCP_SYNACK_COOKIE: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_perf_event_value {
    pub counter: __lkl__u64,
    pub enabled: __lkl__u64,
    pub running: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_bpf_perf_event_value() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_perf_event_value>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_bpf_perf_event_value))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_perf_event_value>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_perf_event_value))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_perf_event_value>())).counter as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_perf_event_value),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_perf_event_value>())).enabled as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_perf_event_value),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_perf_event_value>())).running as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_perf_event_value),
            "::",
            stringify!(running)
        )
    );
}
pub const LKL_BPF_DEVCG_ACC_MKNOD: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_DEVCG_ACC_READ: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_DEVCG_ACC_WRITE: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
pub const LKL_BPF_DEVCG_DEV_BLOCK: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_DEVCG_DEV_CHAR: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_cgroup_dev_ctx {
    pub access_type: __lkl__u32,
    pub major: __lkl__u32,
    pub minor: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_cgroup_dev_ctx() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_cgroup_dev_ctx>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_bpf_cgroup_dev_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_cgroup_dev_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_cgroup_dev_ctx))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_cgroup_dev_ctx>())).access_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_cgroup_dev_ctx),
            "::",
            stringify!(access_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_cgroup_dev_ctx>())).major as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_cgroup_dev_ctx),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_cgroup_dev_ctx>())).minor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_cgroup_dev_ctx),
            "::",
            stringify!(minor)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_bpf_raw_tracepoint_args {
    pub args: __IncompleteArrayField<__lkl__u64>,
}
#[test]
fn bindgen_test_layout_lkl_bpf_raw_tracepoint_args() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_raw_tracepoint_args>(),
        0usize,
        concat!("Size of: ", stringify!(lkl_bpf_raw_tracepoint_args))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_raw_tracepoint_args>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_raw_tracepoint_args))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_raw_tracepoint_args>())).args as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_raw_tracepoint_args),
            "::",
            stringify!(args)
        )
    );
}
pub const LKL_BPF_FIB_LOOKUP_DIRECT: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_FIB_LOOKUP_OUTPUT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub const LKL_BPF_FIB_LKUP_RET_SUCCESS: ::std::os::raw::c_uint = 0;
pub const LKL_BPF_FIB_LKUP_RET_BLACKHOLE: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_FIB_LKUP_RET_UNREACHABLE: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_FIB_LKUP_RET_PROHIBIT: ::std::os::raw::c_uint = 3;
pub const LKL_BPF_FIB_LKUP_RET_NOT_FWDED: ::std::os::raw::c_uint = 4;
pub const LKL_BPF_FIB_LKUP_RET_FWD_DISABLED: ::std::os::raw::c_uint = 5;
pub const LKL_BPF_FIB_LKUP_RET_UNSUPP_LWT: ::std::os::raw::c_uint = 6;
pub const LKL_BPF_FIB_LKUP_RET_NO_NEIGH: ::std::os::raw::c_uint = 7;
pub const LKL_BPF_FIB_LKUP_RET_FRAG_NEEDED: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_fib_lookup {
    pub family: __lkl__u8,
    pub l4_protocol: __lkl__u8,
    pub sport: __lkl__be16,
    pub dport: __lkl__be16,
    pub tot_len: __lkl__u16,
    pub ifindex: __lkl__u32,
    pub __bindgen_anon_1: lkl_bpf_fib_lookup__bindgen_ty_1,
    pub __bindgen_anon_2: lkl_bpf_fib_lookup__bindgen_ty_2,
    pub __bindgen_anon_3: lkl_bpf_fib_lookup__bindgen_ty_3,
    pub h_vlan_proto: __lkl__be16,
    pub h_vlan_TCI: __lkl__be16,
    pub smac: [__lkl__u8; 6usize],
    pub dmac: [__lkl__u8; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_fib_lookup__bindgen_ty_1 {
    pub tos: __lkl__u8,
    pub flowinfo: __lkl__be32,
    pub rt_metric: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_fib_lookup__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_fib_lookup__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_bpf_fib_lookup__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_fib_lookup__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_fib_lookup__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_fib_lookup__bindgen_ty_1>())).tos as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup__bindgen_ty_1),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_fib_lookup__bindgen_ty_1>())).flowinfo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup__bindgen_ty_1),
            "::",
            stringify!(flowinfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_fib_lookup__bindgen_ty_1>())).rt_metric as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup__bindgen_ty_1),
            "::",
            stringify!(rt_metric)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_fib_lookup__bindgen_ty_2 {
    pub ipv4_src: __lkl__be32,
    pub ipv6_src: [__lkl__u32; 4usize],
}
#[test]
fn bindgen_test_layout_lkl_bpf_fib_lookup__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_fib_lookup__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_fib_lookup__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_fib_lookup__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_fib_lookup__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_fib_lookup__bindgen_ty_2>())).ipv4_src as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup__bindgen_ty_2),
            "::",
            stringify!(ipv4_src)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_fib_lookup__bindgen_ty_2>())).ipv6_src as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup__bindgen_ty_2),
            "::",
            stringify!(ipv6_src)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_fib_lookup__bindgen_ty_3 {
    pub ipv4_dst: __lkl__be32,
    pub ipv6_dst: [__lkl__u32; 4usize],
}
#[test]
fn bindgen_test_layout_lkl_bpf_fib_lookup__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_fib_lookup__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_fib_lookup__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_fib_lookup__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_fib_lookup__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_fib_lookup__bindgen_ty_3>())).ipv4_dst as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup__bindgen_ty_3),
            "::",
            stringify!(ipv4_dst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_fib_lookup__bindgen_ty_3>())).ipv6_dst as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup__bindgen_ty_3),
            "::",
            stringify!(ipv6_dst)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_fib_lookup() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_fib_lookup>(),
        64usize,
        concat!("Size of: ", stringify!(lkl_bpf_fib_lookup))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_fib_lookup>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_fib_lookup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_fib_lookup>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_fib_lookup>())).l4_protocol as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup),
            "::",
            stringify!(l4_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_fib_lookup>())).sport as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup),
            "::",
            stringify!(sport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_fib_lookup>())).dport as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup),
            "::",
            stringify!(dport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_fib_lookup>())).tot_len as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup),
            "::",
            stringify!(tot_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_fib_lookup>())).ifindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup),
            "::",
            stringify!(ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_fib_lookup>())).h_vlan_proto as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup),
            "::",
            stringify!(h_vlan_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_fib_lookup>())).h_vlan_TCI as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup),
            "::",
            stringify!(h_vlan_TCI)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_fib_lookup>())).smac as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup),
            "::",
            stringify!(smac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_fib_lookup>())).dmac as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_fib_lookup),
            "::",
            stringify!(dmac)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_redir_neigh {
    pub nh_family: __lkl__u32,
    pub __bindgen_anon_1: lkl_bpf_redir_neigh__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_redir_neigh__bindgen_ty_1 {
    pub ipv4_nh: __lkl__be32,
    pub ipv6_nh: [__lkl__u32; 4usize],
}
#[test]
fn bindgen_test_layout_lkl_bpf_redir_neigh__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_redir_neigh__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_redir_neigh__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_redir_neigh__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_redir_neigh__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_redir_neigh__bindgen_ty_1>())).ipv4_nh as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_redir_neigh__bindgen_ty_1),
            "::",
            stringify!(ipv4_nh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_redir_neigh__bindgen_ty_1>())).ipv6_nh as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_redir_neigh__bindgen_ty_1),
            "::",
            stringify!(ipv6_nh)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_redir_neigh() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_redir_neigh>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_bpf_redir_neigh))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_redir_neigh>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_redir_neigh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_redir_neigh>())).nh_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_redir_neigh),
            "::",
            stringify!(nh_family)
        )
    );
}
pub const lkl_bpf_task_fd_type_LKL_BPF_FD_TYPE_RAW_TRACEPOINT: lkl_bpf_task_fd_type = 0;
pub const lkl_bpf_task_fd_type_LKL_BPF_FD_TYPE_TRACEPOINT: lkl_bpf_task_fd_type = 1;
pub const lkl_bpf_task_fd_type_LKL_BPF_FD_TYPE_KPROBE: lkl_bpf_task_fd_type = 2;
pub const lkl_bpf_task_fd_type_LKL_BPF_FD_TYPE_KRETPROBE: lkl_bpf_task_fd_type = 3;
pub const lkl_bpf_task_fd_type_LKL_BPF_FD_TYPE_UPROBE: lkl_bpf_task_fd_type = 4;
pub const lkl_bpf_task_fd_type_LKL_BPF_FD_TYPE_URETPROBE: lkl_bpf_task_fd_type = 5;
pub type lkl_bpf_task_fd_type = ::std::os::raw::c_uint;
pub const LKL_BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG: ::std::os::raw::c_uint = 1;
pub const LKL_BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL: ::std::os::raw::c_uint = 2;
pub const LKL_BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_flow_keys {
    pub nhoff: __lkl__u16,
    pub thoff: __lkl__u16,
    pub addr_proto: __lkl__u16,
    pub is_frag: __lkl__u8,
    pub is_first_frag: __lkl__u8,
    pub is_encap: __lkl__u8,
    pub ip_proto: __lkl__u8,
    pub n_proto: __lkl__be16,
    pub sport: __lkl__be16,
    pub dport: __lkl__be16,
    pub __bindgen_anon_1: lkl_bpf_flow_keys__bindgen_ty_1,
    pub flags: __lkl__u32,
    pub flow_label: __lkl__be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_flow_keys__bindgen_ty_1 {
    pub __bindgen_anon_1: lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1 {
    pub ipv4_src: __lkl__be32,
    pub ipv4_dst: __lkl__be32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1>())).ipv4_src
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ipv4_src)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1>())).ipv4_dst
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ipv4_dst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2 {
    pub ipv6_src: [__lkl__u32; 4usize],
    pub ipv6_dst: [__lkl__u32; 4usize],
}
#[test]
fn bindgen_test_layout_lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2>())).ipv6_src
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ipv6_src)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2>())).ipv6_dst
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ipv6_dst)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_flow_keys__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_flow_keys__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_bpf_flow_keys__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_flow_keys__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_flow_keys__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_lkl_bpf_flow_keys() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_flow_keys>(),
        56usize,
        concat!("Size of: ", stringify!(lkl_bpf_flow_keys))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_flow_keys>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_flow_keys))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).nhoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(nhoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).thoff as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(thoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).addr_proto as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(addr_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).is_frag as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(is_frag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).is_first_frag as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(is_first_frag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).is_encap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(is_encap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).ip_proto as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(ip_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).n_proto as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(n_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).sport as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(sport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).dport as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(dport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_flow_keys>())).flow_label as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_flow_keys),
            "::",
            stringify!(flow_label)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_func_info {
    pub insn_off: __lkl__u32,
    pub type_id: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_func_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_func_info>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_func_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_func_info>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_func_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_func_info>())).insn_off as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_func_info),
            "::",
            stringify!(insn_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_func_info>())).type_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_func_info),
            "::",
            stringify!(type_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_line_info {
    pub insn_off: __lkl__u32,
    pub file_name_off: __lkl__u32,
    pub line_off: __lkl__u32,
    pub line_col: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_line_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_line_info>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_bpf_line_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_line_info>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_line_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_line_info>())).insn_off as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_line_info),
            "::",
            stringify!(insn_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_line_info>())).file_name_off as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_line_info),
            "::",
            stringify!(file_name_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_line_info>())).line_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_line_info),
            "::",
            stringify!(line_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_line_info>())).line_col as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_line_info),
            "::",
            stringify!(line_col)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_spin_lock {
    pub val: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_spin_lock() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_spin_lock>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_bpf_spin_lock))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_spin_lock>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_spin_lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_spin_lock>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_spin_lock),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_sysctl {
    pub write: __lkl__u32,
    pub file_pos: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sysctl() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sysctl>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_sysctl))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sysctl>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sysctl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sysctl>())).write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sysctl),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sysctl>())).file_pos as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sysctl),
            "::",
            stringify!(file_pos)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_sockopt {
    pub __bindgen_anon_1: lkl_bpf_sockopt__bindgen_ty_1,
    pub __bindgen_anon_2: lkl_bpf_sockopt__bindgen_ty_2,
    pub __bindgen_anon_3: lkl_bpf_sockopt__bindgen_ty_3,
    pub level: __lkl__s32,
    pub optname: __lkl__s32,
    pub optlen: __lkl__s32,
    pub retval: __lkl__s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_sockopt__bindgen_ty_1 {
    pub sk: *mut lkl_bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sockopt__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sockopt__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_sockopt__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sockopt__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sockopt__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sockopt__bindgen_ty_1>())).sk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sockopt__bindgen_ty_1),
            "::",
            stringify!(sk)
        )
    );
}
impl lkl_bpf_sockopt__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_sockopt__bindgen_ty_2 {
    pub optval: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sockopt__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sockopt__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_sockopt__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sockopt__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sockopt__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sockopt__bindgen_ty_2>())).optval as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sockopt__bindgen_ty_2),
            "::",
            stringify!(optval)
        )
    );
}
impl lkl_bpf_sockopt__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_sockopt__bindgen_ty_3 {
    pub optval_end: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sockopt__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sockopt__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_sockopt__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sockopt__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sockopt__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sockopt__bindgen_ty_3>())).optval_end as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sockopt__bindgen_ty_3),
            "::",
            stringify!(optval_end)
        )
    );
}
impl lkl_bpf_sockopt__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_lkl_bpf_sockopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sockopt>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_bpf_sockopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sockopt>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sockopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sockopt>())).level as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sockopt),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sockopt>())).optname as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sockopt),
            "::",
            stringify!(optname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sockopt>())).optlen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sockopt),
            "::",
            stringify!(optlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sockopt>())).retval as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sockopt),
            "::",
            stringify!(retval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_bpf_pidns_info {
    pub pid: __lkl__u32,
    pub tgid: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_bpf_pidns_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_pidns_info>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_pidns_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_pidns_info>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_bpf_pidns_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_pidns_info>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_pidns_info),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_pidns_info>())).tgid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_pidns_info),
            "::",
            stringify!(tgid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_bpf_sk_lookup {
    pub __bindgen_anon_1: lkl_bpf_sk_lookup__bindgen_ty_1,
    pub family: __lkl__u32,
    pub protocol: __lkl__u32,
    pub remote_ip4: __lkl__u32,
    pub remote_ip6: [__lkl__u32; 4usize],
    pub remote_port: __lkl__u32,
    pub local_ip4: __lkl__u32,
    pub local_ip6: [__lkl__u32; 4usize],
    pub local_port: __lkl__u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_bpf_sk_lookup__bindgen_ty_1 {
    pub sk: *mut lkl_bpf_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_bpf_sk_lookup__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sk_lookup__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_bpf_sk_lookup__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sk_lookup__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sk_lookup__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_bpf_sk_lookup__bindgen_ty_1>())).sk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sk_lookup__bindgen_ty_1),
            "::",
            stringify!(sk)
        )
    );
}
impl lkl_bpf_sk_lookup__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_lkl_bpf_sk_lookup() {
    assert_eq!(
        ::std::mem::size_of::<lkl_bpf_sk_lookup>(),
        64usize,
        concat!("Size of: ", stringify!(lkl_bpf_sk_lookup))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_bpf_sk_lookup>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_bpf_sk_lookup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sk_lookup>())).family as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sk_lookup),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sk_lookup>())).protocol as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sk_lookup),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sk_lookup>())).remote_ip4 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sk_lookup),
            "::",
            stringify!(remote_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sk_lookup>())).remote_ip6 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sk_lookup),
            "::",
            stringify!(remote_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sk_lookup>())).remote_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sk_lookup),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sk_lookup>())).local_ip4 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sk_lookup),
            "::",
            stringify!(local_ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sk_lookup>())).local_ip6 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sk_lookup),
            "::",
            stringify!(local_ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_bpf_sk_lookup>())).local_port as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_bpf_sk_lookup),
            "::",
            stringify!(local_port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_btf_ptr {
    pub ptr: *mut ::std::os::raw::c_void,
    pub type_id: __lkl__u32,
    pub flags: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_btf_ptr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_btf_ptr>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_btf_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_btf_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_btf_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_btf_ptr>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_btf_ptr),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_btf_ptr>())).type_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_btf_ptr),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_btf_ptr>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_btf_ptr),
            "::",
            stringify!(flags)
        )
    );
}
pub const LKL_BTF_F_COMPACT: ::std::os::raw::c_uint = 1;
pub const LKL_BTF_F_NONAME: ::std::os::raw::c_uint = 2;
pub const LKL_BTF_F_PTR_RAW: ::std::os::raw::c_uint = 4;
pub const LKL_BTF_F_ZERO: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipc_perm {
    pub key: __lkl__kernel_key_t,
    pub uid: __lkl__kernel_uid_t,
    pub gid: __lkl__kernel_gid_t,
    pub cuid: __lkl__kernel_uid_t,
    pub cgid: __lkl__kernel_gid_t,
    pub mode: __lkl__kernel_mode_t,
    pub seq: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ipc_perm() {
    assert_eq!(
        ::std::mem::size_of::<ipc_perm>(),
        28usize,
        concat!("Size of: ", stringify!(ipc_perm))
    );
    assert_eq!(
        ::std::mem::align_of::<ipc_perm>(),
        4usize,
        concat!("Alignment of ", stringify!(ipc_perm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).cuid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(cuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).cgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(cgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).seq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(seq)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_ipc64_perm {
    pub key: __lkl__kernel_key_t,
    pub uid: __lkl__kernel_uid32_t,
    pub gid: __lkl__kernel_gid32_t,
    pub cuid: __lkl__kernel_uid32_t,
    pub cgid: __lkl__kernel_gid32_t,
    pub mode: __lkl__kernel_mode_t,
    pub __pad1: __IncompleteArrayField<::std::os::raw::c_uchar>,
    pub seq: ::std::os::raw::c_ushort,
    pub __pad2: ::std::os::raw::c_ushort,
    pub __unused1: __lkl__kernel_ulong_t,
    pub __unused2: __lkl__kernel_ulong_t,
}
#[test]
fn bindgen_test_layout_lkl_ipc64_perm() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ipc64_perm>(),
        48usize,
        concat!("Size of: ", stringify!(lkl_ipc64_perm))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ipc64_perm>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_ipc64_perm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc64_perm>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc64_perm),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc64_perm>())).uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc64_perm),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc64_perm>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc64_perm),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc64_perm>())).cuid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc64_perm),
            "::",
            stringify!(cuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc64_perm>())).cgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc64_perm),
            "::",
            stringify!(cgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc64_perm>())).mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc64_perm),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc64_perm>())).__pad1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc64_perm),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc64_perm>())).seq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc64_perm),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc64_perm>())).__pad2 as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc64_perm),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc64_perm>())).__unused1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc64_perm),
            "::",
            stringify!(__unused1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc64_perm>())).__unused2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc64_perm),
            "::",
            stringify!(__unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ipc_kludge {
    pub msgp: *mut lkl_msgbuf,
    pub msgtyp: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_lkl_ipc_kludge() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ipc_kludge>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_ipc_kludge))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ipc_kludge>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_ipc_kludge))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc_kludge>())).msgp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc_kludge),
            "::",
            stringify!(msgp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipc_kludge>())).msgtyp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipc_kludge),
            "::",
            stringify!(msgtyp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_msqid_ds {
    pub msg_perm: ipc_perm,
    pub msg_first: *mut msg,
    pub msg_last: *mut msg,
    pub msg_stime: __lkl__kernel_old_time_t,
    pub msg_rtime: __lkl__kernel_old_time_t,
    pub msg_ctime: __lkl__kernel_old_time_t,
    pub msg_lcbytes: ::std::os::raw::c_ulong,
    pub msg_lqbytes: ::std::os::raw::c_ulong,
    pub msg_cbytes: ::std::os::raw::c_ushort,
    pub msg_qnum: ::std::os::raw::c_ushort,
    pub msg_qbytes: ::std::os::raw::c_ushort,
    pub msg_lspid: __lkl__kernel_ipc_pid_t,
    pub msg_lrpid: __lkl__kernel_ipc_pid_t,
}
#[test]
fn bindgen_test_layout_lkl_msqid_ds() {
    assert_eq!(
        ::std::mem::size_of::<lkl_msqid_ds>(),
        104usize,
        concat!("Size of: ", stringify!(lkl_msqid_ds))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_msqid_ds>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_msqid_ds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_first as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_last as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_stime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_rtime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_rtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_ctime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_lcbytes as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_lcbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_lqbytes as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_lqbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_cbytes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_cbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_qnum as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_qnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_qbytes as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_qbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_lspid as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_lspid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid_ds>())).msg_lrpid as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid_ds),
            "::",
            stringify!(msg_lrpid)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_msqid64_ds {
    pub msg_perm: lkl_ipc64_perm,
    pub msg_stime: ::std::os::raw::c_long,
    pub msg_rtime: ::std::os::raw::c_long,
    pub msg_ctime: ::std::os::raw::c_long,
    pub msg_cbytes: ::std::os::raw::c_ulong,
    pub msg_qnum: ::std::os::raw::c_ulong,
    pub msg_qbytes: ::std::os::raw::c_ulong,
    pub msg_lspid: __lkl__kernel_pid_t,
    pub msg_lrpid: __lkl__kernel_pid_t,
    pub __unused4: ::std::os::raw::c_ulong,
    pub __unused5: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_lkl_msqid64_ds() {
    assert_eq!(
        ::std::mem::size_of::<lkl_msqid64_ds>(),
        120usize,
        concat!("Size of: ", stringify!(lkl_msqid64_ds))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_msqid64_ds>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_msqid64_ds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid64_ds>())).msg_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid64_ds),
            "::",
            stringify!(msg_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid64_ds>())).msg_stime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid64_ds),
            "::",
            stringify!(msg_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid64_ds>())).msg_rtime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid64_ds),
            "::",
            stringify!(msg_rtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid64_ds>())).msg_ctime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid64_ds),
            "::",
            stringify!(msg_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid64_ds>())).msg_cbytes as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid64_ds),
            "::",
            stringify!(msg_cbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid64_ds>())).msg_qnum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid64_ds),
            "::",
            stringify!(msg_qnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid64_ds>())).msg_qbytes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid64_ds),
            "::",
            stringify!(msg_qbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid64_ds>())).msg_lspid as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid64_ds),
            "::",
            stringify!(msg_lspid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid64_ds>())).msg_lrpid as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid64_ds),
            "::",
            stringify!(msg_lrpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid64_ds>())).__unused4 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid64_ds),
            "::",
            stringify!(__unused4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msqid64_ds>())).__unused5 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msqid64_ds),
            "::",
            stringify!(__unused5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_msgbuf {
    pub mtype: __lkl__kernel_long_t,
    pub mtext: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_lkl_msgbuf() {
    assert_eq!(
        ::std::mem::size_of::<lkl_msgbuf>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_msgbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_msgbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_msgbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msgbuf>())).mtype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msgbuf),
            "::",
            stringify!(mtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msgbuf>())).mtext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msgbuf),
            "::",
            stringify!(mtext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_msginfo {
    pub msgpool: ::std::os::raw::c_int,
    pub msgmap: ::std::os::raw::c_int,
    pub msgmax: ::std::os::raw::c_int,
    pub msgmnb: ::std::os::raw::c_int,
    pub msgmni: ::std::os::raw::c_int,
    pub msgssz: ::std::os::raw::c_int,
    pub msgtql: ::std::os::raw::c_int,
    pub msgseg: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_lkl_msginfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_msginfo>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_msginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_msginfo>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_msginfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msginfo>())).msgpool as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msginfo),
            "::",
            stringify!(msgpool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msginfo>())).msgmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msginfo),
            "::",
            stringify!(msgmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msginfo>())).msgmax as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msginfo),
            "::",
            stringify!(msgmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msginfo>())).msgmnb as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msginfo),
            "::",
            stringify!(msgmnb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msginfo>())).msgmni as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msginfo),
            "::",
            stringify!(msgmni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msginfo>())).msgssz as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msginfo),
            "::",
            stringify!(msgssz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msginfo>())).msgtql as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msginfo),
            "::",
            stringify!(msgtql)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_msginfo>())).msgseg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_msginfo),
            "::",
            stringify!(msgseg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rusage {
    pub ru_utime: __lkl__kernel_old_timeval,
    pub ru_stime: __lkl__kernel_old_timeval,
    pub ru_maxrss: __lkl__kernel_long_t,
    pub ru_ixrss: __lkl__kernel_long_t,
    pub ru_idrss: __lkl__kernel_long_t,
    pub ru_isrss: __lkl__kernel_long_t,
    pub ru_minflt: __lkl__kernel_long_t,
    pub ru_majflt: __lkl__kernel_long_t,
    pub ru_nswap: __lkl__kernel_long_t,
    pub ru_inblock: __lkl__kernel_long_t,
    pub ru_oublock: __lkl__kernel_long_t,
    pub ru_msgsnd: __lkl__kernel_long_t,
    pub ru_msgrcv: __lkl__kernel_long_t,
    pub ru_nsignals: __lkl__kernel_long_t,
    pub ru_nvcsw: __lkl__kernel_long_t,
    pub ru_nivcsw: __lkl__kernel_long_t,
}
#[test]
fn bindgen_test_layout_lkl_rusage() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rusage>(),
        144usize,
        concat!("Size of: ", stringify!(lkl_rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rlimit {
    pub rlim_cur: __lkl__kernel_ulong_t,
    pub rlim_max: __lkl__kernel_ulong_t,
}
#[test]
fn bindgen_test_layout_lkl_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rlimit64 {
    pub rlim_cur: __lkl__u64,
    pub rlim_max: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_rlimit64() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rlimit64>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_rlimit64))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rlimit64>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_rlimit64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rlimit64>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rlimit64),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rlimit64>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rlimit64),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_sysinfo {
    pub uptime: __lkl__kernel_long_t,
    pub loads: [__lkl__kernel_ulong_t; 3usize],
    pub totalram: __lkl__kernel_ulong_t,
    pub freeram: __lkl__kernel_ulong_t,
    pub sharedram: __lkl__kernel_ulong_t,
    pub bufferram: __lkl__kernel_ulong_t,
    pub totalswap: __lkl__kernel_ulong_t,
    pub freeswap: __lkl__kernel_ulong_t,
    pub procs: __lkl__u16,
    pub pad: __lkl__u16,
    pub totalhigh: __lkl__kernel_ulong_t,
    pub freehigh: __lkl__kernel_ulong_t,
    pub mem_unit: __lkl__u32,
    pub _f: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_lkl_sysinfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sysinfo>(),
        112usize,
        concat!("Size of: ", stringify!(lkl_sysinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sysinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sysinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).uptime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(uptime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).loads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(loads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).totalram as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(totalram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).freeram as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(freeram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).sharedram as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(sharedram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).bufferram as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(bufferram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).totalswap as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(totalswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).freeswap as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(freeswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).procs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(procs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).pad as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).totalhigh as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(totalhigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).freehigh as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(freehigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>())).mem_unit as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(mem_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sysinfo>()))._f as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sysinfo),
            "::",
            stringify!(_f)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type ssize_t = __ssize_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type gid_t = __gid_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type useconds_t = __useconds_t;
pub type pid_t = __pid_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(
        __buf: *mut ::std::os::raw::c_char,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int);
}
pub const _PC_LINK_MAX: ::std::os::raw::c_uint = 0;
pub const _PC_MAX_CANON: ::std::os::raw::c_uint = 1;
pub const _PC_MAX_INPUT: ::std::os::raw::c_uint = 2;
pub const _PC_NAME_MAX: ::std::os::raw::c_uint = 3;
pub const _PC_PATH_MAX: ::std::os::raw::c_uint = 4;
pub const _PC_PIPE_BUF: ::std::os::raw::c_uint = 5;
pub const _PC_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 6;
pub const _PC_NO_TRUNC: ::std::os::raw::c_uint = 7;
pub const _PC_VDISABLE: ::std::os::raw::c_uint = 8;
pub const _PC_SYNC_IO: ::std::os::raw::c_uint = 9;
pub const _PC_ASYNC_IO: ::std::os::raw::c_uint = 10;
pub const _PC_PRIO_IO: ::std::os::raw::c_uint = 11;
pub const _PC_SOCK_MAXBUF: ::std::os::raw::c_uint = 12;
pub const _PC_FILESIZEBITS: ::std::os::raw::c_uint = 13;
pub const _PC_REC_INCR_XFER_SIZE: ::std::os::raw::c_uint = 14;
pub const _PC_REC_MAX_XFER_SIZE: ::std::os::raw::c_uint = 15;
pub const _PC_REC_MIN_XFER_SIZE: ::std::os::raw::c_uint = 16;
pub const _PC_REC_XFER_ALIGN: ::std::os::raw::c_uint = 17;
pub const _PC_ALLOC_SIZE_MIN: ::std::os::raw::c_uint = 18;
pub const _PC_SYMLINK_MAX: ::std::os::raw::c_uint = 19;
pub const _PC_2_SYMLINKS: ::std::os::raw::c_uint = 20;
pub type _bindgen_ty_35 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: ::std::os::raw::c_uint = 0;
pub const _SC_CHILD_MAX: ::std::os::raw::c_uint = 1;
pub const _SC_CLK_TCK: ::std::os::raw::c_uint = 2;
pub const _SC_NGROUPS_MAX: ::std::os::raw::c_uint = 3;
pub const _SC_OPEN_MAX: ::std::os::raw::c_uint = 4;
pub const _SC_STREAM_MAX: ::std::os::raw::c_uint = 5;
pub const _SC_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _SC_JOB_CONTROL: ::std::os::raw::c_uint = 7;
pub const _SC_SAVED_IDS: ::std::os::raw::c_uint = 8;
pub const _SC_REALTIME_SIGNALS: ::std::os::raw::c_uint = 9;
pub const _SC_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 10;
pub const _SC_TIMERS: ::std::os::raw::c_uint = 11;
pub const _SC_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 12;
pub const _SC_PRIORITIZED_IO: ::std::os::raw::c_uint = 13;
pub const _SC_SYNCHRONIZED_IO: ::std::os::raw::c_uint = 14;
pub const _SC_FSYNC: ::std::os::raw::c_uint = 15;
pub const _SC_MAPPED_FILES: ::std::os::raw::c_uint = 16;
pub const _SC_MEMLOCK: ::std::os::raw::c_uint = 17;
pub const _SC_MEMLOCK_RANGE: ::std::os::raw::c_uint = 18;
pub const _SC_MEMORY_PROTECTION: ::std::os::raw::c_uint = 19;
pub const _SC_MESSAGE_PASSING: ::std::os::raw::c_uint = 20;
pub const _SC_SEMAPHORES: ::std::os::raw::c_uint = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 22;
pub const _SC_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 23;
pub const _SC_AIO_MAX: ::std::os::raw::c_uint = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 25;
pub const _SC_DELAYTIMER_MAX: ::std::os::raw::c_uint = 26;
pub const _SC_MQ_OPEN_MAX: ::std::os::raw::c_uint = 27;
pub const _SC_MQ_PRIO_MAX: ::std::os::raw::c_uint = 28;
pub const _SC_VERSION: ::std::os::raw::c_uint = 29;
pub const _SC_PAGESIZE: ::std::os::raw::c_uint = 30;
pub const _SC_RTSIG_MAX: ::std::os::raw::c_uint = 31;
pub const _SC_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 32;
pub const _SC_SEM_VALUE_MAX: ::std::os::raw::c_uint = 33;
pub const _SC_SIGQUEUE_MAX: ::std::os::raw::c_uint = 34;
pub const _SC_TIMER_MAX: ::std::os::raw::c_uint = 35;
pub const _SC_BC_BASE_MAX: ::std::os::raw::c_uint = 36;
pub const _SC_BC_DIM_MAX: ::std::os::raw::c_uint = 37;
pub const _SC_BC_SCALE_MAX: ::std::os::raw::c_uint = 38;
pub const _SC_BC_STRING_MAX: ::std::os::raw::c_uint = 39;
pub const _SC_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 40;
pub const _SC_EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 41;
pub const _SC_EXPR_NEST_MAX: ::std::os::raw::c_uint = 42;
pub const _SC_LINE_MAX: ::std::os::raw::c_uint = 43;
pub const _SC_RE_DUP_MAX: ::std::os::raw::c_uint = 44;
pub const _SC_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 45;
pub const _SC_2_VERSION: ::std::os::raw::c_uint = 46;
pub const _SC_2_C_BIND: ::std::os::raw::c_uint = 47;
pub const _SC_2_C_DEV: ::std::os::raw::c_uint = 48;
pub const _SC_2_FORT_DEV: ::std::os::raw::c_uint = 49;
pub const _SC_2_FORT_RUN: ::std::os::raw::c_uint = 50;
pub const _SC_2_SW_DEV: ::std::os::raw::c_uint = 51;
pub const _SC_2_LOCALEDEF: ::std::os::raw::c_uint = 52;
pub const _SC_PII: ::std::os::raw::c_uint = 53;
pub const _SC_PII_XTI: ::std::os::raw::c_uint = 54;
pub const _SC_PII_SOCKET: ::std::os::raw::c_uint = 55;
pub const _SC_PII_INTERNET: ::std::os::raw::c_uint = 56;
pub const _SC_PII_OSI: ::std::os::raw::c_uint = 57;
pub const _SC_POLL: ::std::os::raw::c_uint = 58;
pub const _SC_SELECT: ::std::os::raw::c_uint = 59;
pub const _SC_UIO_MAXIOV: ::std::os::raw::c_uint = 60;
pub const _SC_IOV_MAX: ::std::os::raw::c_uint = 60;
pub const _SC_PII_INTERNET_STREAM: ::std::os::raw::c_uint = 61;
pub const _SC_PII_INTERNET_DGRAM: ::std::os::raw::c_uint = 62;
pub const _SC_PII_OSI_COTS: ::std::os::raw::c_uint = 63;
pub const _SC_PII_OSI_CLTS: ::std::os::raw::c_uint = 64;
pub const _SC_PII_OSI_M: ::std::os::raw::c_uint = 65;
pub const _SC_T_IOV_MAX: ::std::os::raw::c_uint = 66;
pub const _SC_THREADS: ::std::os::raw::c_uint = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: ::std::os::raw::c_uint = 68;
pub const _SC_GETGR_R_SIZE_MAX: ::std::os::raw::c_uint = 69;
pub const _SC_GETPW_R_SIZE_MAX: ::std::os::raw::c_uint = 70;
pub const _SC_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 71;
pub const _SC_TTY_NAME_MAX: ::std::os::raw::c_uint = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 73;
pub const _SC_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 74;
pub const _SC_THREAD_STACK_MIN: ::std::os::raw::c_uint = 75;
pub const _SC_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 76;
pub const _SC_THREAD_ATTR_STACKADDR: ::std::os::raw::c_uint = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: ::std::os::raw::c_uint = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 79;
pub const _SC_THREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 80;
pub const _SC_THREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 81;
pub const _SC_THREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 82;
pub const _SC_NPROCESSORS_CONF: ::std::os::raw::c_uint = 83;
pub const _SC_NPROCESSORS_ONLN: ::std::os::raw::c_uint = 84;
pub const _SC_PHYS_PAGES: ::std::os::raw::c_uint = 85;
pub const _SC_AVPHYS_PAGES: ::std::os::raw::c_uint = 86;
pub const _SC_ATEXIT_MAX: ::std::os::raw::c_uint = 87;
pub const _SC_PASS_MAX: ::std::os::raw::c_uint = 88;
pub const _SC_XOPEN_VERSION: ::std::os::raw::c_uint = 89;
pub const _SC_XOPEN_XCU_VERSION: ::std::os::raw::c_uint = 90;
pub const _SC_XOPEN_UNIX: ::std::os::raw::c_uint = 91;
pub const _SC_XOPEN_CRYPT: ::std::os::raw::c_uint = 92;
pub const _SC_XOPEN_ENH_I18N: ::std::os::raw::c_uint = 93;
pub const _SC_XOPEN_SHM: ::std::os::raw::c_uint = 94;
pub const _SC_2_CHAR_TERM: ::std::os::raw::c_uint = 95;
pub const _SC_2_C_VERSION: ::std::os::raw::c_uint = 96;
pub const _SC_2_UPE: ::std::os::raw::c_uint = 97;
pub const _SC_XOPEN_XPG2: ::std::os::raw::c_uint = 98;
pub const _SC_XOPEN_XPG3: ::std::os::raw::c_uint = 99;
pub const _SC_XOPEN_XPG4: ::std::os::raw::c_uint = 100;
pub const _SC_CHAR_BIT: ::std::os::raw::c_uint = 101;
pub const _SC_CHAR_MAX: ::std::os::raw::c_uint = 102;
pub const _SC_CHAR_MIN: ::std::os::raw::c_uint = 103;
pub const _SC_INT_MAX: ::std::os::raw::c_uint = 104;
pub const _SC_INT_MIN: ::std::os::raw::c_uint = 105;
pub const _SC_LONG_BIT: ::std::os::raw::c_uint = 106;
pub const _SC_WORD_BIT: ::std::os::raw::c_uint = 107;
pub const _SC_MB_LEN_MAX: ::std::os::raw::c_uint = 108;
pub const _SC_NZERO: ::std::os::raw::c_uint = 109;
pub const _SC_SSIZE_MAX: ::std::os::raw::c_uint = 110;
pub const _SC_SCHAR_MAX: ::std::os::raw::c_uint = 111;
pub const _SC_SCHAR_MIN: ::std::os::raw::c_uint = 112;
pub const _SC_SHRT_MAX: ::std::os::raw::c_uint = 113;
pub const _SC_SHRT_MIN: ::std::os::raw::c_uint = 114;
pub const _SC_UCHAR_MAX: ::std::os::raw::c_uint = 115;
pub const _SC_UINT_MAX: ::std::os::raw::c_uint = 116;
pub const _SC_ULONG_MAX: ::std::os::raw::c_uint = 117;
pub const _SC_USHRT_MAX: ::std::os::raw::c_uint = 118;
pub const _SC_NL_ARGMAX: ::std::os::raw::c_uint = 119;
pub const _SC_NL_LANGMAX: ::std::os::raw::c_uint = 120;
pub const _SC_NL_MSGMAX: ::std::os::raw::c_uint = 121;
pub const _SC_NL_NMAX: ::std::os::raw::c_uint = 122;
pub const _SC_NL_SETMAX: ::std::os::raw::c_uint = 123;
pub const _SC_NL_TEXTMAX: ::std::os::raw::c_uint = 124;
pub const _SC_XBS5_ILP32_OFF32: ::std::os::raw::c_uint = 125;
pub const _SC_XBS5_ILP32_OFFBIG: ::std::os::raw::c_uint = 126;
pub const _SC_XBS5_LP64_OFF64: ::std::os::raw::c_uint = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: ::std::os::raw::c_uint = 128;
pub const _SC_XOPEN_LEGACY: ::std::os::raw::c_uint = 129;
pub const _SC_XOPEN_REALTIME: ::std::os::raw::c_uint = 130;
pub const _SC_XOPEN_REALTIME_THREADS: ::std::os::raw::c_uint = 131;
pub const _SC_ADVISORY_INFO: ::std::os::raw::c_uint = 132;
pub const _SC_BARRIERS: ::std::os::raw::c_uint = 133;
pub const _SC_BASE: ::std::os::raw::c_uint = 134;
pub const _SC_C_LANG_SUPPORT: ::std::os::raw::c_uint = 135;
pub const _SC_C_LANG_SUPPORT_R: ::std::os::raw::c_uint = 136;
pub const _SC_CLOCK_SELECTION: ::std::os::raw::c_uint = 137;
pub const _SC_CPUTIME: ::std::os::raw::c_uint = 138;
pub const _SC_THREAD_CPUTIME: ::std::os::raw::c_uint = 139;
pub const _SC_DEVICE_IO: ::std::os::raw::c_uint = 140;
pub const _SC_DEVICE_SPECIFIC: ::std::os::raw::c_uint = 141;
pub const _SC_DEVICE_SPECIFIC_R: ::std::os::raw::c_uint = 142;
pub const _SC_FD_MGMT: ::std::os::raw::c_uint = 143;
pub const _SC_FIFO: ::std::os::raw::c_uint = 144;
pub const _SC_PIPE: ::std::os::raw::c_uint = 145;
pub const _SC_FILE_ATTRIBUTES: ::std::os::raw::c_uint = 146;
pub const _SC_FILE_LOCKING: ::std::os::raw::c_uint = 147;
pub const _SC_FILE_SYSTEM: ::std::os::raw::c_uint = 148;
pub const _SC_MONOTONIC_CLOCK: ::std::os::raw::c_uint = 149;
pub const _SC_MULTI_PROCESS: ::std::os::raw::c_uint = 150;
pub const _SC_SINGLE_PROCESS: ::std::os::raw::c_uint = 151;
pub const _SC_NETWORKING: ::std::os::raw::c_uint = 152;
pub const _SC_READER_WRITER_LOCKS: ::std::os::raw::c_uint = 153;
pub const _SC_SPIN_LOCKS: ::std::os::raw::c_uint = 154;
pub const _SC_REGEXP: ::std::os::raw::c_uint = 155;
pub const _SC_REGEX_VERSION: ::std::os::raw::c_uint = 156;
pub const _SC_SHELL: ::std::os::raw::c_uint = 157;
pub const _SC_SIGNALS: ::std::os::raw::c_uint = 158;
pub const _SC_SPAWN: ::std::os::raw::c_uint = 159;
pub const _SC_SPORADIC_SERVER: ::std::os::raw::c_uint = 160;
pub const _SC_THREAD_SPORADIC_SERVER: ::std::os::raw::c_uint = 161;
pub const _SC_SYSTEM_DATABASE: ::std::os::raw::c_uint = 162;
pub const _SC_SYSTEM_DATABASE_R: ::std::os::raw::c_uint = 163;
pub const _SC_TIMEOUTS: ::std::os::raw::c_uint = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 165;
pub const _SC_USER_GROUPS: ::std::os::raw::c_uint = 166;
pub const _SC_USER_GROUPS_R: ::std::os::raw::c_uint = 167;
pub const _SC_2_PBS: ::std::os::raw::c_uint = 168;
pub const _SC_2_PBS_ACCOUNTING: ::std::os::raw::c_uint = 169;
pub const _SC_2_PBS_LOCATE: ::std::os::raw::c_uint = 170;
pub const _SC_2_PBS_MESSAGE: ::std::os::raw::c_uint = 171;
pub const _SC_2_PBS_TRACK: ::std::os::raw::c_uint = 172;
pub const _SC_SYMLOOP_MAX: ::std::os::raw::c_uint = 173;
pub const _SC_STREAMS: ::std::os::raw::c_uint = 174;
pub const _SC_2_PBS_CHECKPOINT: ::std::os::raw::c_uint = 175;
pub const _SC_V6_ILP32_OFF32: ::std::os::raw::c_uint = 176;
pub const _SC_V6_ILP32_OFFBIG: ::std::os::raw::c_uint = 177;
pub const _SC_V6_LP64_OFF64: ::std::os::raw::c_uint = 178;
pub const _SC_V6_LPBIG_OFFBIG: ::std::os::raw::c_uint = 179;
pub const _SC_HOST_NAME_MAX: ::std::os::raw::c_uint = 180;
pub const _SC_TRACE: ::std::os::raw::c_uint = 181;
pub const _SC_TRACE_EVENT_FILTER: ::std::os::raw::c_uint = 182;
pub const _SC_TRACE_INHERIT: ::std::os::raw::c_uint = 183;
pub const _SC_TRACE_LOG: ::std::os::raw::c_uint = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: ::std::os::raw::c_uint = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: ::std::os::raw::c_uint = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: ::std::os::raw::c_uint = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: ::std::os::raw::c_uint = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: ::std::os::raw::c_uint = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: ::std::os::raw::c_uint = 190;
pub const _SC_LEVEL2_CACHE_SIZE: ::std::os::raw::c_uint = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: ::std::os::raw::c_uint = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: ::std::os::raw::c_uint = 193;
pub const _SC_LEVEL3_CACHE_SIZE: ::std::os::raw::c_uint = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: ::std::os::raw::c_uint = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: ::std::os::raw::c_uint = 196;
pub const _SC_LEVEL4_CACHE_SIZE: ::std::os::raw::c_uint = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: ::std::os::raw::c_uint = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: ::std::os::raw::c_uint = 199;
pub const _SC_IPV6: ::std::os::raw::c_uint = 235;
pub const _SC_RAW_SOCKETS: ::std::os::raw::c_uint = 236;
pub const _SC_V7_ILP32_OFF32: ::std::os::raw::c_uint = 237;
pub const _SC_V7_ILP32_OFFBIG: ::std::os::raw::c_uint = 238;
pub const _SC_V7_LP64_OFF64: ::std::os::raw::c_uint = 239;
pub const _SC_V7_LPBIG_OFFBIG: ::std::os::raw::c_uint = 240;
pub const _SC_SS_REPL_MAX: ::std::os::raw::c_uint = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: ::std::os::raw::c_uint = 242;
pub const _SC_TRACE_NAME_MAX: ::std::os::raw::c_uint = 243;
pub const _SC_TRACE_SYS_MAX: ::std::os::raw::c_uint = 244;
pub const _SC_TRACE_USER_EVENT_MAX: ::std::os::raw::c_uint = 245;
pub const _SC_XOPEN_STREAMS: ::std::os::raw::c_uint = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::std::os::raw::c_uint = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::std::os::raw::c_uint = 248;
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
pub const _CS_PATH: ::std::os::raw::c_uint = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 1;
pub const _CS_GNU_LIBC_VERSION: ::std::os::raw::c_uint = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: ::std::os::raw::c_uint = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 5;
pub const _CS_LFS_CFLAGS: ::std::os::raw::c_uint = 1000;
pub const _CS_LFS_LDFLAGS: ::std::os::raw::c_uint = 1001;
pub const _CS_LFS_LIBS: ::std::os::raw::c_uint = 1002;
pub const _CS_LFS_LINTFLAGS: ::std::os::raw::c_uint = 1003;
pub const _CS_LFS64_CFLAGS: ::std::os::raw::c_uint = 1004;
pub const _CS_LFS64_LDFLAGS: ::std::os::raw::c_uint = 1005;
pub const _CS_LFS64_LIBS: ::std::os::raw::c_uint = 1006;
pub const _CS_LFS64_LINTFLAGS: ::std::os::raw::c_uint = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1147;
pub const _CS_V6_ENV: ::std::os::raw::c_uint = 1148;
pub const _CS_V7_ENV: ::std::os::raw::c_uint = 1149;
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: size_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: size_t,
        __offset: size_t,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_shmid_ds {
    pub shm_perm: ipc_perm,
    pub shm_segsz: ::std::os::raw::c_int,
    pub shm_atime: __lkl__kernel_old_time_t,
    pub shm_dtime: __lkl__kernel_old_time_t,
    pub shm_ctime: __lkl__kernel_old_time_t,
    pub shm_cpid: __lkl__kernel_ipc_pid_t,
    pub shm_lpid: __lkl__kernel_ipc_pid_t,
    pub shm_nattch: ::std::os::raw::c_ushort,
    pub shm_unused: ::std::os::raw::c_ushort,
    pub shm_unused2: *mut ::std::os::raw::c_void,
    pub shm_unused3: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lkl_shmid_ds() {
    assert_eq!(
        ::std::mem::size_of::<lkl_shmid_ds>(),
        88usize,
        concat!("Size of: ", stringify!(lkl_shmid_ds))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_shmid_ds>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_shmid_ds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid_ds>())).shm_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid_ds),
            "::",
            stringify!(shm_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid_ds>())).shm_segsz as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid_ds),
            "::",
            stringify!(shm_segsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid_ds>())).shm_atime as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid_ds),
            "::",
            stringify!(shm_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid_ds>())).shm_dtime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid_ds),
            "::",
            stringify!(shm_dtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid_ds>())).shm_ctime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid_ds),
            "::",
            stringify!(shm_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid_ds>())).shm_cpid as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid_ds),
            "::",
            stringify!(shm_cpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid_ds>())).shm_lpid as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid_ds),
            "::",
            stringify!(shm_lpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid_ds>())).shm_nattch as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid_ds),
            "::",
            stringify!(shm_nattch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid_ds>())).shm_unused as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid_ds),
            "::",
            stringify!(shm_unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid_ds>())).shm_unused2 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid_ds),
            "::",
            stringify!(shm_unused2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid_ds>())).shm_unused3 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid_ds),
            "::",
            stringify!(shm_unused3)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_shmid64_ds {
    pub shm_perm: lkl_ipc64_perm,
    pub shm_segsz: lkl_size_t,
    pub shm_atime: ::std::os::raw::c_long,
    pub shm_dtime: ::std::os::raw::c_long,
    pub shm_ctime: ::std::os::raw::c_long,
    pub shm_cpid: __lkl__kernel_pid_t,
    pub shm_lpid: __lkl__kernel_pid_t,
    pub shm_nattch: ::std::os::raw::c_ulong,
    pub __unused4: ::std::os::raw::c_ulong,
    pub __unused5: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_lkl_shmid64_ds() {
    assert_eq!(
        ::std::mem::size_of::<lkl_shmid64_ds>(),
        112usize,
        concat!("Size of: ", stringify!(lkl_shmid64_ds))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_shmid64_ds>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_shmid64_ds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid64_ds>())).shm_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid64_ds),
            "::",
            stringify!(shm_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid64_ds>())).shm_segsz as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid64_ds),
            "::",
            stringify!(shm_segsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid64_ds>())).shm_atime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid64_ds),
            "::",
            stringify!(shm_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid64_ds>())).shm_dtime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid64_ds),
            "::",
            stringify!(shm_dtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid64_ds>())).shm_ctime as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid64_ds),
            "::",
            stringify!(shm_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid64_ds>())).shm_cpid as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid64_ds),
            "::",
            stringify!(shm_cpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid64_ds>())).shm_lpid as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid64_ds),
            "::",
            stringify!(shm_lpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid64_ds>())).shm_nattch as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid64_ds),
            "::",
            stringify!(shm_nattch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid64_ds>())).__unused4 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid64_ds),
            "::",
            stringify!(__unused4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shmid64_ds>())).__unused5 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shmid64_ds),
            "::",
            stringify!(__unused5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_shminfo64 {
    pub shmmax: ::std::os::raw::c_ulong,
    pub shmmin: ::std::os::raw::c_ulong,
    pub shmmni: ::std::os::raw::c_ulong,
    pub shmseg: ::std::os::raw::c_ulong,
    pub shmall: ::std::os::raw::c_ulong,
    pub __unused1: ::std::os::raw::c_ulong,
    pub __unused2: ::std::os::raw::c_ulong,
    pub __unused3: ::std::os::raw::c_ulong,
    pub __unused4: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_lkl_shminfo64() {
    assert_eq!(
        ::std::mem::size_of::<lkl_shminfo64>(),
        72usize,
        concat!("Size of: ", stringify!(lkl_shminfo64))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_shminfo64>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_shminfo64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo64>())).shmmax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo64),
            "::",
            stringify!(shmmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo64>())).shmmin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo64),
            "::",
            stringify!(shmmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo64>())).shmmni as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo64),
            "::",
            stringify!(shmmni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo64>())).shmseg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo64),
            "::",
            stringify!(shmseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo64>())).shmall as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo64),
            "::",
            stringify!(shmall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo64>())).__unused1 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo64),
            "::",
            stringify!(__unused1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo64>())).__unused2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo64),
            "::",
            stringify!(__unused2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo64>())).__unused3 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo64),
            "::",
            stringify!(__unused3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo64>())).__unused4 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo64),
            "::",
            stringify!(__unused4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_shminfo {
    pub shmmax: ::std::os::raw::c_int,
    pub shmmin: ::std::os::raw::c_int,
    pub shmmni: ::std::os::raw::c_int,
    pub shmseg: ::std::os::raw::c_int,
    pub shmall: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lkl_shminfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_shminfo>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_shminfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_shminfo>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_shminfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo>())).shmmax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo),
            "::",
            stringify!(shmmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo>())).shmmin as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo),
            "::",
            stringify!(shmmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo>())).shmmni as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo),
            "::",
            stringify!(shmmni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo>())).shmseg as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo),
            "::",
            stringify!(shmseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shminfo>())).shmall as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shminfo),
            "::",
            stringify!(shmall)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_shm_info {
    pub used_ids: ::std::os::raw::c_int,
    pub shm_tot: __lkl__kernel_ulong_t,
    pub shm_rss: __lkl__kernel_ulong_t,
    pub shm_swp: __lkl__kernel_ulong_t,
    pub swap_attempts: __lkl__kernel_ulong_t,
    pub swap_successes: __lkl__kernel_ulong_t,
}
#[test]
fn bindgen_test_layout_lkl_shm_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_shm_info>(),
        48usize,
        concat!("Size of: ", stringify!(lkl_shm_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_shm_info>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_shm_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shm_info>())).used_ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shm_info),
            "::",
            stringify!(used_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shm_info>())).shm_tot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shm_info),
            "::",
            stringify!(shm_tot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shm_info>())).shm_rss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shm_info),
            "::",
            stringify!(shm_rss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shm_info>())).shm_swp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shm_info),
            "::",
            stringify!(shm_swp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shm_info>())).swap_attempts as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shm_info),
            "::",
            stringify!(swap_attempts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_shm_info>())).swap_successes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_shm_info),
            "::",
            stringify!(swap_successes)
        )
    );
}
pub type lkl_aio_context_t = __lkl__kernel_ulong_t;
pub const LKL_IOCB_CMD_PREAD: ::std::os::raw::c_uint = 0;
pub const LKL_IOCB_CMD_PWRITE: ::std::os::raw::c_uint = 1;
pub const LKL_IOCB_CMD_FSYNC: ::std::os::raw::c_uint = 2;
pub const LKL_IOCB_CMD_FDSYNC: ::std::os::raw::c_uint = 3;
pub const LKL_IOCB_CMD_POLL: ::std::os::raw::c_uint = 5;
pub const LKL_IOCB_CMD_NOOP: ::std::os::raw::c_uint = 6;
pub const LKL_IOCB_CMD_PREADV: ::std::os::raw::c_uint = 7;
pub const LKL_IOCB_CMD_PWRITEV: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_38 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_io_event {
    pub data: __lkl__u64,
    pub obj: __lkl__u64,
    pub res: __lkl__s64,
    pub res2: __lkl__s64,
}
#[test]
fn bindgen_test_layout_lkl_io_event() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_event>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_io_event))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_event>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_io_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_event>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_event),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_event>())).obj as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_event),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_event>())).res as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_event),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_event>())).res2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_event),
            "::",
            stringify!(res2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_iocb {
    pub aio_data: __lkl__u64,
    pub aio_key: __lkl__u32,
    pub aio_rw_flags: __lkl__kernel_rwf_t,
    pub aio_lio_opcode: __lkl__u16,
    pub aio_reqprio: __lkl__s16,
    pub aio_fildes: __lkl__u32,
    pub aio_buf: __lkl__u64,
    pub aio_nbytes: __lkl__u64,
    pub aio_offset: __lkl__s64,
    pub aio_reserved2: __lkl__u64,
    pub aio_flags: __lkl__u32,
    pub aio_resfd: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_iocb() {
    assert_eq!(
        ::std::mem::size_of::<lkl_iocb>(),
        64usize,
        concat!("Size of: ", stringify!(lkl_iocb))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_iocb>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_iocb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_rw_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_rw_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_lio_opcode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_lio_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_reqprio as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_reqprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_fildes as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_fildes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_buf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_nbytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_nbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_offset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_reserved2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iocb>())).aio_resfd as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iocb),
            "::",
            stringify!(aio_resfd)
        )
    );
}
pub type __lkl__kernel_sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lkl__kernel_sockaddr_storage {
    pub __bindgen_anon_1: __lkl__kernel_sockaddr_storage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __lkl__kernel_sockaddr_storage__bindgen_ty_1 {
    pub __bindgen_anon_1: __lkl__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1,
    pub __align: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lkl__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    pub ss_family: __lkl__kernel_sa_family_t,
    pub __data: [::std::os::raw::c_char; 126usize],
}
#[test]
fn bindgen_test_layout___lkl__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(__lkl__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(__lkl__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1>()))
                .ss_family as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1>()))
                .__data as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__data)
        )
    );
}
#[test]
fn bindgen_test_layout___lkl__kernel_sockaddr_storage__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_sockaddr_storage__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(__lkl__kernel_sockaddr_storage__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_sockaddr_storage__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__lkl__kernel_sockaddr_storage__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__kernel_sockaddr_storage__bindgen_ty_1>())).__align
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__kernel_sockaddr_storage__bindgen_ty_1),
            "::",
            stringify!(__align)
        )
    );
}
#[test]
fn bindgen_test_layout___lkl__kernel_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__kernel_sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(__lkl__kernel_sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__kernel_sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__kernel_sockaddr_storage))
    );
}
pub const lkl_perf_type_id_LKL_PERF_TYPE_HARDWARE: lkl_perf_type_id = 0;
pub const lkl_perf_type_id_LKL_PERF_TYPE_SOFTWARE: lkl_perf_type_id = 1;
pub const lkl_perf_type_id_LKL_PERF_TYPE_TRACEPOINT: lkl_perf_type_id = 2;
pub const lkl_perf_type_id_LKL_PERF_TYPE_HW_CACHE: lkl_perf_type_id = 3;
pub const lkl_perf_type_id_LKL_PERF_TYPE_RAW: lkl_perf_type_id = 4;
pub const lkl_perf_type_id_LKL_PERF_TYPE_BREAKPOINT: lkl_perf_type_id = 5;
pub const lkl_perf_type_id_LKL_PERF_TYPE_MAX: lkl_perf_type_id = 6;
pub type lkl_perf_type_id = ::std::os::raw::c_uint;
pub const lkl_perf_hw_id_LKL_PERF_COUNT_HW_CPU_CYCLES: lkl_perf_hw_id = 0;
pub const lkl_perf_hw_id_LKL_PERF_COUNT_HW_INSTRUCTIONS: lkl_perf_hw_id = 1;
pub const lkl_perf_hw_id_LKL_PERF_COUNT_HW_CACHE_REFERENCES: lkl_perf_hw_id = 2;
pub const lkl_perf_hw_id_LKL_PERF_COUNT_HW_CACHE_MISSES: lkl_perf_hw_id = 3;
pub const lkl_perf_hw_id_LKL_PERF_COUNT_HW_BRANCH_INSTRUCTIONS: lkl_perf_hw_id = 4;
pub const lkl_perf_hw_id_LKL_PERF_COUNT_HW_BRANCH_MISSES: lkl_perf_hw_id = 5;
pub const lkl_perf_hw_id_LKL_PERF_COUNT_HW_BUS_CYCLES: lkl_perf_hw_id = 6;
pub const lkl_perf_hw_id_LKL_PERF_COUNT_HW_STALLED_CYCLES_FRONTEND: lkl_perf_hw_id = 7;
pub const lkl_perf_hw_id_LKL_PERF_COUNT_HW_STALLED_CYCLES_BACKEND: lkl_perf_hw_id = 8;
pub const lkl_perf_hw_id_LKL_PERF_COUNT_HW_REF_CPU_CYCLES: lkl_perf_hw_id = 9;
pub const lkl_perf_hw_id_LKL_PERF_COUNT_HW_MAX: lkl_perf_hw_id = 10;
pub type lkl_perf_hw_id = ::std::os::raw::c_uint;
pub const lkl_perf_hw_cache_id_LKL_PERF_COUNT_HW_CACHE_L1D: lkl_perf_hw_cache_id = 0;
pub const lkl_perf_hw_cache_id_LKL_PERF_COUNT_HW_CACHE_L1I: lkl_perf_hw_cache_id = 1;
pub const lkl_perf_hw_cache_id_LKL_PERF_COUNT_HW_CACHE_LL: lkl_perf_hw_cache_id = 2;
pub const lkl_perf_hw_cache_id_LKL_PERF_COUNT_HW_CACHE_DTLB: lkl_perf_hw_cache_id = 3;
pub const lkl_perf_hw_cache_id_LKL_PERF_COUNT_HW_CACHE_ITLB: lkl_perf_hw_cache_id = 4;
pub const lkl_perf_hw_cache_id_LKL_PERF_COUNT_HW_CACHE_BPU: lkl_perf_hw_cache_id = 5;
pub const lkl_perf_hw_cache_id_LKL_PERF_COUNT_HW_CACHE_NODE: lkl_perf_hw_cache_id = 6;
pub const lkl_perf_hw_cache_id_LKL_PERF_COUNT_HW_CACHE_MAX: lkl_perf_hw_cache_id = 7;
pub type lkl_perf_hw_cache_id = ::std::os::raw::c_uint;
pub const lkl_perf_hw_cache_op_id_LKL_PERF_COUNT_HW_CACHE_OP_READ: lkl_perf_hw_cache_op_id = 0;
pub const lkl_perf_hw_cache_op_id_LKL_PERF_COUNT_HW_CACHE_OP_WRITE: lkl_perf_hw_cache_op_id = 1;
pub const lkl_perf_hw_cache_op_id_LKL_PERF_COUNT_HW_CACHE_OP_PREFETCH: lkl_perf_hw_cache_op_id = 2;
pub const lkl_perf_hw_cache_op_id_LKL_PERF_COUNT_HW_CACHE_OP_MAX: lkl_perf_hw_cache_op_id = 3;
pub type lkl_perf_hw_cache_op_id = ::std::os::raw::c_uint;
pub const lkl_perf_hw_cache_op_result_id_LKL_PERF_COUNT_HW_CACHE_RESULT_ACCESS:
    lkl_perf_hw_cache_op_result_id = 0;
pub const lkl_perf_hw_cache_op_result_id_LKL_PERF_COUNT_HW_CACHE_RESULT_MISS:
    lkl_perf_hw_cache_op_result_id = 1;
pub const lkl_perf_hw_cache_op_result_id_LKL_PERF_COUNT_HW_CACHE_RESULT_MAX:
    lkl_perf_hw_cache_op_result_id = 2;
pub type lkl_perf_hw_cache_op_result_id = ::std::os::raw::c_uint;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_CPU_CLOCK: lkl_perf_sw_ids = 0;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_TASK_CLOCK: lkl_perf_sw_ids = 1;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_PAGE_FAULTS: lkl_perf_sw_ids = 2;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_CONTEXT_SWITCHES: lkl_perf_sw_ids = 3;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_CPU_MIGRATIONS: lkl_perf_sw_ids = 4;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_PAGE_FAULTS_MIN: lkl_perf_sw_ids = 5;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_PAGE_FAULTS_MAJ: lkl_perf_sw_ids = 6;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_ALIGNMENT_FAULTS: lkl_perf_sw_ids = 7;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_EMULATION_FAULTS: lkl_perf_sw_ids = 8;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_DUMMY: lkl_perf_sw_ids = 9;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_BPF_OUTPUT: lkl_perf_sw_ids = 10;
pub const lkl_perf_sw_ids_LKL_PERF_COUNT_SW_MAX: lkl_perf_sw_ids = 11;
pub type lkl_perf_sw_ids = ::std::os::raw::c_uint;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_IP: lkl_perf_event_sample_format = 1;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_TID: lkl_perf_event_sample_format = 2;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_TIME: lkl_perf_event_sample_format = 4;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_ADDR: lkl_perf_event_sample_format = 8;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_READ: lkl_perf_event_sample_format = 16;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_CALLCHAIN: lkl_perf_event_sample_format = 32;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_ID: lkl_perf_event_sample_format = 64;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_CPU: lkl_perf_event_sample_format = 128;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_PERIOD: lkl_perf_event_sample_format = 256;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_STREAM_ID: lkl_perf_event_sample_format =
    512;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_RAW: lkl_perf_event_sample_format = 1024;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_BRANCH_STACK: lkl_perf_event_sample_format =
    2048;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_REGS_USER: lkl_perf_event_sample_format =
    4096;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_STACK_USER: lkl_perf_event_sample_format =
    8192;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_WEIGHT: lkl_perf_event_sample_format = 16384;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_DATA_SRC: lkl_perf_event_sample_format =
    32768;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_IDENTIFIER: lkl_perf_event_sample_format =
    65536;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_TRANSACTION: lkl_perf_event_sample_format =
    131072;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_REGS_INTR: lkl_perf_event_sample_format =
    262144;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_PHYS_ADDR: lkl_perf_event_sample_format =
    524288;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_AUX: lkl_perf_event_sample_format = 1048576;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_CGROUP: lkl_perf_event_sample_format =
    2097152;
pub const lkl_perf_event_sample_format_LKL_PERF_SAMPLE_MAX: lkl_perf_event_sample_format = 4194304;
pub const lkl_perf_event_sample_format___LKL__PERF_SAMPLE_CALLCHAIN_EARLY:
    lkl_perf_event_sample_format = 9223372036854775808;
pub type lkl_perf_event_sample_format = ::std::os::raw::c_ulong;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_USER_SHIFT:
    lkl_perf_branch_sample_type_shift = 0;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_KERNEL_SHIFT:
    lkl_perf_branch_sample_type_shift = 1;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_HV_SHIFT:
    lkl_perf_branch_sample_type_shift = 2;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_ANY_SHIFT:
    lkl_perf_branch_sample_type_shift = 3;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT:
    lkl_perf_branch_sample_type_shift = 4;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT:
    lkl_perf_branch_sample_type_shift = 5;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_IND_CALL_SHIFT:
    lkl_perf_branch_sample_type_shift = 6;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT:
    lkl_perf_branch_sample_type_shift = 7;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_IN_TX_SHIFT:
    lkl_perf_branch_sample_type_shift = 8;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_NO_TX_SHIFT:
    lkl_perf_branch_sample_type_shift = 9;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_COND_SHIFT:
    lkl_perf_branch_sample_type_shift = 10;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT:
    lkl_perf_branch_sample_type_shift = 11;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT:
    lkl_perf_branch_sample_type_shift = 12;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_CALL_SHIFT:
    lkl_perf_branch_sample_type_shift = 13;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT:
    lkl_perf_branch_sample_type_shift = 14;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT:
    lkl_perf_branch_sample_type_shift = 15;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT:
    lkl_perf_branch_sample_type_shift = 16;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_HW_INDEX_SHIFT:
    lkl_perf_branch_sample_type_shift = 17;
pub const lkl_perf_branch_sample_type_shift_LKL_PERF_SAMPLE_BRANCH_MAX_SHIFT:
    lkl_perf_branch_sample_type_shift = 18;
pub type lkl_perf_branch_sample_type_shift = ::std::os::raw::c_uint;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_USER: lkl_perf_branch_sample_type = 1;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_KERNEL: lkl_perf_branch_sample_type =
    2;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_HV: lkl_perf_branch_sample_type = 4;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_ANY: lkl_perf_branch_sample_type = 8;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_ANY_CALL: lkl_perf_branch_sample_type =
    16;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_ANY_RETURN:
    lkl_perf_branch_sample_type = 32;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_IND_CALL: lkl_perf_branch_sample_type =
    64;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_ABORT_TX: lkl_perf_branch_sample_type =
    128;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_IN_TX: lkl_perf_branch_sample_type =
    256;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_NO_TX: lkl_perf_branch_sample_type =
    512;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_COND: lkl_perf_branch_sample_type =
    1024;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_CALL_STACK:
    lkl_perf_branch_sample_type = 2048;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_IND_JUMP: lkl_perf_branch_sample_type =
    4096;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_CALL: lkl_perf_branch_sample_type =
    8192;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_NO_FLAGS: lkl_perf_branch_sample_type =
    16384;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_NO_CYCLES:
    lkl_perf_branch_sample_type = 32768;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_TYPE_SAVE:
    lkl_perf_branch_sample_type = 65536;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_HW_INDEX: lkl_perf_branch_sample_type =
    131072;
pub const lkl_perf_branch_sample_type_LKL_PERF_SAMPLE_BRANCH_MAX: lkl_perf_branch_sample_type =
    262144;
pub type lkl_perf_branch_sample_type = ::std::os::raw::c_uint;
pub const LKL_PERF_BR_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const LKL_PERF_BR_COND: ::std::os::raw::c_uint = 1;
pub const LKL_PERF_BR_UNCOND: ::std::os::raw::c_uint = 2;
pub const LKL_PERF_BR_IND: ::std::os::raw::c_uint = 3;
pub const LKL_PERF_BR_CALL: ::std::os::raw::c_uint = 4;
pub const LKL_PERF_BR_IND_CALL: ::std::os::raw::c_uint = 5;
pub const LKL_PERF_BR_RET: ::std::os::raw::c_uint = 6;
pub const LKL_PERF_BR_SYSCALL: ::std::os::raw::c_uint = 7;
pub const LKL_PERF_BR_SYSRET: ::std::os::raw::c_uint = 8;
pub const LKL_PERF_BR_COND_CALL: ::std::os::raw::c_uint = 9;
pub const LKL_PERF_BR_COND_RET: ::std::os::raw::c_uint = 10;
pub const LKL_PERF_BR_MAX: ::std::os::raw::c_uint = 11;
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
pub const lkl_perf_sample_regs_abi_LKL_PERF_SAMPLE_REGS_ABI_NONE: lkl_perf_sample_regs_abi = 0;
pub const lkl_perf_sample_regs_abi_LKL_PERF_SAMPLE_REGS_ABI_32: lkl_perf_sample_regs_abi = 1;
pub const lkl_perf_sample_regs_abi_LKL_PERF_SAMPLE_REGS_ABI_64: lkl_perf_sample_regs_abi = 2;
pub type lkl_perf_sample_regs_abi = ::std::os::raw::c_uint;
pub const LKL_PERF_TXN_ELISION: ::std::os::raw::c_ulong = 1;
pub const LKL_PERF_TXN_TRANSACTION: ::std::os::raw::c_ulong = 2;
pub const LKL_PERF_TXN_SYNC: ::std::os::raw::c_ulong = 4;
pub const LKL_PERF_TXN_ASYNC: ::std::os::raw::c_ulong = 8;
pub const LKL_PERF_TXN_RETRY: ::std::os::raw::c_ulong = 16;
pub const LKL_PERF_TXN_CONFLICT: ::std::os::raw::c_ulong = 32;
pub const LKL_PERF_TXN_CAPACITY_WRITE: ::std::os::raw::c_ulong = 64;
pub const LKL_PERF_TXN_CAPACITY_READ: ::std::os::raw::c_ulong = 128;
pub const LKL_PERF_TXN_MAX: ::std::os::raw::c_ulong = 256;
pub const LKL_PERF_TXN_ABORT_MASK: ::std::os::raw::c_ulong = 18446744069414584320;
pub const LKL_PERF_TXN_ABORT_SHIFT: ::std::os::raw::c_ulong = 32;
pub type _bindgen_ty_40 = ::std::os::raw::c_ulong;
pub const lkl_perf_event_read_format_LKL_PERF_FORMAT_TOTAL_TIME_ENABLED:
    lkl_perf_event_read_format = 1;
pub const lkl_perf_event_read_format_LKL_PERF_FORMAT_TOTAL_TIME_RUNNING:
    lkl_perf_event_read_format = 2;
pub const lkl_perf_event_read_format_LKL_PERF_FORMAT_ID: lkl_perf_event_read_format = 4;
pub const lkl_perf_event_read_format_LKL_PERF_FORMAT_GROUP: lkl_perf_event_read_format = 8;
pub const lkl_perf_event_read_format_LKL_PERF_FORMAT_MAX: lkl_perf_event_read_format = 16;
pub type lkl_perf_event_read_format = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_perf_event_attr {
    pub type_: __lkl__u32,
    pub size: __lkl__u32,
    pub config: __lkl__u64,
    pub __bindgen_anon_1: lkl_perf_event_attr__bindgen_ty_1,
    pub sample_type: __lkl__u64,
    pub read_format: __lkl__u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub __bindgen_anon_2: lkl_perf_event_attr__bindgen_ty_2,
    pub bp_type: __lkl__u32,
    pub __bindgen_anon_3: lkl_perf_event_attr__bindgen_ty_3,
    pub __bindgen_anon_4: lkl_perf_event_attr__bindgen_ty_4,
    pub branch_sample_type: __lkl__u64,
    pub sample_regs_user: __lkl__u64,
    pub sample_stack_user: __lkl__u32,
    pub clockid: __lkl__s32,
    pub sample_regs_intr: __lkl__u64,
    pub aux_watermark: __lkl__u32,
    pub sample_max_stack: __lkl__u16,
    pub __reserved_2: __lkl__u16,
    pub aux_sample_size: __lkl__u32,
    pub __reserved_3: __lkl__u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_perf_event_attr__bindgen_ty_1 {
    pub sample_period: __lkl__u64,
    pub sample_freq: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_perf_event_attr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_event_attr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_perf_event_attr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_event_attr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_perf_event_attr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_1>())).sample_period as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_1),
            "::",
            stringify!(sample_period)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_1>())).sample_freq as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_1),
            "::",
            stringify!(sample_freq)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_perf_event_attr__bindgen_ty_2 {
    pub wakeup_events: __lkl__u32,
    pub wakeup_watermark: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_perf_event_attr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_event_attr__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_perf_event_attr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_event_attr__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_perf_event_attr__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_2>())).wakeup_events as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_2),
            "::",
            stringify!(wakeup_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_2>())).wakeup_watermark
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_2),
            "::",
            stringify!(wakeup_watermark)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_perf_event_attr__bindgen_ty_3 {
    pub bp_addr: __lkl__u64,
    pub kprobe_func: __lkl__u64,
    pub uprobe_path: __lkl__u64,
    pub config1: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_perf_event_attr__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_event_attr__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_perf_event_attr__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_event_attr__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_perf_event_attr__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_3>())).bp_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_3),
            "::",
            stringify!(bp_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_3>())).kprobe_func as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_3),
            "::",
            stringify!(kprobe_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_3>())).uprobe_path as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_3),
            "::",
            stringify!(uprobe_path)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_3>())).config1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_3),
            "::",
            stringify!(config1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_perf_event_attr__bindgen_ty_4 {
    pub bp_len: __lkl__u64,
    pub kprobe_addr: __lkl__u64,
    pub probe_offset: __lkl__u64,
    pub config2: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_perf_event_attr__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_event_attr__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_perf_event_attr__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_event_attr__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_perf_event_attr__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_4>())).bp_len as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_4),
            "::",
            stringify!(bp_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_4>())).kprobe_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_4),
            "::",
            stringify!(kprobe_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_4>())).probe_offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_4),
            "::",
            stringify!(probe_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr__bindgen_ty_4>())).config2 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr__bindgen_ty_4),
            "::",
            stringify!(config2)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_perf_event_attr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_event_attr>(),
        120usize,
        concat!("Size of: ", stringify!(lkl_perf_event_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_event_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_perf_event_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_attr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_attr>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_attr>())).config as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_attr>())).sample_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(sample_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_attr>())).read_format as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(read_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_attr>())).bp_type as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(bp_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr>())).branch_sample_type as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(branch_sample_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr>())).sample_regs_user as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(sample_regs_user)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr>())).sample_stack_user as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(sample_stack_user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_attr>())).clockid as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr>())).sample_regs_intr as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(sample_regs_intr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr>())).aux_watermark as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(aux_watermark)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr>())).sample_max_stack as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(sample_max_stack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr>())).__reserved_2 as *const _ as usize
        },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(__reserved_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr>())).aux_sample_size as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(aux_sample_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_attr>())).__reserved_3 as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_attr),
            "::",
            stringify!(__reserved_3)
        )
    );
}
impl lkl_perf_event_attr {
    #[inline]
    pub fn disabled(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherit(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_inherit(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pinned(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pinned(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclusive(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclusive(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_user(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_user(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_kernel(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_kernel(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_hv(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_hv(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_idle(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_idle(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mmap(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn comm(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_comm(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn freq(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_freq(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherit_stat(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_inherit_stat(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_on_exec(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable_on_exec(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn task(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_task(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn watermark(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_watermark(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn precise_ip(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_precise_ip(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap_data(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mmap_data(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sample_id_all(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sample_id_all(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_host(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_host(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_guest(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_guest(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_callchain_kernel(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_callchain_kernel(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_callchain_user(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_callchain_user(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap2(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mmap2(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn comm_exec(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_comm_exec(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_clockid(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_use_clockid(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn context_switch(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_context_switch(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_backward(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_write_backward(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn namespaces(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_namespaces(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ksymbol(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ksymbol(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bpf_event(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_bpf_event(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aux_output(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_aux_output(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cgroup(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cgroup(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_poke(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_text_poke(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 30u8) as u64) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disabled: __lkl__u64,
        inherit: __lkl__u64,
        pinned: __lkl__u64,
        exclusive: __lkl__u64,
        exclude_user: __lkl__u64,
        exclude_kernel: __lkl__u64,
        exclude_hv: __lkl__u64,
        exclude_idle: __lkl__u64,
        mmap: __lkl__u64,
        comm: __lkl__u64,
        freq: __lkl__u64,
        inherit_stat: __lkl__u64,
        enable_on_exec: __lkl__u64,
        task: __lkl__u64,
        watermark: __lkl__u64,
        precise_ip: __lkl__u64,
        mmap_data: __lkl__u64,
        sample_id_all: __lkl__u64,
        exclude_host: __lkl__u64,
        exclude_guest: __lkl__u64,
        exclude_callchain_kernel: __lkl__u64,
        exclude_callchain_user: __lkl__u64,
        mmap2: __lkl__u64,
        comm_exec: __lkl__u64,
        use_clockid: __lkl__u64,
        context_switch: __lkl__u64,
        write_backward: __lkl__u64,
        namespaces: __lkl__u64,
        ksymbol: __lkl__u64,
        bpf_event: __lkl__u64,
        aux_output: __lkl__u64,
        cgroup: __lkl__u64,
        text_poke: __lkl__u64,
        __reserved_1: __lkl__u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disabled: u64 = unsafe { ::std::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let inherit: u64 = unsafe { ::std::mem::transmute(inherit) };
            inherit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pinned: u64 = unsafe { ::std::mem::transmute(pinned) };
            pinned as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exclusive: u64 = unsafe { ::std::mem::transmute(exclusive) };
            exclusive as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exclude_user: u64 = unsafe { ::std::mem::transmute(exclude_user) };
            exclude_user as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let exclude_kernel: u64 = unsafe { ::std::mem::transmute(exclude_kernel) };
            exclude_kernel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let exclude_hv: u64 = unsafe { ::std::mem::transmute(exclude_hv) };
            exclude_hv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let exclude_idle: u64 = unsafe { ::std::mem::transmute(exclude_idle) };
            exclude_idle as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mmap: u64 = unsafe { ::std::mem::transmute(mmap) };
            mmap as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let comm: u64 = unsafe { ::std::mem::transmute(comm) };
            comm as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let freq: u64 = unsafe { ::std::mem::transmute(freq) };
            freq as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let inherit_stat: u64 = unsafe { ::std::mem::transmute(inherit_stat) };
            inherit_stat as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let enable_on_exec: u64 = unsafe { ::std::mem::transmute(enable_on_exec) };
            enable_on_exec as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let task: u64 = unsafe { ::std::mem::transmute(task) };
            task as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let watermark: u64 = unsafe { ::std::mem::transmute(watermark) };
            watermark as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let precise_ip: u64 = unsafe { ::std::mem::transmute(precise_ip) };
            precise_ip as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let mmap_data: u64 = unsafe { ::std::mem::transmute(mmap_data) };
            mmap_data as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sample_id_all: u64 = unsafe { ::std::mem::transmute(sample_id_all) };
            sample_id_all as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let exclude_host: u64 = unsafe { ::std::mem::transmute(exclude_host) };
            exclude_host as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let exclude_guest: u64 = unsafe { ::std::mem::transmute(exclude_guest) };
            exclude_guest as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let exclude_callchain_kernel: u64 =
                unsafe { ::std::mem::transmute(exclude_callchain_kernel) };
            exclude_callchain_kernel as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let exclude_callchain_user: u64 =
                unsafe { ::std::mem::transmute(exclude_callchain_user) };
            exclude_callchain_user as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let mmap2: u64 = unsafe { ::std::mem::transmute(mmap2) };
            mmap2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let comm_exec: u64 = unsafe { ::std::mem::transmute(comm_exec) };
            comm_exec as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let use_clockid: u64 = unsafe { ::std::mem::transmute(use_clockid) };
            use_clockid as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let context_switch: u64 = unsafe { ::std::mem::transmute(context_switch) };
            context_switch as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let write_backward: u64 = unsafe { ::std::mem::transmute(write_backward) };
            write_backward as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let namespaces: u64 = unsafe { ::std::mem::transmute(namespaces) };
            namespaces as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ksymbol: u64 = unsafe { ::std::mem::transmute(ksymbol) };
            ksymbol as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let bpf_event: u64 = unsafe { ::std::mem::transmute(bpf_event) };
            bpf_event as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let aux_output: u64 = unsafe { ::std::mem::transmute(aux_output) };
            aux_output as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let cgroup: u64 = unsafe { ::std::mem::transmute(cgroup) };
            cgroup as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let text_poke: u64 = unsafe { ::std::mem::transmute(text_poke) };
            text_poke as u64
        });
        __bindgen_bitfield_unit.set(34usize, 30u8, {
            let __reserved_1: u64 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_perf_event_query_bpf {
    pub ids_len: __lkl__u32,
    pub prog_cnt: __lkl__u32,
    pub ids: __IncompleteArrayField<__lkl__u32>,
}
#[test]
fn bindgen_test_layout_lkl_perf_event_query_bpf() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_event_query_bpf>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_perf_event_query_bpf))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_event_query_bpf>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_perf_event_query_bpf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_query_bpf>())).ids_len as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_query_bpf),
            "::",
            stringify!(ids_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_query_bpf>())).prog_cnt as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_query_bpf),
            "::",
            stringify!(prog_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_query_bpf>())).ids as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_query_bpf),
            "::",
            stringify!(ids)
        )
    );
}
pub const lkl_perf_event_ioc_flags_LKL_PERF_IOC_FLAG_GROUP: lkl_perf_event_ioc_flags = 1;
pub type lkl_perf_event_ioc_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_perf_event_mmap_page {
    pub version: __lkl__u32,
    pub compat_version: __lkl__u32,
    pub lock: __lkl__u32,
    pub index: __lkl__u32,
    pub offset: __lkl__s64,
    pub time_enabled: __lkl__u64,
    pub time_running: __lkl__u64,
    pub __bindgen_anon_1: lkl_perf_event_mmap_page__bindgen_ty_1,
    pub pmc_width: __lkl__u16,
    pub time_shift: __lkl__u16,
    pub time_mult: __lkl__u32,
    pub time_offset: __lkl__u64,
    pub time_zero: __lkl__u64,
    pub size: __lkl__u32,
    pub __reserved_1: __lkl__u32,
    pub time_cycles: __lkl__u64,
    pub time_mask: __lkl__u64,
    pub __reserved: [__lkl__u8; 928usize],
    pub data_head: __lkl__u64,
    pub data_tail: __lkl__u64,
    pub data_offset: __lkl__u64,
    pub data_size: __lkl__u64,
    pub aux_head: __lkl__u64,
    pub aux_tail: __lkl__u64,
    pub aux_offset: __lkl__u64,
    pub aux_size: __lkl__u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_perf_event_mmap_page__bindgen_ty_1 {
    pub capabilities: __lkl__u64,
    pub __bindgen_anon_1: lkl_perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct lkl_perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lkl_perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl lkl_perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn cap_bit0(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_bit0(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_bit0_is_deprecated(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_bit0_is_deprecated(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_rdpmc(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_rdpmc(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_time(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_time(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_time_zero(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_time_zero(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_time_short(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_time_short(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_____res(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 58u8) as u64) }
    }
    #[inline]
    pub fn set_cap_____res(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 58u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cap_bit0: __lkl__u64,
        cap_bit0_is_deprecated: __lkl__u64,
        cap_user_rdpmc: __lkl__u64,
        cap_user_time: __lkl__u64,
        cap_user_time_zero: __lkl__u64,
        cap_user_time_short: __lkl__u64,
        cap_____res: __lkl__u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cap_bit0: u64 = unsafe { ::std::mem::transmute(cap_bit0) };
            cap_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cap_bit0_is_deprecated: u64 =
                unsafe { ::std::mem::transmute(cap_bit0_is_deprecated) };
            cap_bit0_is_deprecated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cap_user_rdpmc: u64 = unsafe { ::std::mem::transmute(cap_user_rdpmc) };
            cap_user_rdpmc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cap_user_time: u64 = unsafe { ::std::mem::transmute(cap_user_time) };
            cap_user_time as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cap_user_time_zero: u64 = unsafe { ::std::mem::transmute(cap_user_time_zero) };
            cap_user_time_zero as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cap_user_time_short: u64 = unsafe { ::std::mem::transmute(cap_user_time_short) };
            cap_user_time_short as u64
        });
        __bindgen_bitfield_unit.set(6usize, 58u8, {
            let cap_____res: u64 = unsafe { ::std::mem::transmute(cap_____res) };
            cap_____res as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_lkl_perf_event_mmap_page__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_event_mmap_page__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lkl_perf_event_mmap_page__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_event_mmap_page__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_perf_event_mmap_page__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page__bindgen_ty_1>())).capabilities
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page__bindgen_ty_1),
            "::",
            stringify!(capabilities)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_perf_event_mmap_page() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_event_mmap_page>(),
        1088usize,
        concat!("Size of: ", stringify!(lkl_perf_event_mmap_page))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_event_mmap_page>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_perf_event_mmap_page))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).compat_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(compat_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).time_enabled as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(time_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).time_running as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(time_running)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).pmc_width as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(pmc_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).time_shift as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(time_shift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).time_mult as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(time_mult)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).time_offset as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(time_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).time_zero as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(time_zero)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).__reserved_1 as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(__reserved_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).time_cycles as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(time_cycles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).time_mask as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(time_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).__reserved as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).data_head as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(data_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).data_tail as *const _ as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(data_tail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).data_offset as *const _ as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).data_size as *const _ as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).aux_head as *const _ as usize
        },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(aux_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).aux_tail as *const _ as usize
        },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(aux_tail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).aux_offset as *const _ as usize
        },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(aux_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_perf_event_mmap_page>())).aux_size as *const _ as usize
        },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_mmap_page),
            "::",
            stringify!(aux_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_perf_event_header {
    pub type_: __lkl__u32,
    pub misc: __lkl__u16,
    pub size: __lkl__u16,
}
#[test]
fn bindgen_test_layout_lkl_perf_event_header() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_event_header>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_perf_event_header))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_event_header>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_perf_event_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_header>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_header),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_header>())).misc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_header),
            "::",
            stringify!(misc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_event_header>())).size as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_event_header),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_perf_ns_link_info {
    pub dev: __lkl__u64,
    pub ino: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_perf_ns_link_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_ns_link_info>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_perf_ns_link_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_ns_link_info>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_perf_ns_link_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_ns_link_info>())).dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_ns_link_info),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_ns_link_info>())).ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_ns_link_info),
            "::",
            stringify!(ino)
        )
    );
}
pub const LKL_NET_NS_INDEX: ::std::os::raw::c_uint = 0;
pub const LKL_UTS_NS_INDEX: ::std::os::raw::c_uint = 1;
pub const LKL_IPC_NS_INDEX: ::std::os::raw::c_uint = 2;
pub const LKL_PID_NS_INDEX: ::std::os::raw::c_uint = 3;
pub const LKL_USER_NS_INDEX: ::std::os::raw::c_uint = 4;
pub const LKL_MNT_NS_INDEX: ::std::os::raw::c_uint = 5;
pub const LKL_CGROUP_NS_INDEX: ::std::os::raw::c_uint = 6;
pub const LKL_NR_NAMESPACES: ::std::os::raw::c_uint = 7;
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
pub const lkl_perf_event_type_LKL_PERF_RECORD_MMAP: lkl_perf_event_type = 1;
pub const lkl_perf_event_type_LKL_PERF_RECORD_LOST: lkl_perf_event_type = 2;
pub const lkl_perf_event_type_LKL_PERF_RECORD_COMM: lkl_perf_event_type = 3;
pub const lkl_perf_event_type_LKL_PERF_RECORD_EXIT: lkl_perf_event_type = 4;
pub const lkl_perf_event_type_LKL_PERF_RECORD_THROTTLE: lkl_perf_event_type = 5;
pub const lkl_perf_event_type_LKL_PERF_RECORD_UNTHROTTLE: lkl_perf_event_type = 6;
pub const lkl_perf_event_type_LKL_PERF_RECORD_FORK: lkl_perf_event_type = 7;
pub const lkl_perf_event_type_LKL_PERF_RECORD_READ: lkl_perf_event_type = 8;
pub const lkl_perf_event_type_LKL_PERF_RECORD_SAMPLE: lkl_perf_event_type = 9;
pub const lkl_perf_event_type_LKL_PERF_RECORD_MMAP2: lkl_perf_event_type = 10;
pub const lkl_perf_event_type_LKL_PERF_RECORD_AUX: lkl_perf_event_type = 11;
pub const lkl_perf_event_type_LKL_PERF_RECORD_ITRACE_START: lkl_perf_event_type = 12;
pub const lkl_perf_event_type_LKL_PERF_RECORD_LOST_SAMPLES: lkl_perf_event_type = 13;
pub const lkl_perf_event_type_LKL_PERF_RECORD_SWITCH: lkl_perf_event_type = 14;
pub const lkl_perf_event_type_LKL_PERF_RECORD_SWITCH_CPU_WIDE: lkl_perf_event_type = 15;
pub const lkl_perf_event_type_LKL_PERF_RECORD_NAMESPACES: lkl_perf_event_type = 16;
pub const lkl_perf_event_type_LKL_PERF_RECORD_KSYMBOL: lkl_perf_event_type = 17;
pub const lkl_perf_event_type_LKL_PERF_RECORD_BPF_EVENT: lkl_perf_event_type = 18;
pub const lkl_perf_event_type_LKL_PERF_RECORD_CGROUP: lkl_perf_event_type = 19;
pub const lkl_perf_event_type_LKL_PERF_RECORD_TEXT_POKE: lkl_perf_event_type = 20;
pub const lkl_perf_event_type_LKL_PERF_RECORD_MAX: lkl_perf_event_type = 21;
pub type lkl_perf_event_type = ::std::os::raw::c_uint;
pub const lkl_perf_record_ksymbol_type_LKL_PERF_RECORD_KSYMBOL_TYPE_UNKNOWN:
    lkl_perf_record_ksymbol_type = 0;
pub const lkl_perf_record_ksymbol_type_LKL_PERF_RECORD_KSYMBOL_TYPE_BPF:
    lkl_perf_record_ksymbol_type = 1;
pub const lkl_perf_record_ksymbol_type_LKL_PERF_RECORD_KSYMBOL_TYPE_OOL:
    lkl_perf_record_ksymbol_type = 2;
pub const lkl_perf_record_ksymbol_type_LKL_PERF_RECORD_KSYMBOL_TYPE_MAX:
    lkl_perf_record_ksymbol_type = 3;
pub type lkl_perf_record_ksymbol_type = ::std::os::raw::c_uint;
pub const lkl_perf_bpf_event_type_LKL_PERF_BPF_EVENT_UNKNOWN: lkl_perf_bpf_event_type = 0;
pub const lkl_perf_bpf_event_type_LKL_PERF_BPF_EVENT_PROG_LOAD: lkl_perf_bpf_event_type = 1;
pub const lkl_perf_bpf_event_type_LKL_PERF_BPF_EVENT_PROG_UNLOAD: lkl_perf_bpf_event_type = 2;
pub const lkl_perf_bpf_event_type_LKL_PERF_BPF_EVENT_MAX: lkl_perf_bpf_event_type = 3;
pub type lkl_perf_bpf_event_type = ::std::os::raw::c_uint;
pub const lkl_perf_callchain_context_LKL_PERF_CONTEXT_HV: lkl_perf_callchain_context =
    18446744073709551584;
pub const lkl_perf_callchain_context_LKL_PERF_CONTEXT_KERNEL: lkl_perf_callchain_context =
    18446744073709551488;
pub const lkl_perf_callchain_context_LKL_PERF_CONTEXT_USER: lkl_perf_callchain_context =
    18446744073709551104;
pub const lkl_perf_callchain_context_LKL_PERF_CONTEXT_GUEST: lkl_perf_callchain_context =
    18446744073709549568;
pub const lkl_perf_callchain_context_LKL_PERF_CONTEXT_GUEST_KERNEL: lkl_perf_callchain_context =
    18446744073709549440;
pub const lkl_perf_callchain_context_LKL_PERF_CONTEXT_GUEST_USER: lkl_perf_callchain_context =
    18446744073709549056;
pub const lkl_perf_callchain_context_LKL_PERF_CONTEXT_MAX: lkl_perf_callchain_context =
    18446744073709547521;
pub type lkl_perf_callchain_context = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_perf_mem_data_src {
    pub val: __lkl__u64,
    pub __bindgen_anon_1: lkl_perf_mem_data_src__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct lkl_perf_mem_data_src__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_perf_mem_data_src__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_mem_data_src__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_perf_mem_data_src__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_mem_data_src__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_perf_mem_data_src__bindgen_ty_1)
        )
    );
}
impl lkl_perf_mem_data_src__bindgen_ty_1 {
    #[inline]
    pub fn mem_op(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_mem_op(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_lvl(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 14u8) as u64) }
    }
    #[inline]
    pub fn set_mem_lvl(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_snoop(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_mem_snoop(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_lock(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_mem_lock(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_dtlb(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_mem_dtlb(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_lvl_num(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_mem_lvl_num(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_remote(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mem_remote(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_snoopx(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_mem_snoopx(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_rsvd(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_mem_rsvd(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mem_op: __lkl__u64,
        mem_lvl: __lkl__u64,
        mem_snoop: __lkl__u64,
        mem_lock: __lkl__u64,
        mem_dtlb: __lkl__u64,
        mem_lvl_num: __lkl__u64,
        mem_remote: __lkl__u64,
        mem_snoopx: __lkl__u64,
        mem_rsvd: __lkl__u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let mem_op: u64 = unsafe { ::std::mem::transmute(mem_op) };
            mem_op as u64
        });
        __bindgen_bitfield_unit.set(5usize, 14u8, {
            let mem_lvl: u64 = unsafe { ::std::mem::transmute(mem_lvl) };
            mem_lvl as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let mem_snoop: u64 = unsafe { ::std::mem::transmute(mem_snoop) };
            mem_snoop as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let mem_lock: u64 = unsafe { ::std::mem::transmute(mem_lock) };
            mem_lock as u64
        });
        __bindgen_bitfield_unit.set(26usize, 7u8, {
            let mem_dtlb: u64 = unsafe { ::std::mem::transmute(mem_dtlb) };
            mem_dtlb as u64
        });
        __bindgen_bitfield_unit.set(33usize, 4u8, {
            let mem_lvl_num: u64 = unsafe { ::std::mem::transmute(mem_lvl_num) };
            mem_lvl_num as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let mem_remote: u64 = unsafe { ::std::mem::transmute(mem_remote) };
            mem_remote as u64
        });
        __bindgen_bitfield_unit.set(38usize, 2u8, {
            let mem_snoopx: u64 = unsafe { ::std::mem::transmute(mem_snoopx) };
            mem_snoopx as u64
        });
        __bindgen_bitfield_unit.set(40usize, 24u8, {
            let mem_rsvd: u64 = unsafe { ::std::mem::transmute(mem_rsvd) };
            mem_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_lkl_perf_mem_data_src() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_mem_data_src>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_perf_mem_data_src))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_mem_data_src>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_perf_mem_data_src))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_mem_data_src>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_mem_data_src),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_perf_branch_entry {
    pub from: __lkl__u64,
    pub to: __lkl__u64,
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_lkl_perf_branch_entry() {
    assert_eq!(
        ::std::mem::size_of::<lkl_perf_branch_entry>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_perf_branch_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_perf_branch_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_perf_branch_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_branch_entry>())).from as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_branch_entry),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_perf_branch_entry>())).to as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_perf_branch_entry),
            "::",
            stringify!(to)
        )
    );
}
impl lkl_perf_branch_entry {
    #[inline]
    pub fn mispred(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mispred(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn predicted(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_predicted(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_tx(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_in_tx(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn abort(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_abort(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cycles(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_cycles(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __lkl__u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 40u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __lkl__u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 40u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mispred: __lkl__u64,
        predicted: __lkl__u64,
        in_tx: __lkl__u64,
        abort: __lkl__u64,
        cycles: __lkl__u64,
        type_: __lkl__u64,
        reserved: __lkl__u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mispred: u64 = unsafe { ::std::mem::transmute(mispred) };
            mispred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let predicted: u64 = unsafe { ::std::mem::transmute(predicted) };
            predicted as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_tx: u64 = unsafe { ::std::mem::transmute(in_tx) };
            in_tx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let abort: u64 = unsafe { ::std::mem::transmute(abort) };
            abort as u64
        });
        __bindgen_bitfield_unit.set(4usize, 16u8, {
            let cycles: u64 = unsafe { ::std::mem::transmute(cycles) };
            cycles as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let type_: u64 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(24usize, 40u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_semid_ds {
    pub sem_perm: ipc_perm,
    pub sem_otime: __lkl__kernel_old_time_t,
    pub sem_ctime: __lkl__kernel_old_time_t,
    pub sem_base: *mut sem,
    pub sem_pending: *mut sem_queue,
    pub sem_pending_last: *mut *mut sem_queue,
    pub undo: *mut sem_undo,
    pub sem_nsems: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_lkl_semid_ds() {
    assert_eq!(
        ::std::mem::size_of::<lkl_semid_ds>(),
        88usize,
        concat!("Size of: ", stringify!(lkl_semid_ds))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_semid_ds>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_semid_ds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid_ds>())).sem_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid_ds),
            "::",
            stringify!(sem_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid_ds>())).sem_otime as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid_ds),
            "::",
            stringify!(sem_otime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid_ds>())).sem_ctime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid_ds),
            "::",
            stringify!(sem_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid_ds>())).sem_base as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid_ds),
            "::",
            stringify!(sem_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid_ds>())).sem_pending as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid_ds),
            "::",
            stringify!(sem_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid_ds>())).sem_pending_last as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid_ds),
            "::",
            stringify!(sem_pending_last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid_ds>())).undo as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid_ds),
            "::",
            stringify!(undo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid_ds>())).sem_nsems as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid_ds),
            "::",
            stringify!(sem_nsems)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_semid64_ds {
    pub sem_perm: lkl_ipc64_perm,
    pub sem_otime: ::std::os::raw::c_long,
    pub sem_ctime: ::std::os::raw::c_long,
    pub sem_nsems: ::std::os::raw::c_ulong,
    pub __unused3: ::std::os::raw::c_ulong,
    pub __unused4: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_lkl_semid64_ds() {
    assert_eq!(
        ::std::mem::size_of::<lkl_semid64_ds>(),
        88usize,
        concat!("Size of: ", stringify!(lkl_semid64_ds))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_semid64_ds>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_semid64_ds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid64_ds>())).sem_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid64_ds),
            "::",
            stringify!(sem_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid64_ds>())).sem_otime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid64_ds),
            "::",
            stringify!(sem_otime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid64_ds>())).sem_ctime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid64_ds),
            "::",
            stringify!(sem_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid64_ds>())).sem_nsems as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid64_ds),
            "::",
            stringify!(sem_nsems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid64_ds>())).__unused3 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid64_ds),
            "::",
            stringify!(__unused3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semid64_ds>())).__unused4 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semid64_ds),
            "::",
            stringify!(__unused4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_sembuf {
    pub sem_num: ::std::os::raw::c_ushort,
    pub sem_op: ::std::os::raw::c_short,
    pub sem_flg: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_lkl_sembuf() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sembuf>(),
        6usize,
        concat!("Size of: ", stringify!(lkl_sembuf))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sembuf>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_sembuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sembuf>())).sem_num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sembuf),
            "::",
            stringify!(sem_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sembuf>())).sem_op as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sembuf),
            "::",
            stringify!(sem_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sembuf>())).sem_flg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sembuf),
            "::",
            stringify!(sem_flg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_semun {
    pub val: ::std::os::raw::c_int,
    pub buf: *mut lkl_semid_ds,
    pub array: *mut ::std::os::raw::c_ushort,
    pub __buf: *mut lkl_seminfo,
    pub __pad: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lkl_semun() {
    assert_eq!(
        ::std::mem::size_of::<lkl_semun>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_semun))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_semun>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_semun))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semun>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semun),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semun>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semun),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semun>())).array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semun),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semun>())).__buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semun),
            "::",
            stringify!(__buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_semun>())).__pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_semun),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_seminfo {
    pub semmap: ::std::os::raw::c_int,
    pub semmni: ::std::os::raw::c_int,
    pub semmns: ::std::os::raw::c_int,
    pub semmnu: ::std::os::raw::c_int,
    pub semmsl: ::std::os::raw::c_int,
    pub semopm: ::std::os::raw::c_int,
    pub semume: ::std::os::raw::c_int,
    pub semusz: ::std::os::raw::c_int,
    pub semvmx: ::std::os::raw::c_int,
    pub semaem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lkl_seminfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_seminfo>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_seminfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_seminfo>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_seminfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_seminfo>())).semmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_seminfo),
            "::",
            stringify!(semmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_seminfo>())).semmni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_seminfo),
            "::",
            stringify!(semmni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_seminfo>())).semmns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_seminfo),
            "::",
            stringify!(semmns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_seminfo>())).semmnu as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_seminfo),
            "::",
            stringify!(semmnu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_seminfo>())).semmsl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_seminfo),
            "::",
            stringify!(semmsl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_seminfo>())).semopm as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_seminfo),
            "::",
            stringify!(semopm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_seminfo>())).semume as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_seminfo),
            "::",
            stringify!(semume)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_seminfo>())).semusz as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_seminfo),
            "::",
            stringify!(semusz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_seminfo>())).semvmx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_seminfo),
            "::",
            stringify!(semvmx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_seminfo>())).semaem as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_seminfo),
            "::",
            stringify!(semaem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_robust_list {
    pub next: *mut lkl_robust_list,
}
#[test]
fn bindgen_test_layout_lkl_robust_list() {
    assert_eq!(
        ::std::mem::size_of::<lkl_robust_list>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_robust_list))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_robust_list>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_robust_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_robust_list>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_robust_list),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_robust_list_head {
    pub list: lkl_robust_list,
    pub futex_offset: ::std::os::raw::c_long,
    pub list_op_pending: *mut lkl_robust_list,
}
#[test]
fn bindgen_test_layout_lkl_robust_list_head() {
    assert_eq!(
        ::std::mem::size_of::<lkl_robust_list_head>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_robust_list_head))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_robust_list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_robust_list_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_robust_list_head>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_robust_list_head),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_robust_list_head>())).futex_offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_robust_list_head),
            "::",
            stringify!(futex_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_robust_list_head>())).list_op_pending as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_robust_list_head),
            "::",
            stringify!(list_op_pending)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_pollfd {
    pub fd: ::std::os::raw::c_int,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_lkl_pollfd() {
    assert_eq!(
        ::std::mem::size_of::<lkl_pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_pollfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_pollfd>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_pollfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_pollfd>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_pollfd),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_pollfd>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_pollfd),
            "::",
            stringify!(revents)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_mq_attr {
    pub mq_flags: __lkl__kernel_long_t,
    pub mq_maxmsg: __lkl__kernel_long_t,
    pub mq_msgsize: __lkl__kernel_long_t,
    pub mq_curmsgs: __lkl__kernel_long_t,
    pub __reserved: [__lkl__kernel_long_t; 4usize],
}
#[test]
fn bindgen_test_layout_lkl_mq_attr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_mq_attr>(),
        64usize,
        concat!("Size of: ", stringify!(lkl_mq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_mq_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_mq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_mq_attr>())).mq_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_mq_attr),
            "::",
            stringify!(mq_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_mq_attr>())).mq_maxmsg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_mq_attr),
            "::",
            stringify!(mq_maxmsg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_mq_attr>())).mq_msgsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_mq_attr),
            "::",
            stringify!(mq_msgsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_mq_attr>())).mq_curmsgs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_mq_attr),
            "::",
            stringify!(mq_curmsgs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_mq_attr>())).__reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_mq_attr),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_epoll_event {
    pub events: __lkl__poll_t,
    pub data: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_epoll_event() {
    assert_eq!(
        ::std::mem::size_of::<lkl_epoll_event>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_epoll_event))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_epoll_event>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_epoll_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_epoll_event>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_epoll_event),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_epoll_event>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_epoll_event),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: __lkl__kernel_size_t,
}
#[test]
fn bindgen_test_layout_lkl_iovec() {
    assert_eq!(
        ::std::mem::size_of::<lkl_iovec>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_sigset_t {
    pub sig: [::std::os::raw::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_lkl_sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sigset_t>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigset_t>())).sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigset_t),
            "::",
            stringify!(sig)
        )
    );
}
pub type lkl_old_sigset_t = ::std::os::raw::c_ulong;
pub type __lkl__signalfn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __lkl__sighandler_t = __lkl__signalfn_t;
pub type __lkl__restorefn_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type __lkl__sigrestore_t = __lkl__restorefn_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_sigaction {
    pub lkl_sa_handler: __lkl__sighandler_t,
    pub sa_flags: ::std::os::raw::c_ulong,
    pub sa_mask: lkl_sigset_t,
}
#[test]
fn bindgen_test_layout_lkl_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigaction>())).lkl_sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigaction),
            "::",
            stringify!(lkl_sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigaction>())).sa_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigaction>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: lkl_size_t,
}
#[test]
fn bindgen_test_layout_lkl_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigaltstack>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigaltstack>())).ss_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type lkl_stack_t = lkl_sigaltstack;
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lkl_sigval() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sigval>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type lkl_sigval_t = lkl_sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __lkl__sifields {
    pub _kill: __lkl__sifields__bindgen_ty_1,
    pub _timer: __lkl__sifields__bindgen_ty_2,
    pub _rt: __lkl__sifields__bindgen_ty_3,
    pub _sigchld: __lkl__sifields__bindgen_ty_4,
    pub _sigfault: __lkl__sifields__bindgen_ty_5,
    pub _sigpoll: __lkl__sifields__bindgen_ty_6,
    pub _sigsys: __lkl__sifields__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__sifields__bindgen_ty_1 {
    pub _pid: __lkl__kernel_pid_t,
    pub _uid: __lkl__kernel_uid32_t,
}
#[test]
fn bindgen_test_layout___lkl__sifields__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sifields__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__lkl__sifields__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sifields__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__lkl__sifields__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_1>()))._pid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_1),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_1>()))._uid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_1),
            "::",
            stringify!(_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lkl__sifields__bindgen_ty_2 {
    pub _tid: __lkl__kernel_timer_t,
    pub _overrun: ::std::os::raw::c_int,
    pub _sigval: lkl_sigval_t,
    pub _sys_private: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___lkl__sifields__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sifields__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(__lkl__sifields__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sifields__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__sifields__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_2>()))._tid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_2),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_2>()))._overrun as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_2),
            "::",
            stringify!(_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_2>()))._sigval as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_2),
            "::",
            stringify!(_sigval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_2>()))._sys_private as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_2),
            "::",
            stringify!(_sys_private)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lkl__sifields__bindgen_ty_3 {
    pub _pid: __lkl__kernel_pid_t,
    pub _uid: __lkl__kernel_uid32_t,
    pub _sigval: lkl_sigval_t,
}
#[test]
fn bindgen_test_layout___lkl__sifields__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sifields__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(__lkl__sifields__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sifields__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__sifields__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_3>()))._pid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_3),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_3>()))._uid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_3),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_3>()))._sigval as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_3),
            "::",
            stringify!(_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__sifields__bindgen_ty_4 {
    pub _pid: __lkl__kernel_pid_t,
    pub _uid: __lkl__kernel_uid32_t,
    pub _status: ::std::os::raw::c_int,
    pub _utime: __lkl__kernel_clock_t,
    pub _stime: __lkl__kernel_clock_t,
}
#[test]
fn bindgen_test_layout___lkl__sifields__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sifields__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(__lkl__sifields__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sifields__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__sifields__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_4>()))._pid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_4),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_4>()))._uid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_4),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_4>()))._status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_4),
            "::",
            stringify!(_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_4>()))._utime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_4),
            "::",
            stringify!(_utime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_4>()))._stime as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_4),
            "::",
            stringify!(_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lkl__sifields__bindgen_ty_5 {
    pub _addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: __lkl__sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __lkl__sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_lsb: ::std::os::raw::c_short,
    pub _addr_bnd: __lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [::std::os::raw::c_char; 8usize],
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))
                ._dummy_bnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_dummy_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))
                ._lower as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))
                ._upper as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [::std::os::raw::c_char; 8usize],
    pub _pkey: __lkl__u32,
}
#[test]
fn bindgen_test_layout___lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))
                ._dummy_pkey as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_dummy_pkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))
                ._pkey as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout___lkl__sifields__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_lsb
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_bnd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_pkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout___lkl__sifields__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sifields__bindgen_ty_5>(),
        32usize,
        concat!("Size of: ", stringify!(__lkl__sifields__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sifields__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__sifields__bindgen_ty_5))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_5>()))._addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_5),
            "::",
            stringify!(_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__sifields__bindgen_ty_6 {
    pub _band: ::std::os::raw::c_long,
    pub _fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___lkl__sifields__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sifields__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(__lkl__sifields__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sifields__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__sifields__bindgen_ty_6))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_6>()))._band as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_6),
            "::",
            stringify!(_band)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_6>()))._fd as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_6),
            "::",
            stringify!(_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lkl__sifields__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___lkl__sifields__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sifields__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(__lkl__sifields__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sifields__bindgen_ty_7>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__sifields__bindgen_ty_7))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_7>()))._call_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_7>()))._syscall as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__lkl__sifields__bindgen_ty_7>()))._arch as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout___lkl__sifields() {
    assert_eq!(
        ::std::mem::size_of::<__lkl__sifields>(),
        32usize,
        concat!("Size of: ", stringify!(__lkl__sifields))
    );
    assert_eq!(
        ::std::mem::align_of::<__lkl__sifields>(),
        8usize,
        concat!("Alignment of ", stringify!(__lkl__sifields))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sifields>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sifields>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sifields>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sifields>()))._sigchld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sifields>()))._sigfault as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sifields>()))._sigpoll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lkl__sifields>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lkl__sifields),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_siginfo {
    pub __bindgen_anon_1: lkl_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_siginfo__bindgen_ty_1 {
    pub __bindgen_anon_1: lkl_siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _si_pad: [::std::os::raw::c_int; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: __lkl__sifields,
}
#[test]
fn bindgen_test_layout_lkl_siginfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_siginfo__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(lkl_siginfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_siginfo__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_siginfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_siginfo__bindgen_ty_1__bindgen_ty_1>())).si_signo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_siginfo__bindgen_ty_1__bindgen_ty_1>())).si_errno as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_siginfo__bindgen_ty_1__bindgen_ty_1>())).si_code as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_siginfo__bindgen_ty_1__bindgen_ty_1>()))._sifields
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_sifields)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_siginfo__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_siginfo__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(lkl_siginfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_siginfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_siginfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_siginfo__bindgen_ty_1>()))._si_pad as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_siginfo__bindgen_ty_1),
            "::",
            stringify!(_si_pad)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_siginfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_siginfo>(),
        128usize,
        concat!("Size of: ", stringify!(lkl_siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_siginfo))
    );
}
pub type lkl_siginfo_t = lkl_siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_sigevent {
    pub sigev_value: lkl_sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: lkl_sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: ::std::os::raw::c_int,
    pub _sigev_thread: lkl_sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: lkl_sigval_t)>,
    pub _attribute: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lkl_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(lkl_sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_sigevent__bindgen_ty_1__bindgen_ty_1>()))._function
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(lkl_sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigevent__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigevent__bindgen_ty_1>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_sigevent__bindgen_ty_1>()))._sigev_thread as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(lkl_sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigevent>())).sigev_signo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigevent>())).sigev_notify as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sigevent>()))._sigev_un as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type lkl_sigevent_t = lkl_sigevent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_utimbuf {
    pub actime: __lkl__kernel_old_time_t,
    pub modtime: __lkl__kernel_old_time_t,
}
#[test]
fn bindgen_test_layout_lkl_utimbuf() {
    assert_eq!(
        ::std::mem::size_of::<lkl_utimbuf>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_utimbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_utimbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_utimbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_utimbuf>())).actime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_utimbuf),
            "::",
            stringify!(actime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_utimbuf>())).modtime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_utimbuf),
            "::",
            stringify!(modtime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_icmphdr {
    pub type_: __lkl__u8,
    pub code: __lkl__u8,
    pub checksum: __lkl__sum16,
    pub un: lkl_icmphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_icmphdr__bindgen_ty_1 {
    pub echo: lkl_icmphdr__bindgen_ty_1__bindgen_ty_1,
    pub gateway: __lkl__be32,
    pub frag: lkl_icmphdr__bindgen_ty_1__bindgen_ty_2,
    pub reserved: [__lkl__u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_icmphdr__bindgen_ty_1__bindgen_ty_1 {
    pub id: __lkl__be16,
    pub sequence: __lkl__be16,
}
#[test]
fn bindgen_test_layout_lkl_icmphdr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_icmphdr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_icmphdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_icmphdr__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_icmphdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_icmphdr__bindgen_ty_1__bindgen_ty_1>())).id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_icmphdr__bindgen_ty_1__bindgen_ty_1>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_icmphdr__bindgen_ty_1__bindgen_ty_2 {
    pub __unused: __lkl__be16,
    pub mtu: __lkl__be16,
}
#[test]
fn bindgen_test_layout_lkl_icmphdr__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_icmphdr__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_icmphdr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_icmphdr__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_icmphdr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_icmphdr__bindgen_ty_1__bindgen_ty_2>())).__unused as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(__unused)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_icmphdr__bindgen_ty_1__bindgen_ty_2>())).mtu as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mtu)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_icmphdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_icmphdr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_icmphdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_icmphdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_icmphdr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmphdr__bindgen_ty_1>())).echo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr__bindgen_ty_1),
            "::",
            stringify!(echo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_icmphdr__bindgen_ty_1>())).gateway as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr__bindgen_ty_1),
            "::",
            stringify!(gateway)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmphdr__bindgen_ty_1>())).frag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr__bindgen_ty_1),
            "::",
            stringify!(frag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_icmphdr__bindgen_ty_1>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_icmphdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_icmphdr>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_icmphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_icmphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_icmphdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmphdr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmphdr>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmphdr>())).checksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmphdr>())).un as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmphdr),
            "::",
            stringify!(un)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_icmp_filter {
    pub data: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_icmp_filter() {
    assert_eq!(
        ::std::mem::size_of::<lkl_icmp_filter>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_icmp_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_icmp_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_icmp_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmp_filter>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmp_filter),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_icmp_ext_hdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved2: __lkl__u8,
    pub checksum: __lkl__sum16,
}
#[test]
fn bindgen_test_layout_lkl_icmp_ext_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_icmp_ext_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_icmp_ext_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_icmp_ext_hdr>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_icmp_ext_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmp_ext_hdr>())).reserved2 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmp_ext_hdr),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmp_ext_hdr>())).checksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmp_ext_hdr),
            "::",
            stringify!(checksum)
        )
    );
}
impl lkl_icmp_ext_hdr {
    #[inline]
    pub fn reserved1(&self) -> __lkl__u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: __lkl__u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> __lkl__u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: __lkl__u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved1: __lkl__u8,
        version: __lkl__u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let reserved1: u8 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_icmp_extobj_hdr {
    pub length: __lkl__be16,
    pub class_num: __lkl__u8,
    pub class_type: __lkl__u8,
}
#[test]
fn bindgen_test_layout_lkl_icmp_extobj_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_icmp_extobj_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_icmp_extobj_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_icmp_extobj_hdr>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_icmp_extobj_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmp_extobj_hdr>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmp_extobj_hdr),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmp_extobj_hdr>())).class_num as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmp_extobj_hdr),
            "::",
            stringify!(class_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_icmp_extobj_hdr>())).class_type as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_icmp_extobj_hdr),
            "::",
            stringify!(class_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_iphdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tos: __lkl__u8,
    pub tot_len: __lkl__be16,
    pub id: __lkl__be16,
    pub frag_off: __lkl__be16,
    pub ttl: __lkl__u8,
    pub protocol: __lkl__u8,
    pub check: __lkl__sum16,
    pub saddr: __lkl__be32,
    pub daddr: __lkl__be32,
}
#[test]
fn bindgen_test_layout_lkl_iphdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_iphdr>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_iphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_iphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_iphdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iphdr>())).tos as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iphdr),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iphdr>())).tot_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iphdr),
            "::",
            stringify!(tot_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iphdr>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iphdr),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iphdr>())).frag_off as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iphdr),
            "::",
            stringify!(frag_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iphdr>())).ttl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iphdr),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iphdr>())).protocol as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iphdr),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iphdr>())).check as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iphdr),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iphdr>())).saddr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iphdr),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_iphdr>())).daddr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_iphdr),
            "::",
            stringify!(daddr)
        )
    );
}
impl lkl_iphdr {
    #[inline]
    pub fn ihl(&self) -> __lkl__u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: __lkl__u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> __lkl__u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: __lkl__u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ihl: __lkl__u8,
        version: __lkl__u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u8 = unsafe { ::std::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_ip_auth_hdr {
    pub nexthdr: __lkl__u8,
    pub hdrlen: __lkl__u8,
    pub reserved: __lkl__be16,
    pub spi: __lkl__be32,
    pub seq_no: __lkl__be32,
    pub auth_data: __IncompleteArrayField<__lkl__u8>,
}
#[test]
fn bindgen_test_layout_lkl_ip_auth_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ip_auth_hdr>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_ip_auth_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ip_auth_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ip_auth_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_auth_hdr>())).nexthdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_auth_hdr),
            "::",
            stringify!(nexthdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_auth_hdr>())).hdrlen as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_auth_hdr),
            "::",
            stringify!(hdrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_auth_hdr>())).reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_auth_hdr),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_auth_hdr>())).spi as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_auth_hdr),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_auth_hdr>())).seq_no as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_auth_hdr),
            "::",
            stringify!(seq_no)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_auth_hdr>())).auth_data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_auth_hdr),
            "::",
            stringify!(auth_data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_ip_esp_hdr {
    pub spi: __lkl__be32,
    pub seq_no: __lkl__be32,
    pub enc_data: __IncompleteArrayField<__lkl__u8>,
}
#[test]
fn bindgen_test_layout_lkl_ip_esp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ip_esp_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ip_esp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ip_esp_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ip_esp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_esp_hdr>())).spi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_esp_hdr),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_esp_hdr>())).seq_no as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_esp_hdr),
            "::",
            stringify!(seq_no)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_esp_hdr>())).enc_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_esp_hdr),
            "::",
            stringify!(enc_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ip_comp_hdr {
    pub nexthdr: __lkl__u8,
    pub flags: __lkl__u8,
    pub cpi: __lkl__be16,
}
#[test]
fn bindgen_test_layout_lkl_ip_comp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ip_comp_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_ip_comp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ip_comp_hdr>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_ip_comp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_comp_hdr>())).nexthdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_comp_hdr),
            "::",
            stringify!(nexthdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_comp_hdr>())).flags as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_comp_hdr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_comp_hdr>())).cpi as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_comp_hdr),
            "::",
            stringify!(cpi)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ip_beet_phdr {
    pub nexthdr: __lkl__u8,
    pub hdrlen: __lkl__u8,
    pub padlen: __lkl__u8,
    pub reserved: __lkl__u8,
}
#[test]
fn bindgen_test_layout_lkl_ip_beet_phdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ip_beet_phdr>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_ip_beet_phdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ip_beet_phdr>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_ip_beet_phdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_beet_phdr>())).nexthdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_beet_phdr),
            "::",
            stringify!(nexthdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_beet_phdr>())).hdrlen as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_beet_phdr),
            "::",
            stringify!(hdrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_beet_phdr>())).padlen as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_beet_phdr),
            "::",
            stringify!(padlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_beet_phdr>())).reserved as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_beet_phdr),
            "::",
            stringify!(reserved)
        )
    );
}
pub const LKL_IPV4_DEVCONF_FORWARDING: ::std::os::raw::c_uint = 1;
pub const LKL_IPV4_DEVCONF_MC_FORWARDING: ::std::os::raw::c_uint = 2;
pub const LKL_IPV4_DEVCONF_PROXY_ARP: ::std::os::raw::c_uint = 3;
pub const LKL_IPV4_DEVCONF_ACCEPT_REDIRECTS: ::std::os::raw::c_uint = 4;
pub const LKL_IPV4_DEVCONF_SECURE_REDIRECTS: ::std::os::raw::c_uint = 5;
pub const LKL_IPV4_DEVCONF_SEND_REDIRECTS: ::std::os::raw::c_uint = 6;
pub const LKL_IPV4_DEVCONF_SHARED_MEDIA: ::std::os::raw::c_uint = 7;
pub const LKL_IPV4_DEVCONF_RP_FILTER: ::std::os::raw::c_uint = 8;
pub const LKL_IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE: ::std::os::raw::c_uint = 9;
pub const LKL_IPV4_DEVCONF_BOOTP_RELAY: ::std::os::raw::c_uint = 10;
pub const LKL_IPV4_DEVCONF_LOG_MARTIANS: ::std::os::raw::c_uint = 11;
pub const LKL_IPV4_DEVCONF_TAG: ::std::os::raw::c_uint = 12;
pub const LKL_IPV4_DEVCONF_ARPFILTER: ::std::os::raw::c_uint = 13;
pub const LKL_IPV4_DEVCONF_MEDIUM_ID: ::std::os::raw::c_uint = 14;
pub const LKL_IPV4_DEVCONF_NOXFRM: ::std::os::raw::c_uint = 15;
pub const LKL_IPV4_DEVCONF_NOPOLICY: ::std::os::raw::c_uint = 16;
pub const LKL_IPV4_DEVCONF_FORCE_IGMP_VERSION: ::std::os::raw::c_uint = 17;
pub const LKL_IPV4_DEVCONF_ARP_ANNOUNCE: ::std::os::raw::c_uint = 18;
pub const LKL_IPV4_DEVCONF_ARP_IGNORE: ::std::os::raw::c_uint = 19;
pub const LKL_IPV4_DEVCONF_PROMOTE_SECONDARIES: ::std::os::raw::c_uint = 20;
pub const LKL_IPV4_DEVCONF_ARP_ACCEPT: ::std::os::raw::c_uint = 21;
pub const LKL_IPV4_DEVCONF_ARP_NOTIFY: ::std::os::raw::c_uint = 22;
pub const LKL_IPV4_DEVCONF_ACCEPT_LOCAL: ::std::os::raw::c_uint = 23;
pub const LKL_IPV4_DEVCONF_SRC_VMARK: ::std::os::raw::c_uint = 24;
pub const LKL_IPV4_DEVCONF_PROXY_ARP_PVLAN: ::std::os::raw::c_uint = 25;
pub const LKL_IPV4_DEVCONF_ROUTE_LOCALNET: ::std::os::raw::c_uint = 26;
pub const LKL_IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL: ::std::os::raw::c_uint = 27;
pub const LKL_IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL: ::std::os::raw::c_uint = 28;
pub const LKL_IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN: ::std::os::raw::c_uint = 29;
pub const LKL_IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST: ::std::os::raw::c_uint = 30;
pub const LKL_IPV4_DEVCONF_DROP_GRATUITOUS_ARP: ::std::os::raw::c_uint = 31;
pub const LKL_IPV4_DEVCONF_BC_FORWARDING: ::std::os::raw::c_uint = 32;
pub const __LKL__IPV4_DEVCONF_MAX: ::std::os::raw::c_uint = 33;
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_sockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_lkl_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
pub const MSG_OOB: ::std::os::raw::c_uint = 1;
pub const MSG_PEEK: ::std::os::raw::c_uint = 2;
pub const MSG_DONTROUTE: ::std::os::raw::c_uint = 4;
pub const MSG_CTRUNC: ::std::os::raw::c_uint = 8;
pub const MSG_PROXY: ::std::os::raw::c_uint = 16;
pub const MSG_TRUNC: ::std::os::raw::c_uint = 32;
pub const MSG_DONTWAIT: ::std::os::raw::c_uint = 64;
pub const MSG_EOR: ::std::os::raw::c_uint = 128;
pub const MSG_WAITALL: ::std::os::raw::c_uint = 256;
pub const MSG_FIN: ::std::os::raw::c_uint = 512;
pub const MSG_SYN: ::std::os::raw::c_uint = 1024;
pub const MSG_CONFIRM: ::std::os::raw::c_uint = 2048;
pub const MSG_RST: ::std::os::raw::c_uint = 4096;
pub const MSG_ERRQUEUE: ::std::os::raw::c_uint = 8192;
pub const MSG_NOSIGNAL: ::std::os::raw::c_uint = 16384;
pub const MSG_MORE: ::std::os::raw::c_uint = 32768;
pub const MSG_WAITFORONE: ::std::os::raw::c_uint = 65536;
pub const MSG_BATCH: ::std::os::raw::c_uint = 262144;
pub const MSG_ZEROCOPY: ::std::os::raw::c_uint = 67108864;
pub const MSG_FASTOPEN: ::std::os::raw::c_uint = 536870912;
pub const MSG_CMSG_CLOEXEC: ::std::os::raw::c_uint = 1073741824;
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: size_t,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: size_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: size_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).__cmsg_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub const SHUT_RD: ::std::os::raw::c_uint = 0;
pub const SHUT_WR: ::std::os::raw::c_uint = 1;
pub const SHUT_RDWR: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: size_t,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_sync_serial_settings {
    pub clock_rate: ::std::os::raw::c_uint,
    pub clock_type: ::std::os::raw::c_uint,
    pub loopback: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_lkl_sync_serial_settings() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sync_serial_settings>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_sync_serial_settings))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sync_serial_settings>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_sync_serial_settings))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_sync_serial_settings>())).clock_rate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sync_serial_settings),
            "::",
            stringify!(clock_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_sync_serial_settings>())).clock_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sync_serial_settings),
            "::",
            stringify!(clock_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_sync_serial_settings>())).loopback as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sync_serial_settings),
            "::",
            stringify!(loopback)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_te1_settings {
    pub clock_rate: ::std::os::raw::c_uint,
    pub clock_type: ::std::os::raw::c_uint,
    pub loopback: ::std::os::raw::c_ushort,
    pub slot_map: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_te1_settings() {
    assert_eq!(
        ::std::mem::size_of::<lkl_te1_settings>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_te1_settings))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_te1_settings>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_te1_settings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_te1_settings>())).clock_rate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_te1_settings),
            "::",
            stringify!(clock_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_te1_settings>())).clock_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_te1_settings),
            "::",
            stringify!(clock_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_te1_settings>())).loopback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_te1_settings),
            "::",
            stringify!(loopback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_te1_settings>())).slot_map as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_te1_settings),
            "::",
            stringify!(slot_map)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_raw_hdlc_proto {
    pub encoding: ::std::os::raw::c_ushort,
    pub parity: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_lkl_raw_hdlc_proto() {
    assert_eq!(
        ::std::mem::size_of::<lkl_raw_hdlc_proto>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_raw_hdlc_proto))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_raw_hdlc_proto>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_raw_hdlc_proto))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_raw_hdlc_proto>())).encoding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_raw_hdlc_proto),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_raw_hdlc_proto>())).parity as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_raw_hdlc_proto),
            "::",
            stringify!(parity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_fr_proto {
    pub t391: ::std::os::raw::c_uint,
    pub t392: ::std::os::raw::c_uint,
    pub n391: ::std::os::raw::c_uint,
    pub n392: ::std::os::raw::c_uint,
    pub n393: ::std::os::raw::c_uint,
    pub lmi: ::std::os::raw::c_ushort,
    pub dce: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_lkl_fr_proto() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fr_proto>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_fr_proto))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fr_proto>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_fr_proto))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fr_proto>())).t391 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fr_proto),
            "::",
            stringify!(t391)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fr_proto>())).t392 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fr_proto),
            "::",
            stringify!(t392)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fr_proto>())).n391 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fr_proto),
            "::",
            stringify!(n391)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fr_proto>())).n392 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fr_proto),
            "::",
            stringify!(n392)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fr_proto>())).n393 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fr_proto),
            "::",
            stringify!(n393)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fr_proto>())).lmi as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fr_proto),
            "::",
            stringify!(lmi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fr_proto>())).dce as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fr_proto),
            "::",
            stringify!(dce)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_fr_proto_pvc {
    pub dlci: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_fr_proto_pvc() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fr_proto_pvc>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_fr_proto_pvc))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fr_proto_pvc>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_fr_proto_pvc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fr_proto_pvc>())).dlci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fr_proto_pvc),
            "::",
            stringify!(dlci)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_fr_proto_pvc_info {
    pub dlci: ::std::os::raw::c_uint,
    pub master: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_lkl_fr_proto_pvc_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fr_proto_pvc_info>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_fr_proto_pvc_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fr_proto_pvc_info>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_fr_proto_pvc_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fr_proto_pvc_info>())).dlci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fr_proto_pvc_info),
            "::",
            stringify!(dlci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fr_proto_pvc_info>())).master as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fr_proto_pvc_info),
            "::",
            stringify!(master)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_cisco_proto {
    pub interval: ::std::os::raw::c_uint,
    pub timeout: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_cisco_proto() {
    assert_eq!(
        ::std::mem::size_of::<lkl_cisco_proto>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_cisco_proto))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_cisco_proto>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_cisco_proto))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_cisco_proto>())).interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_cisco_proto),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_cisco_proto>())).timeout as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_cisco_proto),
            "::",
            stringify!(timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_x25_hdlc_proto {
    pub dce: ::std::os::raw::c_ushort,
    pub modulo: ::std::os::raw::c_uint,
    pub window: ::std::os::raw::c_uint,
    pub t1: ::std::os::raw::c_uint,
    pub t2: ::std::os::raw::c_uint,
    pub n2: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_x25_hdlc_proto() {
    assert_eq!(
        ::std::mem::size_of::<lkl_x25_hdlc_proto>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_x25_hdlc_proto))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_x25_hdlc_proto>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_x25_hdlc_proto))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_x25_hdlc_proto>())).dce as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_x25_hdlc_proto),
            "::",
            stringify!(dce)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_x25_hdlc_proto>())).modulo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_x25_hdlc_proto),
            "::",
            stringify!(modulo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_x25_hdlc_proto>())).window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_x25_hdlc_proto),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_x25_hdlc_proto>())).t1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_x25_hdlc_proto),
            "::",
            stringify!(t1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_x25_hdlc_proto>())).t2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_x25_hdlc_proto),
            "::",
            stringify!(t2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_x25_hdlc_proto>())).n2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_x25_hdlc_proto),
            "::",
            stringify!(n2)
        )
    );
}
pub const lkl_net_device_flags_LKL_IFF_UP: lkl_net_device_flags = 1;
pub const lkl_net_device_flags_LKL_IFF_BROADCAST: lkl_net_device_flags = 2;
pub const lkl_net_device_flags_LKL_IFF_DEBUG: lkl_net_device_flags = 4;
pub const lkl_net_device_flags_LKL_IFF_LOOPBACK: lkl_net_device_flags = 8;
pub const lkl_net_device_flags_LKL_IFF_POINTOPOINT: lkl_net_device_flags = 16;
pub const lkl_net_device_flags_LKL_IFF_NOTRAILERS: lkl_net_device_flags = 32;
pub const lkl_net_device_flags_LKL_IFF_RUNNING: lkl_net_device_flags = 64;
pub const lkl_net_device_flags_LKL_IFF_NOARP: lkl_net_device_flags = 128;
pub const lkl_net_device_flags_LKL_IFF_PROMISC: lkl_net_device_flags = 256;
pub const lkl_net_device_flags_LKL_IFF_ALLMULTI: lkl_net_device_flags = 512;
pub const lkl_net_device_flags_LKL_IFF_MASTER: lkl_net_device_flags = 1024;
pub const lkl_net_device_flags_LKL_IFF_SLAVE: lkl_net_device_flags = 2048;
pub const lkl_net_device_flags_LKL_IFF_MULTICAST: lkl_net_device_flags = 4096;
pub const lkl_net_device_flags_LKL_IFF_PORTSEL: lkl_net_device_flags = 8192;
pub const lkl_net_device_flags_LKL_IFF_AUTOMEDIA: lkl_net_device_flags = 16384;
pub const lkl_net_device_flags_LKL_IFF_DYNAMIC: lkl_net_device_flags = 32768;
pub const lkl_net_device_flags_LKL_IFF_LOWER_UP: lkl_net_device_flags = 65536;
pub const lkl_net_device_flags_LKL_IFF_DORMANT: lkl_net_device_flags = 131072;
pub const lkl_net_device_flags_LKL_IFF_ECHO: lkl_net_device_flags = 262144;
#[doc = " enum lkl_net_device_flags - &struct net_device flags"]
#[doc = ""]
#[doc = " These are the &struct net_device flags, they can be set by drivers, the"]
#[doc = " kernel and some can be triggered by userspace. Userspace can query and"]
#[doc = " set these flags using userspace utilities but there is also a sysfs"]
#[doc = " entry available for all dev flags which can be queried and set. These flags"]
#[doc = " are shared for all types of net_devices. The sysfs entries are available"]
#[doc = " via /sys/class/net/<dev>/flags. Flags which can be toggled through sysfs"]
#[doc = " are annotated below, note that only a few flags can be toggled and some"]
#[doc = " other flags are always preserved from the original net_device flags"]
#[doc = " even if you try to set them via sysfs. Flags which are always preserved"]
#[doc = " are kept under the flag grouping @LKL_IFF_VOLATILE. Flags which are __volatile__"]
#[doc = " are annotated below as such."]
#[doc = ""]
#[doc = " You should have a pretty good reason to be extending these flags."]
#[doc = ""]
#[doc = " @LKL_IFF_UP: interface is up. Can be toggled through sysfs."]
#[doc = " @LKL_IFF_BROADCAST: broadcast address valid. Volatile."]
#[doc = " @LKL_IFF_DEBUG: turn on debugging. Can be toggled through sysfs."]
#[doc = " @LKL_IFF_LOOPBACK: is a loopback net. Volatile."]
#[doc = " @LKL_IFF_POINTOPOINT: interface is has p-p link. Volatile."]
#[doc = " @LKL_IFF_NOTRAILERS: avoid use of trailers. Can be toggled through sysfs."]
#[doc = "\tVolatile."]
#[doc = " @LKL_IFF_RUNNING: interface RFC2863 OPER_UP. Volatile."]
#[doc = " @LKL_IFF_NOARP: no ARP protocol. Can be toggled through sysfs. Volatile."]
#[doc = " @LKL_IFF_PROMISC: receive all packets. Can be toggled through sysfs."]
#[doc = " @LKL_IFF_ALLMULTI: receive all multicast packets. Can be toggled through"]
#[doc = "\tsysfs."]
#[doc = " @LKL_IFF_MASTER: master of a load balancer. Volatile."]
#[doc = " @LKL_IFF_SLAVE: slave of a load balancer. Volatile."]
#[doc = " @LKL_IFF_MULTICAST: Supports multicast. Can be toggled through sysfs."]
#[doc = " @LKL_IFF_PORTSEL: can set media type. Can be toggled through sysfs."]
#[doc = " @LKL_IFF_AUTOMEDIA: auto media select active. Can be toggled through sysfs."]
#[doc = " @LKL_IFF_DYNAMIC: dialup device with changing addresses. Can be toggled"]
#[doc = "\tthrough sysfs."]
#[doc = " @LKL_IFF_LOWER_UP: driver signals L1 up. Volatile."]
#[doc = " @LKL_IFF_DORMANT: driver signals dormant. Volatile."]
#[doc = " @LKL_IFF_ECHO: echo sent packets. Volatile."]
pub type lkl_net_device_flags = ::std::os::raw::c_uint;
pub const LKL_IF_OPER_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const LKL_IF_OPER_NOTPRESENT: ::std::os::raw::c_uint = 1;
pub const LKL_IF_OPER_DOWN: ::std::os::raw::c_uint = 2;
pub const LKL_IF_OPER_LOWERLAYERDOWN: ::std::os::raw::c_uint = 3;
pub const LKL_IF_OPER_TESTING: ::std::os::raw::c_uint = 4;
pub const LKL_IF_OPER_DORMANT: ::std::os::raw::c_uint = 5;
pub const LKL_IF_OPER_UP: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
pub const LKL_IF_LINK_MODE_DEFAULT: ::std::os::raw::c_uint = 0;
pub const LKL_IF_LINK_MODE_DORMANT: ::std::os::raw::c_uint = 1;
pub const LKL_IF_LINK_MODE_TESTING: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifmap {
    pub mem_start: ::std::os::raw::c_ulong,
    pub mem_end: ::std::os::raw::c_ulong,
    pub base_addr: ::std::os::raw::c_ushort,
    pub irq: ::std::os::raw::c_uchar,
    pub dma: ::std::os::raw::c_uchar,
    pub port: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_lkl_ifmap() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifmap>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_ifmap))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifmap>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_ifmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifmap>())).mem_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifmap),
            "::",
            stringify!(mem_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifmap>())).mem_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifmap),
            "::",
            stringify!(mem_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifmap>())).base_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifmap),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifmap>())).irq as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifmap),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifmap>())).dma as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifmap),
            "::",
            stringify!(dma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifmap>())).port as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifmap),
            "::",
            stringify!(port)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_if_settings {
    pub type_: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
    pub ifs_ifsu: lkl_if_settings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_if_settings__bindgen_ty_1 {
    pub raw_hdlc: *mut lkl_raw_hdlc_proto,
    pub cisco: *mut lkl_cisco_proto,
    pub fr: *mut lkl_fr_proto,
    pub fr_pvc: *mut lkl_fr_proto_pvc,
    pub fr_pvc_info: *mut lkl_fr_proto_pvc_info,
    pub x25: *mut lkl_x25_hdlc_proto,
    pub sync: *mut lkl_sync_serial_settings,
    pub te1: *mut lkl_te1_settings,
}
#[test]
fn bindgen_test_layout_lkl_if_settings__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_if_settings__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_if_settings__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_if_settings__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_if_settings__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_if_settings__bindgen_ty_1>())).raw_hdlc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_settings__bindgen_ty_1),
            "::",
            stringify!(raw_hdlc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_if_settings__bindgen_ty_1>())).cisco as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_settings__bindgen_ty_1),
            "::",
            stringify!(cisco)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_if_settings__bindgen_ty_1>())).fr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_settings__bindgen_ty_1),
            "::",
            stringify!(fr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_if_settings__bindgen_ty_1>())).fr_pvc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_settings__bindgen_ty_1),
            "::",
            stringify!(fr_pvc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_if_settings__bindgen_ty_1>())).fr_pvc_info as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_settings__bindgen_ty_1),
            "::",
            stringify!(fr_pvc_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_if_settings__bindgen_ty_1>())).x25 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_settings__bindgen_ty_1),
            "::",
            stringify!(x25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_if_settings__bindgen_ty_1>())).sync as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_settings__bindgen_ty_1),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_if_settings__bindgen_ty_1>())).te1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_settings__bindgen_ty_1),
            "::",
            stringify!(te1)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_if_settings() {
    assert_eq!(
        ::std::mem::size_of::<lkl_if_settings>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_if_settings))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_if_settings>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_if_settings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_if_settings>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_settings),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_if_settings>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_settings),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_if_settings>())).ifs_ifsu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_settings),
            "::",
            stringify!(ifs_ifsu)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_ifreq {
    pub ifr_ifrn: lkl_ifreq__bindgen_ty_1,
    pub ifr_ifru: lkl_ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_ifreq__bindgen_ty_1 {
    pub ifrn_name: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_lkl_ifreq__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifreq__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_ifreq__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifreq__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_ifreq__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_1>())).ifrn_name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_1),
            "::",
            stringify!(ifrn_name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_ifreq__bindgen_ty_2 {
    pub ifru_addr: lkl_sockaddr,
    pub ifru_dstaddr: lkl_sockaddr,
    pub ifru_broadaddr: lkl_sockaddr,
    pub ifru_netmask: lkl_sockaddr,
    pub ifru_hwaddr: lkl_sockaddr,
    pub ifru_flags: ::std::os::raw::c_short,
    pub ifru_ivalue: ::std::os::raw::c_int,
    pub ifru_mtu: ::std::os::raw::c_int,
    pub ifru_map: lkl_ifmap,
    pub ifru_slave: [::std::os::raw::c_char; 16usize],
    pub ifru_newname: [::std::os::raw::c_char; 16usize],
    pub ifru_data: *mut ::std::os::raw::c_void,
    pub ifru_settings: lkl_if_settings,
}
#[test]
fn bindgen_test_layout_lkl_ifreq__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifreq__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_ifreq__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifreq__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_ifreq__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_dstaddr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_dstaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_broadaddr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_broadaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_netmask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_netmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_hwaddr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_hwaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_ivalue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_ivalue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_mtu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_mtu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_map as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_slave as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_slave)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_newname as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_newname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifreq__bindgen_ty_2>())).ifru_settings as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq__bindgen_ty_2),
            "::",
            stringify!(ifru_settings)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_ifreq() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifreq>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_ifreq))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifreq>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_ifreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifreq>())).ifr_ifrn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq),
            "::",
            stringify!(ifr_ifrn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifreq>())).ifr_ifru as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifreq),
            "::",
            stringify!(ifr_ifru)
        )
    );
}
pub const LKL_IPPROTO_IP: ::std::os::raw::c_uint = 0;
pub const LKL_IPPROTO_ICMP: ::std::os::raw::c_uint = 1;
pub const LKL_IPPROTO_IGMP: ::std::os::raw::c_uint = 2;
pub const LKL_IPPROTO_IPIP: ::std::os::raw::c_uint = 4;
pub const LKL_IPPROTO_TCP: ::std::os::raw::c_uint = 6;
pub const LKL_IPPROTO_EGP: ::std::os::raw::c_uint = 8;
pub const LKL_IPPROTO_PUP: ::std::os::raw::c_uint = 12;
pub const LKL_IPPROTO_UDP: ::std::os::raw::c_uint = 17;
pub const LKL_IPPROTO_IDP: ::std::os::raw::c_uint = 22;
pub const LKL_IPPROTO_TP: ::std::os::raw::c_uint = 29;
pub const LKL_IPPROTO_DCCP: ::std::os::raw::c_uint = 33;
pub const LKL_IPPROTO_IPV6: ::std::os::raw::c_uint = 41;
pub const LKL_IPPROTO_RSVP: ::std::os::raw::c_uint = 46;
pub const LKL_IPPROTO_GRE: ::std::os::raw::c_uint = 47;
pub const LKL_IPPROTO_ESP: ::std::os::raw::c_uint = 50;
pub const LKL_IPPROTO_AH: ::std::os::raw::c_uint = 51;
pub const LKL_IPPROTO_MTP: ::std::os::raw::c_uint = 92;
pub const LKL_IPPROTO_BEETPH: ::std::os::raw::c_uint = 94;
pub const LKL_IPPROTO_ENCAP: ::std::os::raw::c_uint = 98;
pub const LKL_IPPROTO_PIM: ::std::os::raw::c_uint = 103;
pub const LKL_IPPROTO_COMP: ::std::os::raw::c_uint = 108;
pub const LKL_IPPROTO_SCTP: ::std::os::raw::c_uint = 132;
pub const LKL_IPPROTO_UDPLITE: ::std::os::raw::c_uint = 136;
pub const LKL_IPPROTO_MPLS: ::std::os::raw::c_uint = 137;
pub const LKL_IPPROTO_ETHERNET: ::std::os::raw::c_uint = 143;
pub const LKL_IPPROTO_RAW: ::std::os::raw::c_uint = 255;
pub const LKL_IPPROTO_MPTCP: ::std::os::raw::c_uint = 262;
pub const LKL_IPPROTO_MAX: ::std::os::raw::c_uint = 263;
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_in_addr {
    pub lkl_s_addr: __lkl__be32,
}
#[test]
fn bindgen_test_layout_lkl_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in_addr>())).lkl_s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in_addr),
            "::",
            stringify!(lkl_s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ip_mreq {
    pub imr_multiaddr: lkl_in_addr,
    pub imr_interface: lkl_in_addr,
}
#[test]
fn bindgen_test_layout_lkl_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ip_mreqn {
    pub imr_multiaddr: lkl_in_addr,
    pub imr_address: lkl_in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lkl_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_mreqn>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_mreqn>())).imr_address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_mreqn>())).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ip_mreq_source {
    pub imr_multiaddr: __lkl__be32,
    pub imr_interface: __lkl__be32,
    pub imr_sourceaddr: __lkl__be32,
}
#[test]
fn bindgen_test_layout_lkl_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ip_mreq_source))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ip_mreq_source>())).imr_multiaddr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ip_mreq_source>())).imr_interface as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ip_mreq_source>())).imr_sourceaddr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ip_msfilter {
    pub imsf_multiaddr: __lkl__be32,
    pub imsf_interface: __lkl__be32,
    pub imsf_fmode: __lkl__u32,
    pub imsf_numsrc: __lkl__u32,
    pub imsf_slist: [__lkl__be32; 1usize],
}
#[test]
fn bindgen_test_layout_lkl_ip_msfilter() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ip_msfilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_msfilter>())).imsf_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_msfilter>())).imsf_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_msfilter>())).imsf_fmode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_msfilter>())).imsf_numsrc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ip_msfilter>())).imsf_slist as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_group_req {
    pub gr_interface: __lkl__u32,
    pub gr_group: __lkl__kernel_sockaddr_storage,
}
#[test]
fn bindgen_test_layout_lkl_group_req() {
    assert_eq!(
        ::std::mem::size_of::<lkl_group_req>(),
        136usize,
        concat!("Size of: ", stringify!(lkl_group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_group_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_group_req>())).gr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_group_req>())).gr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_group_source_req {
    pub gsr_interface: __lkl__u32,
    pub gsr_group: __lkl__kernel_sockaddr_storage,
    pub gsr_source: __lkl__kernel_sockaddr_storage,
}
#[test]
fn bindgen_test_layout_lkl_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<lkl_group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(lkl_group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_group_source_req))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_group_source_req>())).gsr_interface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_group_source_req>())).gsr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_group_source_req>())).gsr_source as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_group_filter {
    pub gf_interface: __lkl__u32,
    pub gf_group: __lkl__kernel_sockaddr_storage,
    pub gf_fmode: __lkl__u32,
    pub gf_numsrc: __lkl__u32,
    pub gf_slist: [__lkl__kernel_sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_lkl_group_filter() {
    assert_eq!(
        ::std::mem::size_of::<lkl_group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(lkl_group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_group_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_group_filter>())).gf_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_group_filter>())).gf_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_group_filter>())).gf_fmode as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_group_filter>())).gf_numsrc as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_group_filter>())).gf_slist as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: lkl_in_addr,
    pub ipi_addr: lkl_in_addr,
}
#[test]
fn bindgen_test_layout_lkl_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in_pktinfo>())).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in_pktinfo>())).ipi_spec_dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in_pktinfo>())).ipi_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_sockaddr_in {
    pub sin_family: __lkl__kernel_sa_family_t,
    pub sin_port: __lkl__be16,
    pub sin_addr: lkl_in_addr,
    pub __pad: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_lkl_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sockaddr_in>())).__pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sockaddr_in),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_in6_addr {
    pub in6_u: lkl_in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_in6_addr__bindgen_ty_1 {
    pub u6_addr8: [__lkl__u8; 16usize],
}
#[test]
fn bindgen_test_layout_lkl_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_in6_addr__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_in6_addr__bindgen_ty_1>())).u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr8)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_in6_addr>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_addr>())).in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_addr),
            "::",
            stringify!(in6_u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_in6_flowlabel_req {
    pub flr_dst: lkl_in6_addr,
    pub flr_label: __lkl__be32,
    pub flr_action: __lkl__u8,
    pub flr_share: __lkl__u8,
    pub flr_flags: __lkl__u16,
    pub flr_expires: __lkl__u16,
    pub flr_linger: __lkl__u16,
    pub __flr_pad: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_in6_flowlabel_req() {
    assert_eq!(
        ::std::mem::size_of::<lkl_in6_flowlabel_req>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_in6_flowlabel_req))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_in6_flowlabel_req>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_in6_flowlabel_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_flowlabel_req>())).flr_dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_flowlabel_req),
            "::",
            stringify!(flr_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_flowlabel_req>())).flr_label as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_flowlabel_req),
            "::",
            stringify!(flr_label)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_in6_flowlabel_req>())).flr_action as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_flowlabel_req),
            "::",
            stringify!(flr_action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_flowlabel_req>())).flr_share as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_flowlabel_req),
            "::",
            stringify!(flr_share)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_flowlabel_req>())).flr_flags as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_flowlabel_req),
            "::",
            stringify!(flr_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_in6_flowlabel_req>())).flr_expires as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_flowlabel_req),
            "::",
            stringify!(flr_expires)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_in6_flowlabel_req>())).flr_linger as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_flowlabel_req),
            "::",
            stringify!(flr_linger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_flowlabel_req>())).__flr_pad as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_flowlabel_req),
            "::",
            stringify!(__flr_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rtentry {
    pub rt_pad1: ::std::os::raw::c_ulong,
    pub rt_dst: lkl_sockaddr,
    pub rt_gateway: lkl_sockaddr,
    pub rt_genmask: lkl_sockaddr,
    pub rt_flags: ::std::os::raw::c_ushort,
    pub rt_pad2: ::std::os::raw::c_short,
    pub rt_pad3: ::std::os::raw::c_ulong,
    pub rt_pad4: *mut ::std::os::raw::c_void,
    pub rt_metric: ::std::os::raw::c_short,
    pub rt_dev: *mut ::std::os::raw::c_char,
    pub rt_mtu: ::std::os::raw::c_ulong,
    pub rt_window: ::std::os::raw::c_ulong,
    pub rt_irtt: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_lkl_rtentry() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rtentry>(),
        120usize,
        concat!("Size of: ", stringify!(lkl_rtentry))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rtentry>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_rtentry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_pad1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_dst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_gateway as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_gateway)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_genmask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_genmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_pad2 as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_pad3 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_pad4 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_metric as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_metric)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_dev as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_mtu as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_window as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtentry>())).rt_irtt as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtentry),
            "::",
            stringify!(rt_irtt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_in6_rtmsg {
    pub rtmsg_dst: lkl_in6_addr,
    pub rtmsg_src: lkl_in6_addr,
    pub rtmsg_gateway: lkl_in6_addr,
    pub rtmsg_type: __lkl__u32,
    pub rtmsg_dst_len: __lkl__u16,
    pub rtmsg_src_len: __lkl__u16,
    pub rtmsg_metric: __lkl__u32,
    pub rtmsg_info: ::std::os::raw::c_ulong,
    pub rtmsg_flags: __lkl__u32,
    pub rtmsg_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lkl_in6_rtmsg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_in6_rtmsg>(),
        80usize,
        concat!("Size of: ", stringify!(lkl_in6_rtmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_in6_rtmsg>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_in6_rtmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_rtmsg>())).rtmsg_dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_rtmsg),
            "::",
            stringify!(rtmsg_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_rtmsg>())).rtmsg_src as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_rtmsg),
            "::",
            stringify!(rtmsg_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_rtmsg>())).rtmsg_gateway as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_rtmsg),
            "::",
            stringify!(rtmsg_gateway)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_rtmsg>())).rtmsg_type as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_rtmsg),
            "::",
            stringify!(rtmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_rtmsg>())).rtmsg_dst_len as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_rtmsg),
            "::",
            stringify!(rtmsg_dst_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_rtmsg>())).rtmsg_src_len as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_rtmsg),
            "::",
            stringify!(rtmsg_src_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_rtmsg>())).rtmsg_metric as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_rtmsg),
            "::",
            stringify!(rtmsg_metric)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_rtmsg>())).rtmsg_info as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_rtmsg),
            "::",
            stringify!(rtmsg_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_rtmsg>())).rtmsg_flags as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_rtmsg),
            "::",
            stringify!(rtmsg_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_rtmsg>())).rtmsg_ifindex as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_rtmsg),
            "::",
            stringify!(rtmsg_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_in6_ifreq {
    pub ifr6_addr: lkl_in6_addr,
    pub ifr6_prefixlen: __lkl__u32,
    pub ifr6_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lkl_in6_ifreq() {
    assert_eq!(
        ::std::mem::size_of::<lkl_in6_ifreq>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_in6_ifreq))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_in6_ifreq>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_in6_ifreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_ifreq>())).ifr6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_ifreq),
            "::",
            stringify!(ifr6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_ifreq>())).ifr6_prefixlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_ifreq),
            "::",
            stringify!(ifr6_prefixlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_in6_ifreq>())).ifr6_ifindex as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_in6_ifreq),
            "::",
            stringify!(ifr6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ipv6_rt_hdr {
    pub nexthdr: __lkl__u8,
    pub hdrlen: __lkl__u8,
    pub type_: __lkl__u8,
    pub segments_left: __lkl__u8,
}
#[test]
fn bindgen_test_layout_lkl_ipv6_rt_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ipv6_rt_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_ipv6_rt_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ipv6_rt_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_ipv6_rt_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6_rt_hdr>())).nexthdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6_rt_hdr),
            "::",
            stringify!(nexthdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6_rt_hdr>())).hdrlen as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6_rt_hdr),
            "::",
            stringify!(hdrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6_rt_hdr>())).type_ as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6_rt_hdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6_rt_hdr>())).segments_left as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6_rt_hdr),
            "::",
            stringify!(segments_left)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ipv6_opt_hdr {
    pub nexthdr: __lkl__u8,
    pub hdrlen: __lkl__u8,
}
#[test]
fn bindgen_test_layout_lkl_ipv6_opt_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ipv6_opt_hdr>(),
        2usize,
        concat!("Size of: ", stringify!(lkl_ipv6_opt_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ipv6_opt_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_ipv6_opt_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6_opt_hdr>())).nexthdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6_opt_hdr),
            "::",
            stringify!(nexthdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6_opt_hdr>())).hdrlen as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6_opt_hdr),
            "::",
            stringify!(hdrlen)
        )
    );
}
#[repr(C)]
pub struct lkl_rt0_hdr {
    pub rt_hdr: lkl_ipv6_rt_hdr,
    pub reserved: __lkl__u32,
    pub addr: __IncompleteArrayField<lkl_in6_addr>,
}
#[test]
fn bindgen_test_layout_lkl_rt0_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rt0_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_rt0_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rt0_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_rt0_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rt0_hdr>())).rt_hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rt0_hdr),
            "::",
            stringify!(rt_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rt0_hdr>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rt0_hdr),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rt0_hdr>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rt0_hdr),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_rt2_hdr {
    pub rt_hdr: lkl_ipv6_rt_hdr,
    pub reserved: __lkl__u32,
    pub addr: lkl_in6_addr,
}
#[test]
fn bindgen_test_layout_lkl_rt2_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rt2_hdr>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_rt2_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rt2_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_rt2_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rt2_hdr>())).rt_hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rt2_hdr),
            "::",
            stringify!(rt_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rt2_hdr>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rt2_hdr),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rt2_hdr>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rt2_hdr),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct lkl_ipv6_destopt_hao {
    pub type_: __lkl__u8,
    pub length: __lkl__u8,
    pub addr: lkl_in6_addr,
}
#[test]
fn bindgen_test_layout_lkl_ipv6_destopt_hao() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ipv6_destopt_hao>(),
        18usize,
        concat!("Size of: ", stringify!(lkl_ipv6_destopt_hao))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ipv6_destopt_hao>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_ipv6_destopt_hao))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6_destopt_hao>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6_destopt_hao),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6_destopt_hao>())).length as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6_destopt_hao),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6_destopt_hao>())).addr as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6_destopt_hao),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_ipv6hdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub flow_lbl: [__lkl__u8; 3usize],
    pub payload_len: __lkl__be16,
    pub nexthdr: __lkl__u8,
    pub hop_limit: __lkl__u8,
    pub saddr: lkl_in6_addr,
    pub daddr: lkl_in6_addr,
}
#[test]
fn bindgen_test_layout_lkl_ipv6hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ipv6hdr>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_ipv6hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ipv6hdr>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_ipv6hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6hdr>())).flow_lbl as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6hdr),
            "::",
            stringify!(flow_lbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6hdr>())).payload_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6hdr),
            "::",
            stringify!(payload_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6hdr>())).nexthdr as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6hdr),
            "::",
            stringify!(nexthdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6hdr>())).hop_limit as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6hdr),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6hdr>())).saddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6hdr),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ipv6hdr>())).daddr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ipv6hdr),
            "::",
            stringify!(daddr)
        )
    );
}
impl lkl_ipv6hdr {
    #[inline]
    pub fn priority(&self) -> __lkl__u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: __lkl__u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> __lkl__u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: __lkl__u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        priority: __lkl__u8,
        version: __lkl__u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let priority: u8 = unsafe { ::std::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LKL_DEVCONF_FORWARDING: ::std::os::raw::c_uint = 0;
pub const LKL_DEVCONF_HOPLIMIT: ::std::os::raw::c_uint = 1;
pub const LKL_DEVCONF_MTU6: ::std::os::raw::c_uint = 2;
pub const LKL_DEVCONF_ACCEPT_RA: ::std::os::raw::c_uint = 3;
pub const LKL_DEVCONF_ACCEPT_REDIRECTS: ::std::os::raw::c_uint = 4;
pub const LKL_DEVCONF_AUTOCONF: ::std::os::raw::c_uint = 5;
pub const LKL_DEVCONF_DAD_TRANSMITS: ::std::os::raw::c_uint = 6;
pub const LKL_DEVCONF_RTR_SOLICITS: ::std::os::raw::c_uint = 7;
pub const LKL_DEVCONF_RTR_SOLICIT_INTERVAL: ::std::os::raw::c_uint = 8;
pub const LKL_DEVCONF_RTR_SOLICIT_DELAY: ::std::os::raw::c_uint = 9;
pub const LKL_DEVCONF_USE_TEMPADDR: ::std::os::raw::c_uint = 10;
pub const LKL_DEVCONF_TEMP_VALID_LFT: ::std::os::raw::c_uint = 11;
pub const LKL_DEVCONF_TEMP_PREFERED_LFT: ::std::os::raw::c_uint = 12;
pub const LKL_DEVCONF_REGEN_MAX_RETRY: ::std::os::raw::c_uint = 13;
pub const LKL_DEVCONF_MAX_DESYNC_FACTOR: ::std::os::raw::c_uint = 14;
pub const LKL_DEVCONF_MAX_ADDRESSES: ::std::os::raw::c_uint = 15;
pub const LKL_DEVCONF_FORCE_MLD_VERSION: ::std::os::raw::c_uint = 16;
pub const LKL_DEVCONF_ACCEPT_RA_DEFRTR: ::std::os::raw::c_uint = 17;
pub const LKL_DEVCONF_ACCEPT_RA_PINFO: ::std::os::raw::c_uint = 18;
pub const LKL_DEVCONF_ACCEPT_RA_RTR_PREF: ::std::os::raw::c_uint = 19;
pub const LKL_DEVCONF_RTR_PROBE_INTERVAL: ::std::os::raw::c_uint = 20;
pub const LKL_DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN: ::std::os::raw::c_uint = 21;
pub const LKL_DEVCONF_PROXY_NDP: ::std::os::raw::c_uint = 22;
pub const LKL_DEVCONF_OPTIMISTIC_DAD: ::std::os::raw::c_uint = 23;
pub const LKL_DEVCONF_ACCEPT_SOURCE_ROUTE: ::std::os::raw::c_uint = 24;
pub const LKL_DEVCONF_MC_FORWARDING: ::std::os::raw::c_uint = 25;
pub const LKL_DEVCONF_DISABLE_IPV6: ::std::os::raw::c_uint = 26;
pub const LKL_DEVCONF_ACCEPT_DAD: ::std::os::raw::c_uint = 27;
pub const LKL_DEVCONF_FORCE_TLLAO: ::std::os::raw::c_uint = 28;
pub const LKL_DEVCONF_NDISC_NOTIFY: ::std::os::raw::c_uint = 29;
pub const LKL_DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL: ::std::os::raw::c_uint = 30;
pub const LKL_DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL: ::std::os::raw::c_uint = 31;
pub const LKL_DEVCONF_SUPPRESS_FRAG_NDISC: ::std::os::raw::c_uint = 32;
pub const LKL_DEVCONF_ACCEPT_RA_FROM_LOCAL: ::std::os::raw::c_uint = 33;
pub const LKL_DEVCONF_USE_OPTIMISTIC: ::std::os::raw::c_uint = 34;
pub const LKL_DEVCONF_ACCEPT_RA_MTU: ::std::os::raw::c_uint = 35;
pub const LKL_DEVCONF_STABLE_SECRET: ::std::os::raw::c_uint = 36;
pub const LKL_DEVCONF_USE_OIF_ADDRS_ONLY: ::std::os::raw::c_uint = 37;
pub const LKL_DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT: ::std::os::raw::c_uint = 38;
pub const LKL_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN: ::std::os::raw::c_uint = 39;
pub const LKL_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST: ::std::os::raw::c_uint = 40;
pub const LKL_DEVCONF_DROP_UNSOLICITED_NA: ::std::os::raw::c_uint = 41;
pub const LKL_DEVCONF_KEEP_ADDR_ON_DOWN: ::std::os::raw::c_uint = 42;
pub const LKL_DEVCONF_RTR_SOLICIT_MAX_INTERVAL: ::std::os::raw::c_uint = 43;
pub const LKL_DEVCONF_SEG6_ENABLED: ::std::os::raw::c_uint = 44;
pub const LKL_DEVCONF_SEG6_REQUIRE_HMAC: ::std::os::raw::c_uint = 45;
pub const LKL_DEVCONF_ENHANCED_DAD: ::std::os::raw::c_uint = 46;
pub const LKL_DEVCONF_ADDR_GEN_MODE: ::std::os::raw::c_uint = 47;
pub const LKL_DEVCONF_DISABLE_POLICY: ::std::os::raw::c_uint = 48;
pub const LKL_DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN: ::std::os::raw::c_uint = 49;
pub const LKL_DEVCONF_NDISC_TCLASS: ::std::os::raw::c_uint = 50;
pub const LKL_DEVCONF_RPL_SEG_ENABLED: ::std::os::raw::c_uint = 51;
pub const LKL_DEVCONF_MAX: ::std::os::raw::c_uint = 52;
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_sockaddr_nl {
    pub nl_family: __lkl__kernel_sa_family_t,
    pub nl_pad: ::std::os::raw::c_ushort,
    pub nl_pid: __lkl__u32,
    pub nl_groups: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_sockaddr_nl() {
    assert_eq!(
        ::std::mem::size_of::<lkl_sockaddr_nl>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_sockaddr_nl))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_sockaddr_nl>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_sockaddr_nl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sockaddr_nl>())).nl_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sockaddr_nl),
            "::",
            stringify!(nl_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sockaddr_nl>())).nl_pad as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sockaddr_nl),
            "::",
            stringify!(nl_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sockaddr_nl>())).nl_pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sockaddr_nl),
            "::",
            stringify!(nl_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_sockaddr_nl>())).nl_groups as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_sockaddr_nl),
            "::",
            stringify!(nl_groups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_nlmsghdr {
    pub nlmsg_len: __lkl__u32,
    pub nlmsg_type: __lkl__u16,
    pub nlmsg_flags: __lkl__u16,
    pub nlmsg_seq: __lkl__u32,
    pub nlmsg_pid: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_nlmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_nlmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_nlmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_nlmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_nlmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nlmsghdr>())).nlmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nlmsghdr),
            "::",
            stringify!(nlmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nlmsghdr>())).nlmsg_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nlmsghdr),
            "::",
            stringify!(nlmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nlmsghdr>())).nlmsg_flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nlmsghdr),
            "::",
            stringify!(nlmsg_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nlmsghdr>())).nlmsg_seq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nlmsghdr),
            "::",
            stringify!(nlmsg_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nlmsghdr>())).nlmsg_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nlmsghdr),
            "::",
            stringify!(nlmsg_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_nlmsgerr {
    pub error: ::std::os::raw::c_int,
    pub msg: lkl_nlmsghdr,
}
#[test]
fn bindgen_test_layout_lkl_nlmsgerr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_nlmsgerr>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_nlmsgerr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_nlmsgerr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_nlmsgerr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nlmsgerr>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nlmsgerr),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nlmsgerr>())).msg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nlmsgerr),
            "::",
            stringify!(msg)
        )
    );
}
pub const lkl_nlmsgerr_attrs_LKL_NLMSGERR_ATTR_UNUSED: lkl_nlmsgerr_attrs = 0;
pub const lkl_nlmsgerr_attrs_LKL_NLMSGERR_ATTR_MSG: lkl_nlmsgerr_attrs = 1;
pub const lkl_nlmsgerr_attrs_LKL_NLMSGERR_ATTR_OFFS: lkl_nlmsgerr_attrs = 2;
pub const lkl_nlmsgerr_attrs_LKL_NLMSGERR_ATTR_COOKIE: lkl_nlmsgerr_attrs = 3;
pub const lkl_nlmsgerr_attrs_LKL_NLMSGERR_ATTR_POLICY: lkl_nlmsgerr_attrs = 4;
pub const lkl_nlmsgerr_attrs___LKL__NLMSGERR_ATTR_MAX: lkl_nlmsgerr_attrs = 5;
pub const lkl_nlmsgerr_attrs_LKL_NLMSGERR_ATTR_MAX: lkl_nlmsgerr_attrs = 4;
#[doc = " enum lkl_nlmsgerr_attrs - nlmsgerr attributes"]
#[doc = " @LKL_NLMSGERR_ATTR_UNUSED: unused"]
#[doc = " @LKL_NLMSGERR_ATTR_MSG: error message string (string)"]
#[doc = " @LKL_NLMSGERR_ATTR_OFFS: offset of the invalid attribute in the original"]
#[doc = "\t message, counting from the beginning of the header (lkl_u32)"]
#[doc = " @LKL_NLMSGERR_ATTR_COOKIE: arbitrary subsystem specific cookie to"]
#[doc = "\tbe used - in the success case - to identify a created"]
#[doc = "\tobject or operation or similar (binary)"]
#[doc = " @LKL_NLMSGERR_ATTR_POLICY: policy for a rejected attribute"]
#[doc = " @__LKL__NLMSGERR_ATTR_MAX: number of attributes"]
#[doc = " @LKL_NLMSGERR_ATTR_MAX: highest attribute number"]
pub type lkl_nlmsgerr_attrs = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_nl_pktinfo {
    pub group: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_nl_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_nl_pktinfo>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_nl_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_nl_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_nl_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nl_pktinfo>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nl_pktinfo),
            "::",
            stringify!(group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_nl_mmap_req {
    pub nm_block_size: ::std::os::raw::c_uint,
    pub nm_block_nr: ::std::os::raw::c_uint,
    pub nm_frame_size: ::std::os::raw::c_uint,
    pub nm_frame_nr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_nl_mmap_req() {
    assert_eq!(
        ::std::mem::size_of::<lkl_nl_mmap_req>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_nl_mmap_req))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_nl_mmap_req>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_nl_mmap_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nl_mmap_req>())).nm_block_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nl_mmap_req),
            "::",
            stringify!(nm_block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nl_mmap_req>())).nm_block_nr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nl_mmap_req),
            "::",
            stringify!(nm_block_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nl_mmap_req>())).nm_frame_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nl_mmap_req),
            "::",
            stringify!(nm_frame_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nl_mmap_req>())).nm_frame_nr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nl_mmap_req),
            "::",
            stringify!(nm_frame_nr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_nl_mmap_hdr {
    pub nm_status: ::std::os::raw::c_uint,
    pub nm_len: ::std::os::raw::c_uint,
    pub nm_group: __lkl__u32,
    pub nm_pid: __lkl__u32,
    pub nm_uid: __lkl__u32,
    pub nm_gid: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_nl_mmap_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_nl_mmap_hdr>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_nl_mmap_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_nl_mmap_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_nl_mmap_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nl_mmap_hdr>())).nm_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nl_mmap_hdr),
            "::",
            stringify!(nm_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nl_mmap_hdr>())).nm_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nl_mmap_hdr),
            "::",
            stringify!(nm_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nl_mmap_hdr>())).nm_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nl_mmap_hdr),
            "::",
            stringify!(nm_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nl_mmap_hdr>())).nm_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nl_mmap_hdr),
            "::",
            stringify!(nm_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nl_mmap_hdr>())).nm_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nl_mmap_hdr),
            "::",
            stringify!(nm_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nl_mmap_hdr>())).nm_gid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nl_mmap_hdr),
            "::",
            stringify!(nm_gid)
        )
    );
}
pub const lkl_nl_mmap_status_LKL_NL_MMAP_STATUS_UNUSED: lkl_nl_mmap_status = 0;
pub const lkl_nl_mmap_status_LKL_NL_MMAP_STATUS_RESERVED: lkl_nl_mmap_status = 1;
pub const lkl_nl_mmap_status_LKL_NL_MMAP_STATUS_VALID: lkl_nl_mmap_status = 2;
pub const lkl_nl_mmap_status_LKL_NL_MMAP_STATUS_COPY: lkl_nl_mmap_status = 3;
pub const lkl_nl_mmap_status_LKL_NL_MMAP_STATUS_SKIP: lkl_nl_mmap_status = 4;
pub type lkl_nl_mmap_status = ::std::os::raw::c_uint;
pub const LKL_NETLINK_UNCONNECTED: ::std::os::raw::c_uint = 0;
pub const LKL_NETLINK_CONNECTED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_nlattr {
    pub nla_len: __lkl__u16,
    pub nla_type: __lkl__u16,
}
#[test]
fn bindgen_test_layout_lkl_nlattr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_nlattr>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_nlattr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_nlattr>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_nlattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nlattr>())).nla_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nlattr),
            "::",
            stringify!(nla_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nlattr>())).nla_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nlattr),
            "::",
            stringify!(nla_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_nla_bitfield32 {
    pub value: __lkl__u32,
    pub selector: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_nla_bitfield32() {
    assert_eq!(
        ::std::mem::size_of::<lkl_nla_bitfield32>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_nla_bitfield32))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_nla_bitfield32>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_nla_bitfield32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nla_bitfield32>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nla_bitfield32),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nla_bitfield32>())).selector as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nla_bitfield32),
            "::",
            stringify!(selector)
        )
    );
}
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_INVALID: lkl_netlink_attribute_type = 0;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_FLAG: lkl_netlink_attribute_type = 1;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_U8: lkl_netlink_attribute_type = 2;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_U16: lkl_netlink_attribute_type = 3;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_U32: lkl_netlink_attribute_type = 4;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_U64: lkl_netlink_attribute_type = 5;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_S8: lkl_netlink_attribute_type = 6;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_S16: lkl_netlink_attribute_type = 7;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_S32: lkl_netlink_attribute_type = 8;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_S64: lkl_netlink_attribute_type = 9;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_BINARY: lkl_netlink_attribute_type = 10;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_STRING: lkl_netlink_attribute_type = 11;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_NUL_STRING: lkl_netlink_attribute_type = 12;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_NESTED: lkl_netlink_attribute_type = 13;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_NESTED_ARRAY: lkl_netlink_attribute_type = 14;
pub const lkl_netlink_attribute_type_LKL_NL_ATTR_TYPE_BITFIELD32: lkl_netlink_attribute_type = 15;
#[doc = " enum lkl_netlink_attribute_type - type of an attribute"]
#[doc = " @LKL_NL_ATTR_TYPE_INVALID: unused"]
#[doc = " @LKL_NL_ATTR_TYPE_FLAG: flag attribute (present/not present)"]
#[doc = " @LKL_NL_ATTR_TYPE_U8: 8-bit unsigned attribute"]
#[doc = " @LKL_NL_ATTR_TYPE_U16: 16-bit unsigned attribute"]
#[doc = " @LKL_NL_ATTR_TYPE_U32: 32-bit unsigned attribute"]
#[doc = " @LKL_NL_ATTR_TYPE_U64: 64-bit unsigned attribute"]
#[doc = " @LKL_NL_ATTR_TYPE_S8: 8-bit signed attribute"]
#[doc = " @LKL_NL_ATTR_TYPE_S16: 16-bit signed attribute"]
#[doc = " @LKL_NL_ATTR_TYPE_S32: 32-bit signed attribute"]
#[doc = " @LKL_NL_ATTR_TYPE_S64: 64-bit signed attribute"]
#[doc = " @LKL_NL_ATTR_TYPE_BINARY: binary data, min/max length may be specified"]
#[doc = " @LKL_NL_ATTR_TYPE_STRING: string, min/max length may be specified"]
#[doc = " @LKL_NL_ATTR_TYPE_NUL_STRING: NUL-terminated string,"]
#[doc = "\tmin/max length may be specified"]
#[doc = " @LKL_NL_ATTR_TYPE_NESTED: nested, i.e. the content of this attribute"]
#[doc = "\tconsists of sub-attributes. The nested policy and maxtype"]
#[doc = "\tinside may be specified."]
#[doc = " @LKL_NL_ATTR_TYPE_NESTED_ARRAY: nested array, i.e. the content of this"]
#[doc = "\tattribute contains sub-attributes whose type is irrelevant"]
#[doc = "\t(just used to separate the array entries) and each such array"]
#[doc = "\tentry has attributes again, the policy for those inner ones"]
#[doc = "\tand the corresponding maxtype may be specified."]
#[doc = " @LKL_NL_ATTR_TYPE_BITFIELD32: &struct lkl_nla_bitfield32 attribute"]
pub type lkl_netlink_attribute_type = ::std::os::raw::c_uint;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_UNSPEC:
    lkl_netlink_policy_type_attr = 0;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_TYPE: lkl_netlink_policy_type_attr =
    1;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_MIN_VALUE_S:
    lkl_netlink_policy_type_attr = 2;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_MAX_VALUE_S:
    lkl_netlink_policy_type_attr = 3;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_MIN_VALUE_U:
    lkl_netlink_policy_type_attr = 4;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_MAX_VALUE_U:
    lkl_netlink_policy_type_attr = 5;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_MIN_LENGTH:
    lkl_netlink_policy_type_attr = 6;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_MAX_LENGTH:
    lkl_netlink_policy_type_attr = 7;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_POLICY_IDX:
    lkl_netlink_policy_type_attr = 8;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE:
    lkl_netlink_policy_type_attr = 9;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_BITFIELD32_MASK:
    lkl_netlink_policy_type_attr = 10;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_PAD: lkl_netlink_policy_type_attr =
    11;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_MASK: lkl_netlink_policy_type_attr =
    12;
pub const lkl_netlink_policy_type_attr___LKL__NL_POLICY_TYPE_ATTR_MAX:
    lkl_netlink_policy_type_attr = 13;
pub const lkl_netlink_policy_type_attr_LKL_NL_POLICY_TYPE_ATTR_MAX: lkl_netlink_policy_type_attr =
    12;
#[doc = " enum lkl_netlink_policy_type_attr - policy type attributes"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_UNSPEC: unused"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_TYPE: type of the attribute,"]
#[doc = "\t&enum lkl_netlink_attribute_type (U32)"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_MIN_VALUE_S: minimum value for signed"]
#[doc = "\tintegers (S64)"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_MAX_VALUE_S: maximum value for signed"]
#[doc = "\tintegers (S64)"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_MIN_VALUE_U: minimum value for unsigned"]
#[doc = "\tintegers (U64)"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_MAX_VALUE_U: maximum value for unsigned"]
#[doc = "\tintegers (U64)"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_MIN_LENGTH: minimum length for binary"]
#[doc = "\tattributes, no minimum if not given (U32)"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_MAX_LENGTH: maximum length for binary"]
#[doc = "\tattributes, no maximum if not given (U32)"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_POLICY_IDX: sub policy for nested and"]
#[doc = "\tnested array types (U32)"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE: maximum sub policy"]
#[doc = "\tattribute for nested and nested array types, this can"]
#[doc = "\tin theory be < the size of the policy pointed to by"]
#[doc = "\tthe index, if limited inside the nesting (U32)"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_BITFIELD32_MASK: valid mask for the"]
#[doc = "\tbitfield32 type (U32)"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_MASK: mask of valid bits for unsigned integers (U64)"]
#[doc = " @LKL_NL_POLICY_TYPE_ATTR_PAD: pad attribute for 64-bit alignment"]
pub type lkl_netlink_policy_type_attr = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ndmsg {
    pub ndm_family: __lkl__u8,
    pub ndm_pad1: __lkl__u8,
    pub ndm_pad2: __lkl__u16,
    pub ndm_ifindex: __lkl__s32,
    pub ndm_state: __lkl__u16,
    pub ndm_flags: __lkl__u8,
    pub ndm_type: __lkl__u8,
}
#[test]
fn bindgen_test_layout_lkl_ndmsg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ndmsg>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_ndmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ndmsg>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ndmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndmsg>())).ndm_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndmsg),
            "::",
            stringify!(ndm_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndmsg>())).ndm_pad1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndmsg),
            "::",
            stringify!(ndm_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndmsg>())).ndm_pad2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndmsg),
            "::",
            stringify!(ndm_pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndmsg>())).ndm_ifindex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndmsg),
            "::",
            stringify!(ndm_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndmsg>())).ndm_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndmsg),
            "::",
            stringify!(ndm_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndmsg>())).ndm_flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndmsg),
            "::",
            stringify!(ndm_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndmsg>())).ndm_type as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndmsg),
            "::",
            stringify!(ndm_type)
        )
    );
}
pub const LKL_NDA_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_NDA_DST: ::std::os::raw::c_uint = 1;
pub const LKL_NDA_LLADDR: ::std::os::raw::c_uint = 2;
pub const LKL_NDA_CACHEINFO: ::std::os::raw::c_uint = 3;
pub const LKL_NDA_PROBES: ::std::os::raw::c_uint = 4;
pub const LKL_NDA_VLAN: ::std::os::raw::c_uint = 5;
pub const LKL_NDA_PORT: ::std::os::raw::c_uint = 6;
pub const LKL_NDA_VNI: ::std::os::raw::c_uint = 7;
pub const LKL_NDA_IFINDEX: ::std::os::raw::c_uint = 8;
pub const LKL_NDA_MASTER: ::std::os::raw::c_uint = 9;
pub const LKL_NDA_LINK_NETNSID: ::std::os::raw::c_uint = 10;
pub const LKL_NDA_SRC_VNI: ::std::os::raw::c_uint = 11;
pub const LKL_NDA_PROTOCOL: ::std::os::raw::c_uint = 12;
pub const LKL_NDA_NH_ID: ::std::os::raw::c_uint = 13;
pub const LKL_NDA_FDB_EXT_ATTRS: ::std::os::raw::c_uint = 14;
pub const __LKL__NDA_MAX: ::std::os::raw::c_uint = 15;
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_nda_cacheinfo {
    pub ndm_confirmed: __lkl__u32,
    pub ndm_used: __lkl__u32,
    pub ndm_updated: __lkl__u32,
    pub ndm_refcnt: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_nda_cacheinfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_nda_cacheinfo>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_nda_cacheinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_nda_cacheinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_nda_cacheinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nda_cacheinfo>())).ndm_confirmed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nda_cacheinfo),
            "::",
            stringify!(ndm_confirmed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nda_cacheinfo>())).ndm_used as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nda_cacheinfo),
            "::",
            stringify!(ndm_used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nda_cacheinfo>())).ndm_updated as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nda_cacheinfo),
            "::",
            stringify!(ndm_updated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nda_cacheinfo>())).ndm_refcnt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nda_cacheinfo),
            "::",
            stringify!(ndm_refcnt)
        )
    );
}
#[doc = "\t\tNeighbour tables specific messages."]
#[doc = ""]
#[doc = " To retrieve the neighbour tables send LKL_RTM_GETNEIGHTBL with the"]
#[doc = " LKL_NLM_F_DUMP flag set. Every neighbour table configuration is"]
#[doc = " spread over multiple messages to avoid running into message"]
#[doc = " size limits on systems with many interfaces. The first message"]
#[doc = " in the sequence transports all not device specific data such as"]
#[doc = " statistics, configuration, and the default parameter set."]
#[doc = " This message is followed by 0..n messages carrying device"]
#[doc = " specific parameter sets."]
#[doc = " Although the ordering should be sufficient, LKL_NDTA_NAME can be"]
#[doc = " used to identify sequences. The initial message can be identified"]
#[doc = " by checking for LKL_NDTA_CONFIG. The device specific messages do"]
#[doc = " not contain this TLV but have LKL_NDTPA_IFINDEX set to the"]
#[doc = " corresponding interface index."]
#[doc = ""]
#[doc = " To change neighbour table attributes, send LKL_RTM_SETNEIGHTBL"]
#[doc = " with LKL_NDTA_NAME set. Changeable attribute include NDTA_THRESH[1-3],"]
#[doc = " LKL_NDTA_GC_INTERVAL, and all TLVs in LKL_NDTA_PARMS unless marked"]
#[doc = " otherwise. Device specific parameter sets can be changed by"]
#[doc = " setting LKL_NDTPA_IFINDEX to the interface index of the corresponding"]
#[doc = " device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ndt_stats {
    pub ndts_allocs: __lkl__u64,
    pub ndts_destroys: __lkl__u64,
    pub ndts_hash_grows: __lkl__u64,
    pub ndts_res_failed: __lkl__u64,
    pub ndts_lookups: __lkl__u64,
    pub ndts_hits: __lkl__u64,
    pub ndts_rcv_probes_mcast: __lkl__u64,
    pub ndts_rcv_probes_ucast: __lkl__u64,
    pub ndts_periodic_gc_runs: __lkl__u64,
    pub ndts_forced_gc_runs: __lkl__u64,
    pub ndts_table_fulls: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_ndt_stats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ndt_stats>(),
        88usize,
        concat!("Size of: ", stringify!(lkl_ndt_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ndt_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_ndt_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_stats>())).ndts_allocs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_stats),
            "::",
            stringify!(ndts_allocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_stats>())).ndts_destroys as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_stats),
            "::",
            stringify!(ndts_destroys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_stats>())).ndts_hash_grows as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_stats),
            "::",
            stringify!(ndts_hash_grows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_stats>())).ndts_res_failed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_stats),
            "::",
            stringify!(ndts_res_failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_stats>())).ndts_lookups as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_stats),
            "::",
            stringify!(ndts_lookups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_stats>())).ndts_hits as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_stats),
            "::",
            stringify!(ndts_hits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ndt_stats>())).ndts_rcv_probes_mcast as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_stats),
            "::",
            stringify!(ndts_rcv_probes_mcast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ndt_stats>())).ndts_rcv_probes_ucast as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_stats),
            "::",
            stringify!(ndts_rcv_probes_ucast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ndt_stats>())).ndts_periodic_gc_runs as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_stats),
            "::",
            stringify!(ndts_periodic_gc_runs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ndt_stats>())).ndts_forced_gc_runs as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_stats),
            "::",
            stringify!(ndts_forced_gc_runs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_stats>())).ndts_table_fulls as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_stats),
            "::",
            stringify!(ndts_table_fulls)
        )
    );
}
pub const LKL_NDTPA_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_NDTPA_IFINDEX: ::std::os::raw::c_uint = 1;
pub const LKL_NDTPA_REFCNT: ::std::os::raw::c_uint = 2;
pub const LKL_NDTPA_REACHABLE_TIME: ::std::os::raw::c_uint = 3;
pub const LKL_NDTPA_BASE_REACHABLE_TIME: ::std::os::raw::c_uint = 4;
pub const LKL_NDTPA_RETRANS_TIME: ::std::os::raw::c_uint = 5;
pub const LKL_NDTPA_GC_STALETIME: ::std::os::raw::c_uint = 6;
pub const LKL_NDTPA_DELAY_PROBE_TIME: ::std::os::raw::c_uint = 7;
pub const LKL_NDTPA_QUEUE_LEN: ::std::os::raw::c_uint = 8;
pub const LKL_NDTPA_APP_PROBES: ::std::os::raw::c_uint = 9;
pub const LKL_NDTPA_UCAST_PROBES: ::std::os::raw::c_uint = 10;
pub const LKL_NDTPA_MCAST_PROBES: ::std::os::raw::c_uint = 11;
pub const LKL_NDTPA_ANYCAST_DELAY: ::std::os::raw::c_uint = 12;
pub const LKL_NDTPA_PROXY_DELAY: ::std::os::raw::c_uint = 13;
pub const LKL_NDTPA_PROXY_QLEN: ::std::os::raw::c_uint = 14;
pub const LKL_NDTPA_LOCKTIME: ::std::os::raw::c_uint = 15;
pub const LKL_NDTPA_QUEUE_LENBYTES: ::std::os::raw::c_uint = 16;
pub const LKL_NDTPA_MCAST_REPROBES: ::std::os::raw::c_uint = 17;
pub const LKL_NDTPA_PAD: ::std::os::raw::c_uint = 18;
pub const __LKL__NDTPA_MAX: ::std::os::raw::c_uint = 19;
pub type _bindgen_ty_52 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ndtmsg {
    pub ndtm_family: __lkl__u8,
    pub ndtm_pad1: __lkl__u8,
    pub ndtm_pad2: __lkl__u16,
}
#[test]
fn bindgen_test_layout_lkl_ndtmsg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ndtmsg>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_ndtmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ndtmsg>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_ndtmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndtmsg>())).ndtm_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndtmsg),
            "::",
            stringify!(ndtm_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndtmsg>())).ndtm_pad1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndtmsg),
            "::",
            stringify!(ndtm_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndtmsg>())).ndtm_pad2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndtmsg),
            "::",
            stringify!(ndtm_pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ndt_config {
    pub ndtc_key_len: __lkl__u16,
    pub ndtc_entry_size: __lkl__u16,
    pub ndtc_entries: __lkl__u32,
    pub ndtc_last_flush: __lkl__u32,
    pub ndtc_last_rand: __lkl__u32,
    pub ndtc_hash_rnd: __lkl__u32,
    pub ndtc_hash_mask: __lkl__u32,
    pub ndtc_hash_chain_gc: __lkl__u32,
    pub ndtc_proxy_qlen: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ndt_config() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ndt_config>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_ndt_config))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ndt_config>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ndt_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_config>())).ndtc_key_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_config),
            "::",
            stringify!(ndtc_key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_config>())).ndtc_entry_size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_config),
            "::",
            stringify!(ndtc_entry_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_config>())).ndtc_entries as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_config),
            "::",
            stringify!(ndtc_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_config>())).ndtc_last_flush as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_config),
            "::",
            stringify!(ndtc_last_flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_config>())).ndtc_last_rand as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_config),
            "::",
            stringify!(ndtc_last_rand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_config>())).ndtc_hash_rnd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_config),
            "::",
            stringify!(ndtc_hash_rnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_config>())).ndtc_hash_mask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_config),
            "::",
            stringify!(ndtc_hash_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ndt_config>())).ndtc_hash_chain_gc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_config),
            "::",
            stringify!(ndtc_hash_chain_gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ndt_config>())).ndtc_proxy_qlen as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ndt_config),
            "::",
            stringify!(ndtc_proxy_qlen)
        )
    );
}
pub const LKL_NDTA_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_NDTA_NAME: ::std::os::raw::c_uint = 1;
pub const LKL_NDTA_THRESH1: ::std::os::raw::c_uint = 2;
pub const LKL_NDTA_THRESH2: ::std::os::raw::c_uint = 3;
pub const LKL_NDTA_THRESH3: ::std::os::raw::c_uint = 4;
pub const LKL_NDTA_CONFIG: ::std::os::raw::c_uint = 5;
pub const LKL_NDTA_PARMS: ::std::os::raw::c_uint = 6;
pub const LKL_NDTA_STATS: ::std::os::raw::c_uint = 7;
pub const LKL_NDTA_GC_INTERVAL: ::std::os::raw::c_uint = 8;
pub const LKL_NDTA_PAD: ::std::os::raw::c_uint = 9;
pub const __LKL__NDTA_MAX: ::std::os::raw::c_uint = 10;
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
pub const LKL_FDB_NOTIFY_BIT: ::std::os::raw::c_uint = 1;
pub const LKL_FDB_NOTIFY_INACTIVE_BIT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_54 = ::std::os::raw::c_uint;
pub const LKL_NFEA_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_NFEA_ACTIVITY_NOTIFY: ::std::os::raw::c_uint = 1;
pub const LKL_NFEA_DONT_REFRESH: ::std::os::raw::c_uint = 2;
pub const __LKL__NFEA_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rtnl_link_stats {
    pub rx_packets: __lkl__u32,
    pub tx_packets: __lkl__u32,
    pub rx_bytes: __lkl__u32,
    pub tx_bytes: __lkl__u32,
    pub rx_errors: __lkl__u32,
    pub tx_errors: __lkl__u32,
    pub rx_dropped: __lkl__u32,
    pub tx_dropped: __lkl__u32,
    pub multicast: __lkl__u32,
    pub collisions: __lkl__u32,
    pub rx_length_errors: __lkl__u32,
    pub rx_over_errors: __lkl__u32,
    pub rx_crc_errors: __lkl__u32,
    pub rx_frame_errors: __lkl__u32,
    pub rx_fifo_errors: __lkl__u32,
    pub rx_missed_errors: __lkl__u32,
    pub tx_aborted_errors: __lkl__u32,
    pub tx_carrier_errors: __lkl__u32,
    pub tx_fifo_errors: __lkl__u32,
    pub tx_heartbeat_errors: __lkl__u32,
    pub tx_window_errors: __lkl__u32,
    pub rx_compressed: __lkl__u32,
    pub tx_compressed: __lkl__u32,
    pub rx_nohandler: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_rtnl_link_stats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rtnl_link_stats>(),
        96usize,
        concat!("Size of: ", stringify!(lkl_rtnl_link_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rtnl_link_stats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_rtnl_link_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_packets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).tx_packets as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(tx_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).tx_bytes as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(tx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_errors as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).tx_errors as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(tx_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_dropped as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).tx_dropped as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(tx_dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).multicast as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(multicast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).collisions as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(collisions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_length_errors as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_length_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_over_errors as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_over_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_crc_errors as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_crc_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_frame_errors as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_frame_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_fifo_errors as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_fifo_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_missed_errors as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_missed_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).tx_aborted_errors as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(tx_aborted_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).tx_carrier_errors as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(tx_carrier_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).tx_fifo_errors as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(tx_fifo_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).tx_heartbeat_errors as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(tx_heartbeat_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).tx_window_errors as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(tx_window_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_compressed as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_compressed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).tx_compressed as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(tx_compressed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats>())).rx_nohandler as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats),
            "::",
            stringify!(rx_nohandler)
        )
    );
}
#[doc = " struct lkl_rtnl_link_stats64 - The main device statistics structure."]
#[doc = ""]
#[doc = " @rx_packets: Number of good packets received by the interface."]
#[doc = "   For hardware interfaces counts all good packets received from the device"]
#[doc = "   by the host, including packets which host had to drop at various stages"]
#[doc = "   of processing (even in the driver)."]
#[doc = ""]
#[doc = " @tx_packets: Number of packets successfully transmitted."]
#[doc = "   For hardware interfaces counts packets which host was able to successfully"]
#[doc = "   hand over to the device, which does not necessarily mean that packets"]
#[doc = "   had been successfully transmitted out of the device, only that device"]
#[doc = "   acknowledged it copied them out of host memory."]
#[doc = ""]
#[doc = " @rx_bytes: Number of good received bytes, corresponding to @rx_packets."]
#[doc = ""]
#[doc = "   For IEEE 802.3 devices should count the length of Ethernet Frames"]
#[doc = "   excluding the FCS."]
#[doc = ""]
#[doc = " @tx_bytes: Number of good transmitted bytes, corresponding to @tx_packets."]
#[doc = ""]
#[doc = "   For IEEE 802.3 devices should count the length of Ethernet Frames"]
#[doc = "   excluding the FCS."]
#[doc = ""]
#[doc = " @rx_errors: Total number of bad packets received on this network device."]
#[doc = "   This counter must include events counted by @rx_length_errors,"]
#[doc = "   @rx_crc_errors, @rx_frame_errors and other errors not otherwise"]
#[doc = "   counted."]
#[doc = ""]
#[doc = " @tx_errors: Total number of transmit problems."]
#[doc = "   This counter must include events counter by @tx_aborted_errors,"]
#[doc = "   @tx_carrier_errors, @tx_fifo_errors, @tx_heartbeat_errors,"]
#[doc = "   @tx_window_errors and other errors not otherwise counted."]
#[doc = ""]
#[doc = " @rx_dropped: Number of packets received but not processed,"]
#[doc = "   e.g. due to lack of resources or unsupported protocol."]
#[doc = "   For hardware interfaces this counter should not include packets"]
#[doc = "   dropped by the device which are counted separately in"]
#[doc = "   @rx_missed_errors (since procfs folds those two counters together)."]
#[doc = ""]
#[doc = " @tx_dropped: Number of packets dropped on their way to transmission,"]
#[doc = "   e.g. due to lack of resources."]
#[doc = ""]
#[doc = " @multicast: Multicast packets received."]
#[doc = "   For hardware interfaces this statistic is commonly calculated"]
#[doc = "   at the device level (unlike @rx_packets) and therefore may include"]
#[doc = "   packets which did not reach the host."]
#[doc = ""]
#[doc = "   For IEEE 802.3 devices this counter may be equivalent to:"]
#[doc = ""]
#[doc = "    - 30.3.1.1.21 aMulticastFramesReceivedOK"]
#[doc = ""]
#[doc = " @collisions: Number of collisions during packet transmissions."]
#[doc = ""]
#[doc = " @rx_length_errors: Number of packets dropped due to invalid length."]
#[doc = "   Part of aggregate \"frame\" errors in `/proc/net/dev`."]
#[doc = ""]
#[doc = "   For IEEE 802.3 devices this counter should be equivalent to a sum"]
#[doc = "   of the following attributes:"]
#[doc = ""]
#[doc = "    - 30.3.1.1.23 aInRangeLengthErrors"]
#[doc = "    - 30.3.1.1.24 aOutOfRangeLengthField"]
#[doc = "    - 30.3.1.1.25 aFrameTooLongErrors"]
#[doc = ""]
#[doc = " @rx_over_errors: Receiver FIFO overflow event counter."]
#[doc = ""]
#[doc = "   Historically the count of overflow events. Such events may be"]
#[doc = "   reported in the receive descriptors or via interrupts, and may"]
#[doc = "   not correspond one-to-one with dropped packets."]
#[doc = ""]
#[doc = "   The recommended interpretation for high speed interfaces is -"]
#[doc = "   number of packets dropped because they did not fit into buffers"]
#[doc = "   provided by the host, e.g. packets larger than MTU or next buffer"]
#[doc = "   in the ring was not available for a scatter transfer."]
#[doc = ""]
#[doc = "   Part of aggregate \"frame\" errors in `/proc/net/dev`."]
#[doc = ""]
#[doc = "   This statistics was historically used interchangeably with"]
#[doc = "   @rx_fifo_errors."]
#[doc = ""]
#[doc = "   This statistic corresponds to hardware events and is not commonly used"]
#[doc = "   on software devices."]
#[doc = ""]
#[doc = " @rx_crc_errors: Number of packets received with a CRC error."]
#[doc = "   Part of aggregate \"frame\" errors in `/proc/net/dev`."]
#[doc = ""]
#[doc = "   For IEEE 802.3 devices this counter must be equivalent to:"]
#[doc = ""]
#[doc = "    - 30.3.1.1.6 aFrameCheckSequenceErrors"]
#[doc = ""]
#[doc = " @rx_frame_errors: Receiver frame alignment errors."]
#[doc = "   Part of aggregate \"frame\" errors in `/proc/net/dev`."]
#[doc = ""]
#[doc = "   For IEEE 802.3 devices this counter should be equivalent to:"]
#[doc = ""]
#[doc = "    - 30.3.1.1.7 aAlignmentErrors"]
#[doc = ""]
#[doc = " @rx_fifo_errors: Receiver FIFO error counter."]
#[doc = ""]
#[doc = "   Historically the count of overflow events. Those events may be"]
#[doc = "   reported in the receive descriptors or via interrupts, and may"]
#[doc = "   not correspond one-to-one with dropped packets."]
#[doc = ""]
#[doc = "   This statistics was used interchangeably with @rx_over_errors."]
#[doc = "   Not recommended for use in drivers for high speed interfaces."]
#[doc = ""]
#[doc = "   This statistic is used on software devices, e.g. to count software"]
#[doc = "   packet queue overflow (can) or sequencing errors (GRE)."]
#[doc = ""]
#[doc = " @rx_missed_errors: Count of packets missed by the host."]
#[doc = "   Folded into the \"drop\" counter in `/proc/net/dev`."]
#[doc = ""]
#[doc = "   Counts number of packets dropped by the device due to lack"]
#[doc = "   of buffer space. This usually indicates that the host interface"]
#[doc = "   is slower than the network interface, or host is not keeping up"]
#[doc = "   with the receive packet rate."]
#[doc = ""]
#[doc = "   This statistic corresponds to hardware events and is not used"]
#[doc = "   on software devices."]
#[doc = ""]
#[doc = " @tx_aborted_errors:"]
#[doc = "   Part of aggregate \"carrier\" errors in `/proc/net/dev`."]
#[doc = "   For IEEE 802.3 devices capable of half-duplex operation this counter"]
#[doc = "   must be equivalent to:"]
#[doc = ""]
#[doc = "    - 30.3.1.1.11 aFramesAbortedDueToXSColls"]
#[doc = ""]
#[doc = "   High speed interfaces may use this counter as a general device"]
#[doc = "   discard counter."]
#[doc = ""]
#[doc = " @tx_carrier_errors: Number of frame transmission errors due to loss"]
#[doc = "   of carrier during transmission."]
#[doc = "   Part of aggregate \"carrier\" errors in `/proc/net/dev`."]
#[doc = ""]
#[doc = "   For IEEE 802.3 devices this counter must be equivalent to:"]
#[doc = ""]
#[doc = "    - 30.3.1.1.13 aCarrierSenseErrors"]
#[doc = ""]
#[doc = " @tx_fifo_errors: Number of frame transmission errors due to device"]
#[doc = "   FIFO underrun / underflow. This condition occurs when the device"]
#[doc = "   begins transmission of a frame but is unable to deliver the"]
#[doc = "   entire frame to the transmitter in time for transmission."]
#[doc = "   Part of aggregate \"carrier\" errors in `/proc/net/dev`."]
#[doc = ""]
#[doc = " @tx_heartbeat_errors: Number of Heartbeat / SQE Test errors for"]
#[doc = "   old half-duplex Ethernet."]
#[doc = "   Part of aggregate \"carrier\" errors in `/proc/net/dev`."]
#[doc = ""]
#[doc = "   For IEEE 802.3 devices possibly equivalent to:"]
#[doc = ""]
#[doc = "    - 30.3.2.1.4 aSQETestErrors"]
#[doc = ""]
#[doc = " @tx_window_errors: Number of frame transmission errors due"]
#[doc = "   to late collisions (for Ethernet - after the first 64B of transmission)."]
#[doc = "   Part of aggregate \"carrier\" errors in `/proc/net/dev`."]
#[doc = ""]
#[doc = "   For IEEE 802.3 devices this counter must be equivalent to:"]
#[doc = ""]
#[doc = "    - 30.3.1.1.10 aLateCollisions"]
#[doc = ""]
#[doc = " @rx_compressed: Number of correctly received compressed packets."]
#[doc = "   This counters is only meaningful for interfaces which support"]
#[doc = "   packet compression (e.g. CSLIP, PPP)."]
#[doc = ""]
#[doc = " @tx_compressed: Number of transmitted compressed packets."]
#[doc = "   This counters is only meaningful for interfaces which support"]
#[doc = "   packet compression (e.g. CSLIP, PPP)."]
#[doc = ""]
#[doc = " @rx_nohandler: Number of packets received on the interface"]
#[doc = "   but dropped by the networking stack because the device is"]
#[doc = "   not designated to receive packets (e.g. backup link in a bond)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rtnl_link_stats64 {
    pub rx_packets: __lkl__u64,
    pub tx_packets: __lkl__u64,
    pub rx_bytes: __lkl__u64,
    pub tx_bytes: __lkl__u64,
    pub rx_errors: __lkl__u64,
    pub tx_errors: __lkl__u64,
    pub rx_dropped: __lkl__u64,
    pub tx_dropped: __lkl__u64,
    pub multicast: __lkl__u64,
    pub collisions: __lkl__u64,
    pub rx_length_errors: __lkl__u64,
    pub rx_over_errors: __lkl__u64,
    pub rx_crc_errors: __lkl__u64,
    pub rx_frame_errors: __lkl__u64,
    pub rx_fifo_errors: __lkl__u64,
    pub rx_missed_errors: __lkl__u64,
    pub tx_aborted_errors: __lkl__u64,
    pub tx_carrier_errors: __lkl__u64,
    pub tx_fifo_errors: __lkl__u64,
    pub tx_heartbeat_errors: __lkl__u64,
    pub tx_window_errors: __lkl__u64,
    pub rx_compressed: __lkl__u64,
    pub tx_compressed: __lkl__u64,
    pub rx_nohandler: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_rtnl_link_stats64() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rtnl_link_stats64>(),
        192usize,
        concat!("Size of: ", stringify!(lkl_rtnl_link_stats64))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rtnl_link_stats64>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_rtnl_link_stats64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_packets as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_packets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).tx_packets as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(tx_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_bytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).tx_bytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(tx_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_errors as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).tx_errors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(tx_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_dropped as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_dropped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).tx_dropped as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(tx_dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).multicast as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(multicast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).collisions as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(collisions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_length_errors as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_length_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_over_errors as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_over_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_crc_errors as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_crc_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_frame_errors as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_frame_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_fifo_errors as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_fifo_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_missed_errors as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_missed_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).tx_aborted_errors as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(tx_aborted_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).tx_carrier_errors as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(tx_carrier_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).tx_fifo_errors as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(tx_fifo_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).tx_heartbeat_errors as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(tx_heartbeat_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).tx_window_errors as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(tx_window_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_compressed as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_compressed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).tx_compressed as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(tx_compressed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rtnl_link_stats64>())).rx_nohandler as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_stats64),
            "::",
            stringify!(rx_nohandler)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rtnl_link_ifmap {
    pub mem_start: __lkl__u64,
    pub mem_end: __lkl__u64,
    pub base_addr: __lkl__u64,
    pub irq: __lkl__u16,
    pub dma: __lkl__u8,
    pub port: __lkl__u8,
}
#[test]
fn bindgen_test_layout_lkl_rtnl_link_ifmap() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rtnl_link_ifmap>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_rtnl_link_ifmap))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rtnl_link_ifmap>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_rtnl_link_ifmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_ifmap>())).mem_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_ifmap),
            "::",
            stringify!(mem_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_ifmap>())).mem_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_ifmap),
            "::",
            stringify!(mem_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_ifmap>())).base_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_ifmap),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_ifmap>())).irq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_ifmap),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_ifmap>())).dma as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_ifmap),
            "::",
            stringify!(dma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnl_link_ifmap>())).port as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnl_link_ifmap),
            "::",
            stringify!(port)
        )
    );
}
pub const LKL_IFLA_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_ADDRESS: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_BROADCAST: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_IFNAME: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_MTU: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_LINK: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_QDISC: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_STATS: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_COST: ::std::os::raw::c_uint = 8;
pub const LKL_IFLA_PRIORITY: ::std::os::raw::c_uint = 9;
pub const LKL_IFLA_MASTER: ::std::os::raw::c_uint = 10;
pub const LKL_IFLA_WIRELESS: ::std::os::raw::c_uint = 11;
pub const LKL_IFLA_PROTINFO: ::std::os::raw::c_uint = 12;
pub const LKL_IFLA_TXQLEN: ::std::os::raw::c_uint = 13;
pub const LKL_IFLA_MAP: ::std::os::raw::c_uint = 14;
pub const LKL_IFLA_WEIGHT: ::std::os::raw::c_uint = 15;
pub const LKL_IFLA_OPERSTATE: ::std::os::raw::c_uint = 16;
pub const LKL_IFLA_LINKMODE: ::std::os::raw::c_uint = 17;
pub const LKL_IFLA_LINKINFO: ::std::os::raw::c_uint = 18;
pub const LKL_IFLA_NET_NS_PID: ::std::os::raw::c_uint = 19;
pub const LKL_IFLA_IFALIAS: ::std::os::raw::c_uint = 20;
pub const LKL_IFLA_NUM_VF: ::std::os::raw::c_uint = 21;
pub const LKL_IFLA_VFINFO_LIST: ::std::os::raw::c_uint = 22;
pub const LKL_IFLA_STATS64: ::std::os::raw::c_uint = 23;
pub const LKL_IFLA_VF_PORTS: ::std::os::raw::c_uint = 24;
pub const LKL_IFLA_PORT_SELF: ::std::os::raw::c_uint = 25;
pub const LKL_IFLA_AF_SPEC: ::std::os::raw::c_uint = 26;
pub const LKL_IFLA_GROUP: ::std::os::raw::c_uint = 27;
pub const LKL_IFLA_NET_NS_FD: ::std::os::raw::c_uint = 28;
pub const LKL_IFLA_EXT_MASK: ::std::os::raw::c_uint = 29;
pub const LKL_IFLA_PROMISCUITY: ::std::os::raw::c_uint = 30;
pub const LKL_IFLA_NUM_TX_QUEUES: ::std::os::raw::c_uint = 31;
pub const LKL_IFLA_NUM_RX_QUEUES: ::std::os::raw::c_uint = 32;
pub const LKL_IFLA_CARRIER: ::std::os::raw::c_uint = 33;
pub const LKL_IFLA_PHYS_PORT_ID: ::std::os::raw::c_uint = 34;
pub const LKL_IFLA_CARRIER_CHANGES: ::std::os::raw::c_uint = 35;
pub const LKL_IFLA_PHYS_SWITCH_ID: ::std::os::raw::c_uint = 36;
pub const LKL_IFLA_LINK_NETNSID: ::std::os::raw::c_uint = 37;
pub const LKL_IFLA_PHYS_PORT_NAME: ::std::os::raw::c_uint = 38;
pub const LKL_IFLA_PROTO_DOWN: ::std::os::raw::c_uint = 39;
pub const LKL_IFLA_GSO_MAX_SEGS: ::std::os::raw::c_uint = 40;
pub const LKL_IFLA_GSO_MAX_SIZE: ::std::os::raw::c_uint = 41;
pub const LKL_IFLA_PAD: ::std::os::raw::c_uint = 42;
pub const LKL_IFLA_XDP: ::std::os::raw::c_uint = 43;
pub const LKL_IFLA_EVENT: ::std::os::raw::c_uint = 44;
pub const LKL_IFLA_NEW_NETNSID: ::std::os::raw::c_uint = 45;
pub const LKL_IFLA_IF_NETNSID: ::std::os::raw::c_uint = 46;
pub const LKL_IFLA_TARGET_NETNSID: ::std::os::raw::c_uint = 46;
pub const LKL_IFLA_CARRIER_UP_COUNT: ::std::os::raw::c_uint = 47;
pub const LKL_IFLA_CARRIER_DOWN_COUNT: ::std::os::raw::c_uint = 48;
pub const LKL_IFLA_NEW_IFINDEX: ::std::os::raw::c_uint = 49;
pub const LKL_IFLA_MIN_MTU: ::std::os::raw::c_uint = 50;
pub const LKL_IFLA_MAX_MTU: ::std::os::raw::c_uint = 51;
pub const LKL_IFLA_PROP_LIST: ::std::os::raw::c_uint = 52;
pub const LKL_IFLA_ALT_IFNAME: ::std::os::raw::c_uint = 53;
pub const LKL_IFLA_PERM_ADDRESS: ::std::os::raw::c_uint = 54;
pub const LKL_IFLA_PROTO_DOWN_REASON: ::std::os::raw::c_uint = 55;
pub const __LKL__IFLA_MAX: ::std::os::raw::c_uint = 56;
pub type _bindgen_ty_56 = ::std::os::raw::c_uint;
pub const LKL_IFLA_PROTO_DOWN_REASON_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_PROTO_DOWN_REASON_MASK: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_PROTO_DOWN_REASON_VALUE: ::std::os::raw::c_uint = 2;
pub const __LKL__IFLA_PROTO_DOWN_REASON_CNT: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_PROTO_DOWN_REASON_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_57 = ::std::os::raw::c_uint;
pub const LKL_IFLA_INET_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_INET_CONF: ::std::os::raw::c_uint = 1;
pub const __LKL__IFLA_INET_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_58 = ::std::os::raw::c_uint;
pub const LKL_IFLA_INET6_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_INET6_FLAGS: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_INET6_CONF: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_INET6_STATS: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_INET6_MCAST: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_INET6_CACHEINFO: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_INET6_ICMP6STATS: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_INET6_TOKEN: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_INET6_ADDR_GEN_MODE: ::std::os::raw::c_uint = 8;
pub const __LKL__IFLA_INET6_MAX: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_59 = ::std::os::raw::c_uint;
pub const lkl_in6_addr_gen_mode_LKL_IN6_ADDR_GEN_MODE_EUI64: lkl_in6_addr_gen_mode = 0;
pub const lkl_in6_addr_gen_mode_LKL_IN6_ADDR_GEN_MODE_NONE: lkl_in6_addr_gen_mode = 1;
pub const lkl_in6_addr_gen_mode_LKL_IN6_ADDR_GEN_MODE_STABLE_PRIVACY: lkl_in6_addr_gen_mode = 2;
pub const lkl_in6_addr_gen_mode_LKL_IN6_ADDR_GEN_MODE_RANDOM: lkl_in6_addr_gen_mode = 3;
pub type lkl_in6_addr_gen_mode = ::std::os::raw::c_uint;
pub const LKL_IFLA_BR_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_BR_FORWARD_DELAY: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_BR_HELLO_TIME: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_BR_MAX_AGE: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_BR_AGEING_TIME: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_BR_STP_STATE: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_BR_PRIORITY: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_BR_VLAN_FILTERING: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_BR_VLAN_PROTOCOL: ::std::os::raw::c_uint = 8;
pub const LKL_IFLA_BR_GROUP_FWD_MASK: ::std::os::raw::c_uint = 9;
pub const LKL_IFLA_BR_ROOT_ID: ::std::os::raw::c_uint = 10;
pub const LKL_IFLA_BR_BRIDGE_ID: ::std::os::raw::c_uint = 11;
pub const LKL_IFLA_BR_ROOT_PORT: ::std::os::raw::c_uint = 12;
pub const LKL_IFLA_BR_ROOT_PATH_COST: ::std::os::raw::c_uint = 13;
pub const LKL_IFLA_BR_TOPOLOGY_CHANGE: ::std::os::raw::c_uint = 14;
pub const LKL_IFLA_BR_TOPOLOGY_CHANGE_DETECTED: ::std::os::raw::c_uint = 15;
pub const LKL_IFLA_BR_HELLO_TIMER: ::std::os::raw::c_uint = 16;
pub const LKL_IFLA_BR_TCN_TIMER: ::std::os::raw::c_uint = 17;
pub const LKL_IFLA_BR_TOPOLOGY_CHANGE_TIMER: ::std::os::raw::c_uint = 18;
pub const LKL_IFLA_BR_GC_TIMER: ::std::os::raw::c_uint = 19;
pub const LKL_IFLA_BR_GROUP_ADDR: ::std::os::raw::c_uint = 20;
pub const LKL_IFLA_BR_FDB_FLUSH: ::std::os::raw::c_uint = 21;
pub const LKL_IFLA_BR_MCAST_ROUTER: ::std::os::raw::c_uint = 22;
pub const LKL_IFLA_BR_MCAST_SNOOPING: ::std::os::raw::c_uint = 23;
pub const LKL_IFLA_BR_MCAST_QUERY_USE_IFADDR: ::std::os::raw::c_uint = 24;
pub const LKL_IFLA_BR_MCAST_QUERIER: ::std::os::raw::c_uint = 25;
pub const LKL_IFLA_BR_MCAST_HASH_ELASTICITY: ::std::os::raw::c_uint = 26;
pub const LKL_IFLA_BR_MCAST_HASH_MAX: ::std::os::raw::c_uint = 27;
pub const LKL_IFLA_BR_MCAST_LAST_MEMBER_CNT: ::std::os::raw::c_uint = 28;
pub const LKL_IFLA_BR_MCAST_STARTUP_QUERY_CNT: ::std::os::raw::c_uint = 29;
pub const LKL_IFLA_BR_MCAST_LAST_MEMBER_INTVL: ::std::os::raw::c_uint = 30;
pub const LKL_IFLA_BR_MCAST_MEMBERSHIP_INTVL: ::std::os::raw::c_uint = 31;
pub const LKL_IFLA_BR_MCAST_QUERIER_INTVL: ::std::os::raw::c_uint = 32;
pub const LKL_IFLA_BR_MCAST_QUERY_INTVL: ::std::os::raw::c_uint = 33;
pub const LKL_IFLA_BR_MCAST_QUERY_RESPONSE_INTVL: ::std::os::raw::c_uint = 34;
pub const LKL_IFLA_BR_MCAST_STARTUP_QUERY_INTVL: ::std::os::raw::c_uint = 35;
pub const LKL_IFLA_BR_NF_CALL_IPTABLES: ::std::os::raw::c_uint = 36;
pub const LKL_IFLA_BR_NF_CALL_IP6TABLES: ::std::os::raw::c_uint = 37;
pub const LKL_IFLA_BR_NF_CALL_ARPTABLES: ::std::os::raw::c_uint = 38;
pub const LKL_IFLA_BR_VLAN_DEFAULT_PVID: ::std::os::raw::c_uint = 39;
pub const LKL_IFLA_BR_PAD: ::std::os::raw::c_uint = 40;
pub const LKL_IFLA_BR_VLAN_STATS_ENABLED: ::std::os::raw::c_uint = 41;
pub const LKL_IFLA_BR_MCAST_STATS_ENABLED: ::std::os::raw::c_uint = 42;
pub const LKL_IFLA_BR_MCAST_IGMP_VERSION: ::std::os::raw::c_uint = 43;
pub const LKL_IFLA_BR_MCAST_MLD_VERSION: ::std::os::raw::c_uint = 44;
pub const LKL_IFLA_BR_VLAN_STATS_PER_PORT: ::std::os::raw::c_uint = 45;
pub const LKL_IFLA_BR_MULTI_BOOLOPT: ::std::os::raw::c_uint = 46;
pub const __LKL__IFLA_BR_MAX: ::std::os::raw::c_uint = 47;
pub type _bindgen_ty_60 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_bridge_id {
    pub prio: [__lkl__u8; 2usize],
    pub addr: [__lkl__u8; 6usize],
}
#[test]
fn bindgen_test_layout_lkl_ifla_bridge_id() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_bridge_id>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ifla_bridge_id))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_bridge_id>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_ifla_bridge_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_bridge_id>())).prio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_bridge_id),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_bridge_id>())).addr as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_bridge_id),
            "::",
            stringify!(addr)
        )
    );
}
pub const LKL_BRIDGE_MODE_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_BRIDGE_MODE_HAIRPIN: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
pub const LKL_IFLA_BRPORT_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_BRPORT_STATE: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_BRPORT_PRIORITY: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_BRPORT_COST: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_BRPORT_MODE: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_BRPORT_GUARD: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_BRPORT_PROTECT: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_BRPORT_FAST_LEAVE: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_BRPORT_LEARNING: ::std::os::raw::c_uint = 8;
pub const LKL_IFLA_BRPORT_UNICAST_FLOOD: ::std::os::raw::c_uint = 9;
pub const LKL_IFLA_BRPORT_PROXYARP: ::std::os::raw::c_uint = 10;
pub const LKL_IFLA_BRPORT_LEARNING_SYNC: ::std::os::raw::c_uint = 11;
pub const LKL_IFLA_BRPORT_PROXYARP_WIFI: ::std::os::raw::c_uint = 12;
pub const LKL_IFLA_BRPORT_ROOT_ID: ::std::os::raw::c_uint = 13;
pub const LKL_IFLA_BRPORT_BRIDGE_ID: ::std::os::raw::c_uint = 14;
pub const LKL_IFLA_BRPORT_DESIGNATED_PORT: ::std::os::raw::c_uint = 15;
pub const LKL_IFLA_BRPORT_DESIGNATED_COST: ::std::os::raw::c_uint = 16;
pub const LKL_IFLA_BRPORT_ID: ::std::os::raw::c_uint = 17;
pub const LKL_IFLA_BRPORT_NO: ::std::os::raw::c_uint = 18;
pub const LKL_IFLA_BRPORT_TOPOLOGY_CHANGE_ACK: ::std::os::raw::c_uint = 19;
pub const LKL_IFLA_BRPORT_CONFIG_PENDING: ::std::os::raw::c_uint = 20;
pub const LKL_IFLA_BRPORT_MESSAGE_AGE_TIMER: ::std::os::raw::c_uint = 21;
pub const LKL_IFLA_BRPORT_FORWARD_DELAY_TIMER: ::std::os::raw::c_uint = 22;
pub const LKL_IFLA_BRPORT_HOLD_TIMER: ::std::os::raw::c_uint = 23;
pub const LKL_IFLA_BRPORT_FLUSH: ::std::os::raw::c_uint = 24;
pub const LKL_IFLA_BRPORT_MULTICAST_ROUTER: ::std::os::raw::c_uint = 25;
pub const LKL_IFLA_BRPORT_PAD: ::std::os::raw::c_uint = 26;
pub const LKL_IFLA_BRPORT_MCAST_FLOOD: ::std::os::raw::c_uint = 27;
pub const LKL_IFLA_BRPORT_MCAST_TO_UCAST: ::std::os::raw::c_uint = 28;
pub const LKL_IFLA_BRPORT_VLAN_TUNNEL: ::std::os::raw::c_uint = 29;
pub const LKL_IFLA_BRPORT_BCAST_FLOOD: ::std::os::raw::c_uint = 30;
pub const LKL_IFLA_BRPORT_GROUP_FWD_MASK: ::std::os::raw::c_uint = 31;
pub const LKL_IFLA_BRPORT_NEIGH_SUPPRESS: ::std::os::raw::c_uint = 32;
pub const LKL_IFLA_BRPORT_ISOLATED: ::std::os::raw::c_uint = 33;
pub const LKL_IFLA_BRPORT_BACKUP_PORT: ::std::os::raw::c_uint = 34;
pub const LKL_IFLA_BRPORT_MRP_RING_OPEN: ::std::os::raw::c_uint = 35;
pub const LKL_IFLA_BRPORT_MRP_IN_OPEN: ::std::os::raw::c_uint = 36;
pub const __LKL__IFLA_BRPORT_MAX: ::std::os::raw::c_uint = 37;
pub type _bindgen_ty_62 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_cacheinfo {
    pub max_reasm_len: __lkl__u32,
    pub tstamp: __lkl__u32,
    pub reachable_time: __lkl__u32,
    pub retrans_time: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifla_cacheinfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_cacheinfo>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_ifla_cacheinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_cacheinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_cacheinfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifla_cacheinfo>())).max_reasm_len as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_cacheinfo),
            "::",
            stringify!(max_reasm_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_cacheinfo>())).tstamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_cacheinfo),
            "::",
            stringify!(tstamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifla_cacheinfo>())).reachable_time as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_cacheinfo),
            "::",
            stringify!(reachable_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_cacheinfo>())).retrans_time as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_cacheinfo),
            "::",
            stringify!(retrans_time)
        )
    );
}
pub const LKL_IFLA_INFO_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_INFO_KIND: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_INFO_DATA: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_INFO_XSTATS: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_INFO_SLAVE_KIND: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_INFO_SLAVE_DATA: ::std::os::raw::c_uint = 5;
pub const __LKL__IFLA_INFO_MAX: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_63 = ::std::os::raw::c_uint;
pub const LKL_IFLA_VLAN_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_VLAN_ID: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_VLAN_FLAGS: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_VLAN_EGRESS_QOS: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_VLAN_INGRESS_QOS: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_VLAN_PROTOCOL: ::std::os::raw::c_uint = 5;
pub const __LKL__IFLA_VLAN_MAX: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_64 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vlan_flags {
    pub flags: __lkl__u32,
    pub mask: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vlan_flags() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vlan_flags>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ifla_vlan_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vlan_flags>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vlan_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vlan_flags>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vlan_flags),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vlan_flags>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vlan_flags),
            "::",
            stringify!(mask)
        )
    );
}
pub const LKL_IFLA_VLAN_QOS_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_VLAN_QOS_MAPPING: ::std::os::raw::c_uint = 1;
pub const __LKL__IFLA_VLAN_QOS_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_65 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vlan_qos_mapping {
    pub from: __lkl__u32,
    pub to: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vlan_qos_mapping() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vlan_qos_mapping>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ifla_vlan_qos_mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vlan_qos_mapping>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vlan_qos_mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vlan_qos_mapping>())).from as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vlan_qos_mapping),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vlan_qos_mapping>())).to as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vlan_qos_mapping),
            "::",
            stringify!(to)
        )
    );
}
pub const LKL_IFLA_MACVLAN_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_MACVLAN_MODE: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_MACVLAN_FLAGS: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_MACVLAN_MACADDR_MODE: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_MACVLAN_MACADDR: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_MACVLAN_MACADDR_DATA: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_MACVLAN_MACADDR_COUNT: ::std::os::raw::c_uint = 6;
pub const __LKL__IFLA_MACVLAN_MAX: ::std::os::raw::c_uint = 7;
pub type _bindgen_ty_66 = ::std::os::raw::c_uint;
pub const lkl_macvlan_mode_LKL_MACVLAN_MODE_PRIVATE: lkl_macvlan_mode = 1;
pub const lkl_macvlan_mode_LKL_MACVLAN_MODE_VEPA: lkl_macvlan_mode = 2;
pub const lkl_macvlan_mode_LKL_MACVLAN_MODE_BRIDGE: lkl_macvlan_mode = 4;
pub const lkl_macvlan_mode_LKL_MACVLAN_MODE_PASSTHRU: lkl_macvlan_mode = 8;
pub const lkl_macvlan_mode_LKL_MACVLAN_MODE_SOURCE: lkl_macvlan_mode = 16;
pub type lkl_macvlan_mode = ::std::os::raw::c_uint;
pub const lkl_macvlan_macaddr_mode_LKL_MACVLAN_MACADDR_ADD: lkl_macvlan_macaddr_mode = 0;
pub const lkl_macvlan_macaddr_mode_LKL_MACVLAN_MACADDR_DEL: lkl_macvlan_macaddr_mode = 1;
pub const lkl_macvlan_macaddr_mode_LKL_MACVLAN_MACADDR_FLUSH: lkl_macvlan_macaddr_mode = 2;
pub const lkl_macvlan_macaddr_mode_LKL_MACVLAN_MACADDR_SET: lkl_macvlan_macaddr_mode = 3;
pub type lkl_macvlan_macaddr_mode = ::std::os::raw::c_uint;
pub const LKL_IFLA_VRF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_VRF_TABLE: ::std::os::raw::c_uint = 1;
pub const __LKL__IFLA_VRF_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_67 = ::std::os::raw::c_uint;
pub const LKL_IFLA_VRF_PORT_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_VRF_PORT_TABLE: ::std::os::raw::c_uint = 1;
pub const __LKL__IFLA_VRF_PORT_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_68 = ::std::os::raw::c_uint;
pub const LKL_IFLA_MACSEC_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_MACSEC_SCI: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_MACSEC_PORT: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_MACSEC_ICV_LEN: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_MACSEC_CIPHER_SUITE: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_MACSEC_WINDOW: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_MACSEC_ENCODING_SA: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_MACSEC_ENCRYPT: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_MACSEC_PROTECT: ::std::os::raw::c_uint = 8;
pub const LKL_IFLA_MACSEC_INC_SCI: ::std::os::raw::c_uint = 9;
pub const LKL_IFLA_MACSEC_ES: ::std::os::raw::c_uint = 10;
pub const LKL_IFLA_MACSEC_SCB: ::std::os::raw::c_uint = 11;
pub const LKL_IFLA_MACSEC_REPLAY_PROTECT: ::std::os::raw::c_uint = 12;
pub const LKL_IFLA_MACSEC_VALIDATION: ::std::os::raw::c_uint = 13;
pub const LKL_IFLA_MACSEC_PAD: ::std::os::raw::c_uint = 14;
pub const LKL_IFLA_MACSEC_OFFLOAD: ::std::os::raw::c_uint = 15;
pub const __LKL__IFLA_MACSEC_MAX: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_69 = ::std::os::raw::c_uint;
pub const LKL_IFLA_XFRM_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_XFRM_LINK: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_XFRM_IF_ID: ::std::os::raw::c_uint = 2;
pub const __LKL__IFLA_XFRM_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_70 = ::std::os::raw::c_uint;
pub const lkl_macsec_validation_type_LKL_MACSEC_VALIDATE_DISABLED: lkl_macsec_validation_type = 0;
pub const lkl_macsec_validation_type_LKL_MACSEC_VALIDATE_CHECK: lkl_macsec_validation_type = 1;
pub const lkl_macsec_validation_type_LKL_MACSEC_VALIDATE_STRICT: lkl_macsec_validation_type = 2;
pub const lkl_macsec_validation_type___LKL__MACSEC_VALIDATE_END: lkl_macsec_validation_type = 3;
pub const lkl_macsec_validation_type_LKL_MACSEC_VALIDATE_MAX: lkl_macsec_validation_type = 2;
pub type lkl_macsec_validation_type = ::std::os::raw::c_uint;
pub const lkl_macsec_offload_LKL_MACSEC_OFFLOAD_OFF: lkl_macsec_offload = 0;
pub const lkl_macsec_offload_LKL_MACSEC_OFFLOAD_PHY: lkl_macsec_offload = 1;
pub const lkl_macsec_offload_LKL_MACSEC_OFFLOAD_MAC: lkl_macsec_offload = 2;
pub const lkl_macsec_offload___LKL__MACSEC_OFFLOAD_END: lkl_macsec_offload = 3;
pub const lkl_macsec_offload_LKL_MACSEC_OFFLOAD_MAX: lkl_macsec_offload = 2;
pub type lkl_macsec_offload = ::std::os::raw::c_uint;
pub const LKL_IFLA_IPVLAN_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_IPVLAN_MODE: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_IPVLAN_FLAGS: ::std::os::raw::c_uint = 2;
pub const __LKL__IFLA_IPVLAN_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_71 = ::std::os::raw::c_uint;
pub const lkl_ipvlan_mode_LKL_IPVLAN_MODE_L2: lkl_ipvlan_mode = 0;
pub const lkl_ipvlan_mode_LKL_IPVLAN_MODE_L3: lkl_ipvlan_mode = 1;
pub const lkl_ipvlan_mode_LKL_IPVLAN_MODE_L3S: lkl_ipvlan_mode = 2;
pub const lkl_ipvlan_mode_LKL_IPVLAN_MODE_MAX: lkl_ipvlan_mode = 3;
pub type lkl_ipvlan_mode = ::std::os::raw::c_uint;
pub const LKL_IFLA_VXLAN_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_VXLAN_ID: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_VXLAN_GROUP: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_VXLAN_LINK: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_VXLAN_LOCAL: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_VXLAN_TTL: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_VXLAN_TOS: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_VXLAN_LEARNING: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_VXLAN_AGEING: ::std::os::raw::c_uint = 8;
pub const LKL_IFLA_VXLAN_LIMIT: ::std::os::raw::c_uint = 9;
pub const LKL_IFLA_VXLAN_PORT_RANGE: ::std::os::raw::c_uint = 10;
pub const LKL_IFLA_VXLAN_PROXY: ::std::os::raw::c_uint = 11;
pub const LKL_IFLA_VXLAN_RSC: ::std::os::raw::c_uint = 12;
pub const LKL_IFLA_VXLAN_L2MISS: ::std::os::raw::c_uint = 13;
pub const LKL_IFLA_VXLAN_L3MISS: ::std::os::raw::c_uint = 14;
pub const LKL_IFLA_VXLAN_PORT: ::std::os::raw::c_uint = 15;
pub const LKL_IFLA_VXLAN_GROUP6: ::std::os::raw::c_uint = 16;
pub const LKL_IFLA_VXLAN_LOCAL6: ::std::os::raw::c_uint = 17;
pub const LKL_IFLA_VXLAN_UDP_CSUM: ::std::os::raw::c_uint = 18;
pub const LKL_IFLA_VXLAN_UDP_ZERO_CSUM6_TX: ::std::os::raw::c_uint = 19;
pub const LKL_IFLA_VXLAN_UDP_ZERO_CSUM6_RX: ::std::os::raw::c_uint = 20;
pub const LKL_IFLA_VXLAN_REMCSUM_TX: ::std::os::raw::c_uint = 21;
pub const LKL_IFLA_VXLAN_REMCSUM_RX: ::std::os::raw::c_uint = 22;
pub const LKL_IFLA_VXLAN_GBP: ::std::os::raw::c_uint = 23;
pub const LKL_IFLA_VXLAN_REMCSUM_NOPARTIAL: ::std::os::raw::c_uint = 24;
pub const LKL_IFLA_VXLAN_COLLECT_METADATA: ::std::os::raw::c_uint = 25;
pub const LKL_IFLA_VXLAN_LABEL: ::std::os::raw::c_uint = 26;
pub const LKL_IFLA_VXLAN_GPE: ::std::os::raw::c_uint = 27;
pub const LKL_IFLA_VXLAN_TTL_INHERIT: ::std::os::raw::c_uint = 28;
pub const LKL_IFLA_VXLAN_DF: ::std::os::raw::c_uint = 29;
pub const __LKL__IFLA_VXLAN_MAX: ::std::os::raw::c_uint = 30;
pub type _bindgen_ty_72 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vxlan_port_range {
    pub low: __lkl__be16,
    pub high: __lkl__be16,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vxlan_port_range() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vxlan_port_range>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_ifla_vxlan_port_range))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vxlan_port_range>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vxlan_port_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vxlan_port_range>())).low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vxlan_port_range),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vxlan_port_range>())).high as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vxlan_port_range),
            "::",
            stringify!(high)
        )
    );
}
pub const lkl_ifla_vxlan_df_LKL_VXLAN_DF_UNSET: lkl_ifla_vxlan_df = 0;
pub const lkl_ifla_vxlan_df_LKL_VXLAN_DF_SET: lkl_ifla_vxlan_df = 1;
pub const lkl_ifla_vxlan_df_LKL_VXLAN_DF_INHERIT: lkl_ifla_vxlan_df = 2;
pub const lkl_ifla_vxlan_df___LKL__VXLAN_DF_END: lkl_ifla_vxlan_df = 3;
pub const lkl_ifla_vxlan_df_LKL_VXLAN_DF_MAX: lkl_ifla_vxlan_df = 2;
pub type lkl_ifla_vxlan_df = ::std::os::raw::c_uint;
pub const LKL_IFLA_GENEVE_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_GENEVE_ID: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_GENEVE_REMOTE: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_GENEVE_TTL: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_GENEVE_TOS: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_GENEVE_PORT: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_GENEVE_COLLECT_METADATA: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_GENEVE_REMOTE6: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_GENEVE_UDP_CSUM: ::std::os::raw::c_uint = 8;
pub const LKL_IFLA_GENEVE_UDP_ZERO_CSUM6_TX: ::std::os::raw::c_uint = 9;
pub const LKL_IFLA_GENEVE_UDP_ZERO_CSUM6_RX: ::std::os::raw::c_uint = 10;
pub const LKL_IFLA_GENEVE_LABEL: ::std::os::raw::c_uint = 11;
pub const LKL_IFLA_GENEVE_TTL_INHERIT: ::std::os::raw::c_uint = 12;
pub const LKL_IFLA_GENEVE_DF: ::std::os::raw::c_uint = 13;
pub const __LKL__IFLA_GENEVE_MAX: ::std::os::raw::c_uint = 14;
pub type _bindgen_ty_73 = ::std::os::raw::c_uint;
pub const lkl_ifla_geneve_df_LKL_GENEVE_DF_UNSET: lkl_ifla_geneve_df = 0;
pub const lkl_ifla_geneve_df_LKL_GENEVE_DF_SET: lkl_ifla_geneve_df = 1;
pub const lkl_ifla_geneve_df_LKL_GENEVE_DF_INHERIT: lkl_ifla_geneve_df = 2;
pub const lkl_ifla_geneve_df___LKL__GENEVE_DF_END: lkl_ifla_geneve_df = 3;
pub const lkl_ifla_geneve_df_LKL_GENEVE_DF_MAX: lkl_ifla_geneve_df = 2;
pub type lkl_ifla_geneve_df = ::std::os::raw::c_uint;
pub const LKL_IFLA_BAREUDP_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_BAREUDP_PORT: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_BAREUDP_ETHERTYPE: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_BAREUDP_SRCPORT_MIN: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_BAREUDP_MULTIPROTO_MODE: ::std::os::raw::c_uint = 4;
pub const __LKL__IFLA_BAREUDP_MAX: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_74 = ::std::os::raw::c_uint;
pub const LKL_IFLA_PPP_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_PPP_DEV_FD: ::std::os::raw::c_uint = 1;
pub const __LKL__IFLA_PPP_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_75 = ::std::os::raw::c_uint;
pub const lkl_ifla_gtp_role_LKL_GTP_ROLE_GGSN: lkl_ifla_gtp_role = 0;
pub const lkl_ifla_gtp_role_LKL_GTP_ROLE_SGSN: lkl_ifla_gtp_role = 1;
pub type lkl_ifla_gtp_role = ::std::os::raw::c_uint;
pub const LKL_IFLA_GTP_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_GTP_FD0: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_GTP_FD1: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_GTP_PDP_HASHSIZE: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_GTP_ROLE: ::std::os::raw::c_uint = 4;
pub const __LKL__IFLA_GTP_MAX: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_76 = ::std::os::raw::c_uint;
pub const LKL_IFLA_BOND_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_BOND_MODE: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_BOND_ACTIVE_SLAVE: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_BOND_MIIMON: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_BOND_UPDELAY: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_BOND_DOWNDELAY: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_BOND_USE_CARRIER: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_BOND_ARP_INTERVAL: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_BOND_ARP_IP_TARGET: ::std::os::raw::c_uint = 8;
pub const LKL_IFLA_BOND_ARP_VALIDATE: ::std::os::raw::c_uint = 9;
pub const LKL_IFLA_BOND_ARP_ALL_TARGETS: ::std::os::raw::c_uint = 10;
pub const LKL_IFLA_BOND_PRIMARY: ::std::os::raw::c_uint = 11;
pub const LKL_IFLA_BOND_PRIMARY_RESELECT: ::std::os::raw::c_uint = 12;
pub const LKL_IFLA_BOND_FAIL_OVER_MAC: ::std::os::raw::c_uint = 13;
pub const LKL_IFLA_BOND_XMIT_HASH_POLICY: ::std::os::raw::c_uint = 14;
pub const LKL_IFLA_BOND_RESEND_IGMP: ::std::os::raw::c_uint = 15;
pub const LKL_IFLA_BOND_NUM_PEER_NOTIF: ::std::os::raw::c_uint = 16;
pub const LKL_IFLA_BOND_ALL_SLAVES_ACTIVE: ::std::os::raw::c_uint = 17;
pub const LKL_IFLA_BOND_MIN_LINKS: ::std::os::raw::c_uint = 18;
pub const LKL_IFLA_BOND_LP_INTERVAL: ::std::os::raw::c_uint = 19;
pub const LKL_IFLA_BOND_PACKETS_PER_SLAVE: ::std::os::raw::c_uint = 20;
pub const LKL_IFLA_BOND_AD_LACP_RATE: ::std::os::raw::c_uint = 21;
pub const LKL_IFLA_BOND_AD_SELECT: ::std::os::raw::c_uint = 22;
pub const LKL_IFLA_BOND_AD_INFO: ::std::os::raw::c_uint = 23;
pub const LKL_IFLA_BOND_AD_ACTOR_SYS_PRIO: ::std::os::raw::c_uint = 24;
pub const LKL_IFLA_BOND_AD_USER_PORT_KEY: ::std::os::raw::c_uint = 25;
pub const LKL_IFLA_BOND_AD_ACTOR_SYSTEM: ::std::os::raw::c_uint = 26;
pub const LKL_IFLA_BOND_TLB_DYNAMIC_LB: ::std::os::raw::c_uint = 27;
pub const LKL_IFLA_BOND_PEER_NOTIF_DELAY: ::std::os::raw::c_uint = 28;
pub const __LKL__IFLA_BOND_MAX: ::std::os::raw::c_uint = 29;
pub type _bindgen_ty_77 = ::std::os::raw::c_uint;
pub const LKL_IFLA_BOND_AD_INFO_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_BOND_AD_INFO_AGGREGATOR: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_BOND_AD_INFO_NUM_PORTS: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_BOND_AD_INFO_ACTOR_KEY: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_BOND_AD_INFO_PARTNER_KEY: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_BOND_AD_INFO_PARTNER_MAC: ::std::os::raw::c_uint = 5;
pub const __LKL__IFLA_BOND_AD_INFO_MAX: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_78 = ::std::os::raw::c_uint;
pub const LKL_IFLA_BOND_SLAVE_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_BOND_SLAVE_STATE: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_BOND_SLAVE_MII_STATUS: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_BOND_SLAVE_LINK_FAILURE_COUNT: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_BOND_SLAVE_PERM_HWADDR: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_BOND_SLAVE_QUEUE_ID: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_BOND_SLAVE_AD_AGGREGATOR_ID: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE: ::std::os::raw::c_uint = 8;
pub const __LKL__IFLA_BOND_SLAVE_MAX: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_79 = ::std::os::raw::c_uint;
pub const LKL_IFLA_VF_INFO_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_VF_INFO: ::std::os::raw::c_uint = 1;
pub const __LKL__IFLA_VF_INFO_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_80 = ::std::os::raw::c_uint;
pub const LKL_IFLA_VF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_VF_MAC: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_VF_VLAN: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_VF_TX_RATE: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_VF_SPOOFCHK: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_VF_LINK_STATE: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_VF_RATE: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_VF_RSS_QUERY_EN: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_VF_STATS: ::std::os::raw::c_uint = 8;
pub const LKL_IFLA_VF_TRUST: ::std::os::raw::c_uint = 9;
pub const LKL_IFLA_VF_IB_NODE_GUID: ::std::os::raw::c_uint = 10;
pub const LKL_IFLA_VF_IB_PORT_GUID: ::std::os::raw::c_uint = 11;
pub const LKL_IFLA_VF_VLAN_LIST: ::std::os::raw::c_uint = 12;
pub const LKL_IFLA_VF_BROADCAST: ::std::os::raw::c_uint = 13;
pub const __LKL__IFLA_VF_MAX: ::std::os::raw::c_uint = 14;
pub type _bindgen_ty_81 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vf_mac {
    pub vf: __lkl__u32,
    pub mac: [__lkl__u8; 32usize],
}
#[test]
fn bindgen_test_layout_lkl_ifla_vf_mac() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vf_mac>(),
        36usize,
        concat!("Size of: ", stringify!(lkl_ifla_vf_mac))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vf_mac>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vf_mac))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_mac>())).vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_mac),
            "::",
            stringify!(vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_mac>())).mac as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_mac),
            "::",
            stringify!(mac)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vf_broadcast {
    pub broadcast: [__lkl__u8; 32usize],
}
#[test]
fn bindgen_test_layout_lkl_ifla_vf_broadcast() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vf_broadcast>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_ifla_vf_broadcast))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vf_broadcast>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vf_broadcast))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_broadcast>())).broadcast as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_broadcast),
            "::",
            stringify!(broadcast)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vf_vlan {
    pub vf: __lkl__u32,
    pub vlan: __lkl__u32,
    pub qos: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vf_vlan() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vf_vlan>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_ifla_vf_vlan))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vf_vlan>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vf_vlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_vlan>())).vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_vlan),
            "::",
            stringify!(vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_vlan>())).vlan as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_vlan),
            "::",
            stringify!(vlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_vlan>())).qos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_vlan),
            "::",
            stringify!(qos)
        )
    );
}
pub const LKL_IFLA_VF_VLAN_INFO_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_VF_VLAN_INFO: ::std::os::raw::c_uint = 1;
pub const __LKL__IFLA_VF_VLAN_INFO_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_82 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vf_vlan_info {
    pub vf: __lkl__u32,
    pub vlan: __lkl__u32,
    pub qos: __lkl__u32,
    pub vlan_proto: __lkl__be16,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vf_vlan_info() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vf_vlan_info>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_ifla_vf_vlan_info))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vf_vlan_info>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vf_vlan_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_vlan_info>())).vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_vlan_info),
            "::",
            stringify!(vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_vlan_info>())).vlan as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_vlan_info),
            "::",
            stringify!(vlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_vlan_info>())).qos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_vlan_info),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifla_vf_vlan_info>())).vlan_proto as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_vlan_info),
            "::",
            stringify!(vlan_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vf_tx_rate {
    pub vf: __lkl__u32,
    pub rate: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vf_tx_rate() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vf_tx_rate>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ifla_vf_tx_rate))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vf_tx_rate>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vf_tx_rate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_tx_rate>())).vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_tx_rate),
            "::",
            stringify!(vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_tx_rate>())).rate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_tx_rate),
            "::",
            stringify!(rate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vf_rate {
    pub vf: __lkl__u32,
    pub min_tx_rate: __lkl__u32,
    pub max_tx_rate: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vf_rate() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vf_rate>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_ifla_vf_rate))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vf_rate>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vf_rate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_rate>())).vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_rate),
            "::",
            stringify!(vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_rate>())).min_tx_rate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_rate),
            "::",
            stringify!(min_tx_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_rate>())).max_tx_rate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_rate),
            "::",
            stringify!(max_tx_rate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vf_spoofchk {
    pub vf: __lkl__u32,
    pub setting: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vf_spoofchk() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vf_spoofchk>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ifla_vf_spoofchk))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vf_spoofchk>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vf_spoofchk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_spoofchk>())).vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_spoofchk),
            "::",
            stringify!(vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_spoofchk>())).setting as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_spoofchk),
            "::",
            stringify!(setting)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vf_guid {
    pub vf: __lkl__u32,
    pub guid: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vf_guid() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vf_guid>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_ifla_vf_guid))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vf_guid>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vf_guid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_guid>())).vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_guid),
            "::",
            stringify!(vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_guid>())).guid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_guid),
            "::",
            stringify!(guid)
        )
    );
}
pub const LKL_IFLA_VF_LINK_STATE_AUTO: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_VF_LINK_STATE_ENABLE: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_VF_LINK_STATE_DISABLE: ::std::os::raw::c_uint = 2;
pub const __LKL__IFLA_VF_LINK_STATE_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_83 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vf_link_state {
    pub vf: __lkl__u32,
    pub link_state: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vf_link_state() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vf_link_state>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ifla_vf_link_state))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vf_link_state>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vf_link_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_link_state>())).vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_link_state),
            "::",
            stringify!(vf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifla_vf_link_state>())).link_state as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_link_state),
            "::",
            stringify!(link_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vf_rss_query_en {
    pub vf: __lkl__u32,
    pub setting: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vf_rss_query_en() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vf_rss_query_en>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ifla_vf_rss_query_en))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vf_rss_query_en>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vf_rss_query_en))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_rss_query_en>())).vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_rss_query_en),
            "::",
            stringify!(vf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifla_vf_rss_query_en>())).setting as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_rss_query_en),
            "::",
            stringify!(setting)
        )
    );
}
pub const LKL_IFLA_VF_STATS_RX_PACKETS: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_VF_STATS_TX_PACKETS: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_VF_STATS_RX_BYTES: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_VF_STATS_TX_BYTES: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_VF_STATS_BROADCAST: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_VF_STATS_MULTICAST: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_VF_STATS_PAD: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_VF_STATS_RX_DROPPED: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_VF_STATS_TX_DROPPED: ::std::os::raw::c_uint = 8;
pub const __LKL__IFLA_VF_STATS_MAX: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_84 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_vf_trust {
    pub vf: __lkl__u32,
    pub setting: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifla_vf_trust() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_vf_trust>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ifla_vf_trust))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_vf_trust>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_vf_trust))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_trust>())).vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_trust),
            "::",
            stringify!(vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_vf_trust>())).setting as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_vf_trust),
            "::",
            stringify!(setting)
        )
    );
}
pub const LKL_IFLA_VF_PORT_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_VF_PORT: ::std::os::raw::c_uint = 1;
pub const __LKL__IFLA_VF_PORT_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_85 = ::std::os::raw::c_uint;
pub const LKL_IFLA_PORT_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_PORT_VF: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_PORT_PROFILE: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_PORT_VSI_TYPE: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_PORT_INSTANCE_UUID: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_PORT_HOST_UUID: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_PORT_REQUEST: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_PORT_RESPONSE: ::std::os::raw::c_uint = 7;
pub const __LKL__IFLA_PORT_MAX: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_86 = ::std::os::raw::c_uint;
pub const LKL_PORT_REQUEST_PREASSOCIATE: ::std::os::raw::c_uint = 0;
pub const LKL_PORT_REQUEST_PREASSOCIATE_RR: ::std::os::raw::c_uint = 1;
pub const LKL_PORT_REQUEST_ASSOCIATE: ::std::os::raw::c_uint = 2;
pub const LKL_PORT_REQUEST_DISASSOCIATE: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_87 = ::std::os::raw::c_uint;
pub const LKL_PORT_VDP_RESPONSE_SUCCESS: ::std::os::raw::c_uint = 0;
pub const LKL_PORT_VDP_RESPONSE_INVALID_FORMAT: ::std::os::raw::c_uint = 1;
pub const LKL_PORT_VDP_RESPONSE_INSUFFICIENT_RESOURCES: ::std::os::raw::c_uint = 2;
pub const LKL_PORT_VDP_RESPONSE_UNUSED_VTID: ::std::os::raw::c_uint = 3;
pub const LKL_PORT_VDP_RESPONSE_VTID_VIOLATION: ::std::os::raw::c_uint = 4;
pub const LKL_PORT_VDP_RESPONSE_VTID_VERSION_VIOALTION: ::std::os::raw::c_uint = 5;
pub const LKL_PORT_VDP_RESPONSE_OUT_OF_SYNC: ::std::os::raw::c_uint = 6;
pub const LKL_PORT_PROFILE_RESPONSE_SUCCESS: ::std::os::raw::c_uint = 256;
pub const LKL_PORT_PROFILE_RESPONSE_INPROGRESS: ::std::os::raw::c_uint = 257;
pub const LKL_PORT_PROFILE_RESPONSE_INVALID: ::std::os::raw::c_uint = 258;
pub const LKL_PORT_PROFILE_RESPONSE_BADSTATE: ::std::os::raw::c_uint = 259;
pub const LKL_PORT_PROFILE_RESPONSE_INSUFFICIENT_RESOURCES: ::std::os::raw::c_uint = 260;
pub const LKL_PORT_PROFILE_RESPONSE_ERROR: ::std::os::raw::c_uint = 261;
pub type _bindgen_ty_88 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_port_vsi {
    pub vsi_mgr_id: __lkl__u8,
    pub vsi_type_id: [__lkl__u8; 3usize],
    pub vsi_type_version: __lkl__u8,
    pub pad: [__lkl__u8; 3usize],
}
#[test]
fn bindgen_test_layout_lkl_ifla_port_vsi() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_port_vsi>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ifla_port_vsi))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_port_vsi>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_ifla_port_vsi))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_port_vsi>())).vsi_mgr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_port_vsi),
            "::",
            stringify!(vsi_mgr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_port_vsi>())).vsi_type_id as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_port_vsi),
            "::",
            stringify!(vsi_type_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_ifla_port_vsi>())).vsi_type_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_port_vsi),
            "::",
            stringify!(vsi_type_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_port_vsi>())).pad as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_port_vsi),
            "::",
            stringify!(pad)
        )
    );
}
pub const LKL_IFLA_IPOIB_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_IPOIB_PKEY: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_IPOIB_MODE: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_IPOIB_UMCAST: ::std::os::raw::c_uint = 3;
pub const __LKL__IFLA_IPOIB_MAX: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_89 = ::std::os::raw::c_uint;
pub const LKL_IPOIB_MODE_DATAGRAM: ::std::os::raw::c_uint = 0;
pub const LKL_IPOIB_MODE_CONNECTED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_90 = ::std::os::raw::c_uint;
pub const LKL_HSR_PROTOCOL_HSR: ::std::os::raw::c_uint = 0;
pub const LKL_HSR_PROTOCOL_PRP: ::std::os::raw::c_uint = 1;
pub const LKL_HSR_PROTOCOL_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_91 = ::std::os::raw::c_uint;
pub const LKL_IFLA_HSR_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_HSR_SLAVE1: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_HSR_SLAVE2: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_HSR_MULTICAST_SPEC: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_HSR_SUPERVISION_ADDR: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_HSR_SEQ_NR: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_HSR_VERSION: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_HSR_PROTOCOL: ::std::os::raw::c_uint = 7;
pub const __LKL__IFLA_HSR_MAX: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_92 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_if_stats_msg {
    pub family: __lkl__u8,
    pub pad1: __lkl__u8,
    pub pad2: __lkl__u16,
    pub ifindex: __lkl__u32,
    pub filter_mask: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_if_stats_msg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_if_stats_msg>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_if_stats_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_if_stats_msg>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_if_stats_msg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_if_stats_msg>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_stats_msg),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_if_stats_msg>())).pad1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_stats_msg),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_if_stats_msg>())).pad2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_stats_msg),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_if_stats_msg>())).ifindex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_stats_msg),
            "::",
            stringify!(ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_if_stats_msg>())).filter_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_if_stats_msg),
            "::",
            stringify!(filter_mask)
        )
    );
}
pub const LKL_IFLA_STATS_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_STATS_LINK_64: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_STATS_LINK_XSTATS: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_STATS_LINK_XSTATS_SLAVE: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_STATS_LINK_OFFLOAD_XSTATS: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_STATS_AF_SPEC: ::std::os::raw::c_uint = 5;
pub const __LKL__IFLA_STATS_MAX: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_93 = ::std::os::raw::c_uint;
pub const LKL_LINK_XSTATS_TYPE_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_LINK_XSTATS_TYPE_BRIDGE: ::std::os::raw::c_uint = 1;
pub const LKL_LINK_XSTATS_TYPE_BOND: ::std::os::raw::c_uint = 2;
pub const __LKL__LINK_XSTATS_TYPE_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_94 = ::std::os::raw::c_uint;
pub const LKL_IFLA_OFFLOAD_XSTATS_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_OFFLOAD_XSTATS_CPU_HIT: ::std::os::raw::c_uint = 1;
pub const __LKL__IFLA_OFFLOAD_XSTATS_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_95 = ::std::os::raw::c_uint;
pub const LKL_XDP_ATTACHED_NONE: ::std::os::raw::c_uint = 0;
pub const LKL_XDP_ATTACHED_DRV: ::std::os::raw::c_uint = 1;
pub const LKL_XDP_ATTACHED_SKB: ::std::os::raw::c_uint = 2;
pub const LKL_XDP_ATTACHED_HW: ::std::os::raw::c_uint = 3;
pub const LKL_XDP_ATTACHED_MULTI: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_96 = ::std::os::raw::c_uint;
pub const LKL_IFLA_XDP_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_XDP_FD: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_XDP_ATTACHED: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_XDP_FLAGS: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_XDP_PROG_ID: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_XDP_DRV_PROG_ID: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_XDP_SKB_PROG_ID: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_XDP_HW_PROG_ID: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_XDP_EXPECTED_FD: ::std::os::raw::c_uint = 8;
pub const __LKL__IFLA_XDP_MAX: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_97 = ::std::os::raw::c_uint;
pub const LKL_IFLA_EVENT_NONE: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_EVENT_REBOOT: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_EVENT_FEATURES: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_EVENT_BONDING_FAILOVER: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_EVENT_NOTIFY_PEERS: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_EVENT_IGMP_RESEND: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_EVENT_BONDING_OPTIONS: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_98 = ::std::os::raw::c_uint;
pub const LKL_IFLA_TUN_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_TUN_OWNER: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_TUN_GROUP: ::std::os::raw::c_uint = 2;
pub const LKL_IFLA_TUN_TYPE: ::std::os::raw::c_uint = 3;
pub const LKL_IFLA_TUN_PI: ::std::os::raw::c_uint = 4;
pub const LKL_IFLA_TUN_VNET_HDR: ::std::os::raw::c_uint = 5;
pub const LKL_IFLA_TUN_PERSIST: ::std::os::raw::c_uint = 6;
pub const LKL_IFLA_TUN_MULTI_QUEUE: ::std::os::raw::c_uint = 7;
pub const LKL_IFLA_TUN_NUM_QUEUES: ::std::os::raw::c_uint = 8;
pub const LKL_IFLA_TUN_NUM_DISABLED_QUEUES: ::std::os::raw::c_uint = 9;
pub const __LKL__IFLA_TUN_MAX: ::std::os::raw::c_uint = 10;
pub type _bindgen_ty_99 = ::std::os::raw::c_uint;
pub const LKL_IFLA_RMNET_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFLA_RMNET_MUX_ID: ::std::os::raw::c_uint = 1;
pub const LKL_IFLA_RMNET_FLAGS: ::std::os::raw::c_uint = 2;
pub const __LKL__IFLA_RMNET_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_100 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifla_rmnet_flags {
    pub flags: __lkl__u32,
    pub mask: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifla_rmnet_flags() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifla_rmnet_flags>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ifla_rmnet_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifla_rmnet_flags>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifla_rmnet_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_rmnet_flags>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_rmnet_flags),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifla_rmnet_flags>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifla_rmnet_flags),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifaddrmsg {
    pub ifa_family: __lkl__u8,
    pub ifa_prefixlen: __lkl__u8,
    pub ifa_flags: __lkl__u8,
    pub ifa_scope: __lkl__u8,
    pub ifa_index: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifaddrmsg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifaddrmsg>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_ifaddrmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifaddrmsg>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifaddrmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifaddrmsg>())).ifa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifaddrmsg),
            "::",
            stringify!(ifa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifaddrmsg>())).ifa_prefixlen as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifaddrmsg),
            "::",
            stringify!(ifa_prefixlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifaddrmsg>())).ifa_flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifaddrmsg),
            "::",
            stringify!(ifa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifaddrmsg>())).ifa_scope as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifaddrmsg),
            "::",
            stringify!(ifa_scope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifaddrmsg>())).ifa_index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifaddrmsg),
            "::",
            stringify!(ifa_index)
        )
    );
}
pub const LKL_IFA_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_IFA_ADDRESS: ::std::os::raw::c_uint = 1;
pub const LKL_IFA_LOCAL: ::std::os::raw::c_uint = 2;
pub const LKL_IFA_LABEL: ::std::os::raw::c_uint = 3;
pub const LKL_IFA_BROADCAST: ::std::os::raw::c_uint = 4;
pub const LKL_IFA_ANYCAST: ::std::os::raw::c_uint = 5;
pub const LKL_IFA_CACHEINFO: ::std::os::raw::c_uint = 6;
pub const LKL_IFA_MULTICAST: ::std::os::raw::c_uint = 7;
pub const LKL_IFA_FLAGS: ::std::os::raw::c_uint = 8;
pub const LKL_IFA_RT_PRIORITY: ::std::os::raw::c_uint = 9;
pub const LKL_IFA_TARGET_NETNSID: ::std::os::raw::c_uint = 10;
pub const __LKL__IFA_MAX: ::std::os::raw::c_uint = 11;
pub type _bindgen_ty_101 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifa_cacheinfo {
    pub ifa_prefered: __lkl__u32,
    pub ifa_valid: __lkl__u32,
    pub cstamp: __lkl__u32,
    pub tstamp: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_ifa_cacheinfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifa_cacheinfo>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_ifa_cacheinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifa_cacheinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifa_cacheinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifa_cacheinfo>())).ifa_prefered as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifa_cacheinfo),
            "::",
            stringify!(ifa_prefered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifa_cacheinfo>())).ifa_valid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifa_cacheinfo),
            "::",
            stringify!(ifa_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifa_cacheinfo>())).cstamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifa_cacheinfo),
            "::",
            stringify!(cstamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifa_cacheinfo>())).tstamp as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifa_cacheinfo),
            "::",
            stringify!(tstamp)
        )
    );
}
pub const LKL_RTM_BASE: ::std::os::raw::c_uint = 16;
pub const LKL_RTM_NEWLINK: ::std::os::raw::c_uint = 16;
pub const LKL_RTM_DELLINK: ::std::os::raw::c_uint = 17;
pub const LKL_RTM_GETLINK: ::std::os::raw::c_uint = 18;
pub const LKL_RTM_SETLINK: ::std::os::raw::c_uint = 19;
pub const LKL_RTM_NEWADDR: ::std::os::raw::c_uint = 20;
pub const LKL_RTM_DELADDR: ::std::os::raw::c_uint = 21;
pub const LKL_RTM_GETADDR: ::std::os::raw::c_uint = 22;
pub const LKL_RTM_NEWROUTE: ::std::os::raw::c_uint = 24;
pub const LKL_RTM_DELROUTE: ::std::os::raw::c_uint = 25;
pub const LKL_RTM_GETROUTE: ::std::os::raw::c_uint = 26;
pub const LKL_RTM_NEWNEIGH: ::std::os::raw::c_uint = 28;
pub const LKL_RTM_DELNEIGH: ::std::os::raw::c_uint = 29;
pub const LKL_RTM_GETNEIGH: ::std::os::raw::c_uint = 30;
pub const LKL_RTM_NEWRULE: ::std::os::raw::c_uint = 32;
pub const LKL_RTM_DELRULE: ::std::os::raw::c_uint = 33;
pub const LKL_RTM_GETRULE: ::std::os::raw::c_uint = 34;
pub const LKL_RTM_NEWQDISC: ::std::os::raw::c_uint = 36;
pub const LKL_RTM_DELQDISC: ::std::os::raw::c_uint = 37;
pub const LKL_RTM_GETQDISC: ::std::os::raw::c_uint = 38;
pub const LKL_RTM_NEWTCLASS: ::std::os::raw::c_uint = 40;
pub const LKL_RTM_DELTCLASS: ::std::os::raw::c_uint = 41;
pub const LKL_RTM_GETTCLASS: ::std::os::raw::c_uint = 42;
pub const LKL_RTM_NEWTFILTER: ::std::os::raw::c_uint = 44;
pub const LKL_RTM_DELTFILTER: ::std::os::raw::c_uint = 45;
pub const LKL_RTM_GETTFILTER: ::std::os::raw::c_uint = 46;
pub const LKL_RTM_NEWACTION: ::std::os::raw::c_uint = 48;
pub const LKL_RTM_DELACTION: ::std::os::raw::c_uint = 49;
pub const LKL_RTM_GETACTION: ::std::os::raw::c_uint = 50;
pub const LKL_RTM_NEWPREFIX: ::std::os::raw::c_uint = 52;
pub const LKL_RTM_GETMULTICAST: ::std::os::raw::c_uint = 58;
pub const LKL_RTM_GETANYCAST: ::std::os::raw::c_uint = 62;
pub const LKL_RTM_NEWNEIGHTBL: ::std::os::raw::c_uint = 64;
pub const LKL_RTM_GETNEIGHTBL: ::std::os::raw::c_uint = 66;
pub const LKL_RTM_SETNEIGHTBL: ::std::os::raw::c_uint = 67;
pub const LKL_RTM_NEWNDUSEROPT: ::std::os::raw::c_uint = 68;
pub const LKL_RTM_NEWADDRLABEL: ::std::os::raw::c_uint = 72;
pub const LKL_RTM_DELADDRLABEL: ::std::os::raw::c_uint = 73;
pub const LKL_RTM_GETADDRLABEL: ::std::os::raw::c_uint = 74;
pub const LKL_RTM_GETDCB: ::std::os::raw::c_uint = 78;
pub const LKL_RTM_SETDCB: ::std::os::raw::c_uint = 79;
pub const LKL_RTM_NEWNETCONF: ::std::os::raw::c_uint = 80;
pub const LKL_RTM_DELNETCONF: ::std::os::raw::c_uint = 81;
pub const LKL_RTM_GETNETCONF: ::std::os::raw::c_uint = 82;
pub const LKL_RTM_NEWMDB: ::std::os::raw::c_uint = 84;
pub const LKL_RTM_DELMDB: ::std::os::raw::c_uint = 85;
pub const LKL_RTM_GETMDB: ::std::os::raw::c_uint = 86;
pub const LKL_RTM_NEWNSID: ::std::os::raw::c_uint = 88;
pub const LKL_RTM_DELNSID: ::std::os::raw::c_uint = 89;
pub const LKL_RTM_GETNSID: ::std::os::raw::c_uint = 90;
pub const LKL_RTM_NEWSTATS: ::std::os::raw::c_uint = 92;
pub const LKL_RTM_GETSTATS: ::std::os::raw::c_uint = 94;
pub const LKL_RTM_NEWCACHEREPORT: ::std::os::raw::c_uint = 96;
pub const LKL_RTM_NEWCHAIN: ::std::os::raw::c_uint = 100;
pub const LKL_RTM_DELCHAIN: ::std::os::raw::c_uint = 101;
pub const LKL_RTM_GETCHAIN: ::std::os::raw::c_uint = 102;
pub const LKL_RTM_NEWNEXTHOP: ::std::os::raw::c_uint = 104;
pub const LKL_RTM_DELNEXTHOP: ::std::os::raw::c_uint = 105;
pub const LKL_RTM_GETNEXTHOP: ::std::os::raw::c_uint = 106;
pub const LKL_RTM_NEWLINKPROP: ::std::os::raw::c_uint = 108;
pub const LKL_RTM_DELLINKPROP: ::std::os::raw::c_uint = 109;
pub const LKL_RTM_GETLINKPROP: ::std::os::raw::c_uint = 110;
pub const LKL_RTM_NEWVLAN: ::std::os::raw::c_uint = 112;
pub const LKL_RTM_DELVLAN: ::std::os::raw::c_uint = 113;
pub const LKL_RTM_GETVLAN: ::std::os::raw::c_uint = 114;
pub const __LKL__RTM_MAX: ::std::os::raw::c_uint = 115;
#[doc = "\t\tRouting/neighbour discovery messages."]
pub type _bindgen_ty_102 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rtattr {
    pub rta_len: ::std::os::raw::c_ushort,
    pub rta_type: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_lkl_rtattr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rtattr>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_rtattr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rtattr>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_rtattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtattr>())).rta_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtattr),
            "::",
            stringify!(rta_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtattr>())).rta_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtattr),
            "::",
            stringify!(rta_type)
        )
    );
}
#[doc = "\t\tDefinitions used in routing table administration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rtmsg {
    pub rtm_family: ::std::os::raw::c_uchar,
    pub rtm_dst_len: ::std::os::raw::c_uchar,
    pub rtm_src_len: ::std::os::raw::c_uchar,
    pub rtm_tos: ::std::os::raw::c_uchar,
    pub rtm_table: ::std::os::raw::c_uchar,
    pub rtm_protocol: ::std::os::raw::c_uchar,
    pub rtm_scope: ::std::os::raw::c_uchar,
    pub rtm_type: ::std::os::raw::c_uchar,
    pub rtm_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_rtmsg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rtmsg>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_rtmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rtmsg>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_rtmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtmsg>())).rtm_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtmsg),
            "::",
            stringify!(rtm_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtmsg>())).rtm_dst_len as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtmsg),
            "::",
            stringify!(rtm_dst_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtmsg>())).rtm_src_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtmsg),
            "::",
            stringify!(rtm_src_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtmsg>())).rtm_tos as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtmsg),
            "::",
            stringify!(rtm_tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtmsg>())).rtm_table as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtmsg),
            "::",
            stringify!(rtm_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtmsg>())).rtm_protocol as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtmsg),
            "::",
            stringify!(rtm_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtmsg>())).rtm_scope as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtmsg),
            "::",
            stringify!(rtm_scope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtmsg>())).rtm_type as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtmsg),
            "::",
            stringify!(rtm_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtmsg>())).rtm_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtmsg),
            "::",
            stringify!(rtm_flags)
        )
    );
}
pub const LKL_RTN_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_RTN_UNICAST: ::std::os::raw::c_uint = 1;
pub const LKL_RTN_LOCAL: ::std::os::raw::c_uint = 2;
pub const LKL_RTN_BROADCAST: ::std::os::raw::c_uint = 3;
pub const LKL_RTN_ANYCAST: ::std::os::raw::c_uint = 4;
pub const LKL_RTN_MULTICAST: ::std::os::raw::c_uint = 5;
pub const LKL_RTN_BLACKHOLE: ::std::os::raw::c_uint = 6;
pub const LKL_RTN_UNREACHABLE: ::std::os::raw::c_uint = 7;
pub const LKL_RTN_PROHIBIT: ::std::os::raw::c_uint = 8;
pub const LKL_RTN_THROW: ::std::os::raw::c_uint = 9;
pub const LKL_RTN_NAT: ::std::os::raw::c_uint = 10;
pub const LKL_RTN_XRESOLVE: ::std::os::raw::c_uint = 11;
pub const __LKL__RTN_MAX: ::std::os::raw::c_uint = 12;
pub type _bindgen_ty_103 = ::std::os::raw::c_uint;
pub const lkl_rt_scope_t_LKL_RT_SCOPE_UNIVERSE: lkl_rt_scope_t = 0;
pub const lkl_rt_scope_t_LKL_RT_SCOPE_SITE: lkl_rt_scope_t = 200;
pub const lkl_rt_scope_t_LKL_RT_SCOPE_LINK: lkl_rt_scope_t = 253;
pub const lkl_rt_scope_t_LKL_RT_SCOPE_HOST: lkl_rt_scope_t = 254;
pub const lkl_rt_scope_t_LKL_RT_SCOPE_NOWHERE: lkl_rt_scope_t = 255;
pub type lkl_rt_scope_t = ::std::os::raw::c_uint;
pub const lkl_rt_class_t_LKL_RT_TABLE_UNSPEC: lkl_rt_class_t = 0;
pub const lkl_rt_class_t_LKL_RT_TABLE_COMPAT: lkl_rt_class_t = 252;
pub const lkl_rt_class_t_LKL_RT_TABLE_DEFAULT: lkl_rt_class_t = 253;
pub const lkl_rt_class_t_LKL_RT_TABLE_MAIN: lkl_rt_class_t = 254;
pub const lkl_rt_class_t_LKL_RT_TABLE_LOCAL: lkl_rt_class_t = 255;
pub const lkl_rt_class_t_LKL_RT_TABLE_MAX: lkl_rt_class_t = 4294967295;
pub type lkl_rt_class_t = ::std::os::raw::c_uint;
pub const lkl_rtattr_type_t_LKL_RTA_UNSPEC: lkl_rtattr_type_t = 0;
pub const lkl_rtattr_type_t_LKL_RTA_DST: lkl_rtattr_type_t = 1;
pub const lkl_rtattr_type_t_LKL_RTA_SRC: lkl_rtattr_type_t = 2;
pub const lkl_rtattr_type_t_LKL_RTA_IIF: lkl_rtattr_type_t = 3;
pub const lkl_rtattr_type_t_LKL_RTA_OIF: lkl_rtattr_type_t = 4;
pub const lkl_rtattr_type_t_LKL_RTA_GATEWAY: lkl_rtattr_type_t = 5;
pub const lkl_rtattr_type_t_LKL_RTA_PRIORITY: lkl_rtattr_type_t = 6;
pub const lkl_rtattr_type_t_LKL_RTA_PREFSRC: lkl_rtattr_type_t = 7;
pub const lkl_rtattr_type_t_LKL_RTA_METRICS: lkl_rtattr_type_t = 8;
pub const lkl_rtattr_type_t_LKL_RTA_MULTIPATH: lkl_rtattr_type_t = 9;
pub const lkl_rtattr_type_t_LKL_RTA_PROTOINFO: lkl_rtattr_type_t = 10;
pub const lkl_rtattr_type_t_LKL_RTA_FLOW: lkl_rtattr_type_t = 11;
pub const lkl_rtattr_type_t_LKL_RTA_CACHEINFO: lkl_rtattr_type_t = 12;
pub const lkl_rtattr_type_t_LKL_RTA_SESSION: lkl_rtattr_type_t = 13;
pub const lkl_rtattr_type_t_LKL_RTA_MP_ALGO: lkl_rtattr_type_t = 14;
pub const lkl_rtattr_type_t_LKL_RTA_TABLE: lkl_rtattr_type_t = 15;
pub const lkl_rtattr_type_t_LKL_RTA_MARK: lkl_rtattr_type_t = 16;
pub const lkl_rtattr_type_t_LKL_RTA_MFC_STATS: lkl_rtattr_type_t = 17;
pub const lkl_rtattr_type_t_LKL_RTA_VIA: lkl_rtattr_type_t = 18;
pub const lkl_rtattr_type_t_LKL_RTA_NEWDST: lkl_rtattr_type_t = 19;
pub const lkl_rtattr_type_t_LKL_RTA_PREF: lkl_rtattr_type_t = 20;
pub const lkl_rtattr_type_t_LKL_RTA_ENCAP_TYPE: lkl_rtattr_type_t = 21;
pub const lkl_rtattr_type_t_LKL_RTA_ENCAP: lkl_rtattr_type_t = 22;
pub const lkl_rtattr_type_t_LKL_RTA_EXPIRES: lkl_rtattr_type_t = 23;
pub const lkl_rtattr_type_t_LKL_RTA_PAD: lkl_rtattr_type_t = 24;
pub const lkl_rtattr_type_t_LKL_RTA_UID: lkl_rtattr_type_t = 25;
pub const lkl_rtattr_type_t_LKL_RTA_TTL_PROPAGATE: lkl_rtattr_type_t = 26;
pub const lkl_rtattr_type_t_LKL_RTA_IP_PROTO: lkl_rtattr_type_t = 27;
pub const lkl_rtattr_type_t_LKL_RTA_SPORT: lkl_rtattr_type_t = 28;
pub const lkl_rtattr_type_t_LKL_RTA_DPORT: lkl_rtattr_type_t = 29;
pub const lkl_rtattr_type_t_LKL_RTA_NH_ID: lkl_rtattr_type_t = 30;
pub const lkl_rtattr_type_t___LKL__RTA_MAX: lkl_rtattr_type_t = 31;
pub type lkl_rtattr_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rtnexthop {
    pub rtnh_len: ::std::os::raw::c_ushort,
    pub rtnh_flags: ::std::os::raw::c_uchar,
    pub rtnh_hops: ::std::os::raw::c_uchar,
    pub rtnh_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lkl_rtnexthop() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rtnexthop>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_rtnexthop))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rtnexthop>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_rtnexthop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnexthop>())).rtnh_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnexthop),
            "::",
            stringify!(rtnh_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnexthop>())).rtnh_flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnexthop),
            "::",
            stringify!(rtnh_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnexthop>())).rtnh_hops as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnexthop),
            "::",
            stringify!(rtnh_hops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtnexthop>())).rtnh_ifindex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtnexthop),
            "::",
            stringify!(rtnh_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_rtvia {
    pub rtvia_family: __lkl__kernel_sa_family_t,
    pub rtvia_addr: __IncompleteArrayField<__lkl__u8>,
}
#[test]
fn bindgen_test_layout_lkl_rtvia() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rtvia>(),
        2usize,
        concat!("Size of: ", stringify!(lkl_rtvia))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rtvia>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_rtvia))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtvia>())).rtvia_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtvia),
            "::",
            stringify!(rtvia_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtvia>())).rtvia_addr as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtvia),
            "::",
            stringify!(rtvia_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rta_cacheinfo {
    pub rta_clntref: __lkl__u32,
    pub rta_lastuse: __lkl__u32,
    pub rta_expires: __lkl__s32,
    pub rta_error: __lkl__u32,
    pub rta_used: __lkl__u32,
    pub rta_id: __lkl__u32,
    pub rta_ts: __lkl__u32,
    pub rta_tsage: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_rta_cacheinfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rta_cacheinfo>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_rta_cacheinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rta_cacheinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_rta_cacheinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_cacheinfo>())).rta_clntref as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_cacheinfo),
            "::",
            stringify!(rta_clntref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_cacheinfo>())).rta_lastuse as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_cacheinfo),
            "::",
            stringify!(rta_lastuse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_cacheinfo>())).rta_expires as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_cacheinfo),
            "::",
            stringify!(rta_expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_cacheinfo>())).rta_error as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_cacheinfo),
            "::",
            stringify!(rta_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_cacheinfo>())).rta_used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_cacheinfo),
            "::",
            stringify!(rta_used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_cacheinfo>())).rta_id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_cacheinfo),
            "::",
            stringify!(rta_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_cacheinfo>())).rta_ts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_cacheinfo),
            "::",
            stringify!(rta_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_cacheinfo>())).rta_tsage as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_cacheinfo),
            "::",
            stringify!(rta_tsage)
        )
    );
}
pub const LKL_RTAX_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_RTAX_LOCK: ::std::os::raw::c_uint = 1;
pub const LKL_RTAX_MTU: ::std::os::raw::c_uint = 2;
pub const LKL_RTAX_WINDOW: ::std::os::raw::c_uint = 3;
pub const LKL_RTAX_RTT: ::std::os::raw::c_uint = 4;
pub const LKL_RTAX_RTTVAR: ::std::os::raw::c_uint = 5;
pub const LKL_RTAX_SSTHRESH: ::std::os::raw::c_uint = 6;
pub const LKL_RTAX_CWND: ::std::os::raw::c_uint = 7;
pub const LKL_RTAX_ADVMSS: ::std::os::raw::c_uint = 8;
pub const LKL_RTAX_REORDERING: ::std::os::raw::c_uint = 9;
pub const LKL_RTAX_HOPLIMIT: ::std::os::raw::c_uint = 10;
pub const LKL_RTAX_INITCWND: ::std::os::raw::c_uint = 11;
pub const LKL_RTAX_FEATURES: ::std::os::raw::c_uint = 12;
pub const LKL_RTAX_RTO_MIN: ::std::os::raw::c_uint = 13;
pub const LKL_RTAX_INITRWND: ::std::os::raw::c_uint = 14;
pub const LKL_RTAX_QUICKACK: ::std::os::raw::c_uint = 15;
pub const LKL_RTAX_CC_ALGO: ::std::os::raw::c_uint = 16;
pub const LKL_RTAX_FASTOPEN_NO_COOKIE: ::std::os::raw::c_uint = 17;
pub const __LKL__RTAX_MAX: ::std::os::raw::c_uint = 18;
pub type _bindgen_ty_104 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_rta_session {
    pub proto: __lkl__u8,
    pub pad1: __lkl__u8,
    pub pad2: __lkl__u16,
    pub u: lkl_rta_session__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_rta_session__bindgen_ty_1 {
    pub ports: lkl_rta_session__bindgen_ty_1__bindgen_ty_1,
    pub icmpt: lkl_rta_session__bindgen_ty_1__bindgen_ty_2,
    pub spi: __lkl__u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rta_session__bindgen_ty_1__bindgen_ty_1 {
    pub sport: __lkl__u16,
    pub dport: __lkl__u16,
}
#[test]
fn bindgen_test_layout_lkl_rta_session__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rta_session__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_rta_session__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rta_session__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_rta_session__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rta_session__bindgen_ty_1__bindgen_ty_1>())).sport
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rta_session__bindgen_ty_1__bindgen_ty_1>())).dport
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dport)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rta_session__bindgen_ty_1__bindgen_ty_2 {
    pub type_: __lkl__u8,
    pub code: __lkl__u8,
    pub ident: __lkl__u16,
}
#[test]
fn bindgen_test_layout_lkl_rta_session__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rta_session__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_rta_session__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rta_session__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_rta_session__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rta_session__bindgen_ty_1__bindgen_ty_2>())).type_
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rta_session__bindgen_ty_1__bindgen_ty_2>())).code as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rta_session__bindgen_ty_1__bindgen_ty_2>())).ident
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ident)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_rta_session__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rta_session__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_rta_session__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rta_session__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_rta_session__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rta_session__bindgen_ty_1>())).ports as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session__bindgen_ty_1),
            "::",
            stringify!(ports)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rta_session__bindgen_ty_1>())).icmpt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session__bindgen_ty_1),
            "::",
            stringify!(icmpt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_rta_session__bindgen_ty_1>())).spi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session__bindgen_ty_1),
            "::",
            stringify!(spi)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_rta_session() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rta_session>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_rta_session))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rta_session>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_rta_session))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_session>())).proto as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_session>())).pad1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_session>())).pad2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_session>())).u as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_session),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rta_mfc_stats {
    pub mfcs_packets: __lkl__u64,
    pub mfcs_bytes: __lkl__u64,
    pub mfcs_wrong_if: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_rta_mfc_stats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rta_mfc_stats>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_rta_mfc_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rta_mfc_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_rta_mfc_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_mfc_stats>())).mfcs_packets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_mfc_stats),
            "::",
            stringify!(mfcs_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_mfc_stats>())).mfcs_bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_mfc_stats),
            "::",
            stringify!(mfcs_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rta_mfc_stats>())).mfcs_wrong_if as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rta_mfc_stats),
            "::",
            stringify!(mfcs_wrong_if)
        )
    );
}
#[doc = "\t\tGeneral form of address family dependent message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_rtgenmsg {
    pub rtgen_family: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_lkl_rtgenmsg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_rtgenmsg>(),
        1usize,
        concat!("Size of: ", stringify!(lkl_rtgenmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_rtgenmsg>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_rtgenmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_rtgenmsg>())).rtgen_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_rtgenmsg),
            "::",
            stringify!(rtgen_family)
        )
    );
}
#[doc = "\t\tLink layer specific messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ifinfomsg {
    pub ifi_family: ::std::os::raw::c_uchar,
    pub __ifi_pad: ::std::os::raw::c_uchar,
    pub ifi_type: ::std::os::raw::c_ushort,
    pub ifi_index: ::std::os::raw::c_int,
    pub ifi_flags: ::std::os::raw::c_uint,
    pub ifi_change: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_ifinfomsg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ifinfomsg>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_ifinfomsg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ifinfomsg>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_ifinfomsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifinfomsg>())).ifi_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifinfomsg),
            "::",
            stringify!(ifi_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifinfomsg>())).__ifi_pad as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifinfomsg),
            "::",
            stringify!(__ifi_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifinfomsg>())).ifi_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifinfomsg),
            "::",
            stringify!(ifi_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifinfomsg>())).ifi_index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifinfomsg),
            "::",
            stringify!(ifi_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifinfomsg>())).ifi_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifinfomsg),
            "::",
            stringify!(ifi_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ifinfomsg>())).ifi_change as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ifinfomsg),
            "::",
            stringify!(ifi_change)
        )
    );
}
#[doc = "\t\tprefix information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_prefixmsg {
    pub prefix_family: ::std::os::raw::c_uchar,
    pub prefix_pad1: ::std::os::raw::c_uchar,
    pub prefix_pad2: ::std::os::raw::c_ushort,
    pub prefix_ifindex: ::std::os::raw::c_int,
    pub prefix_type: ::std::os::raw::c_uchar,
    pub prefix_len: ::std::os::raw::c_uchar,
    pub prefix_flags: ::std::os::raw::c_uchar,
    pub prefix_pad3: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_lkl_prefixmsg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_prefixmsg>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_prefixmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_prefixmsg>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_prefixmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_prefixmsg>())).prefix_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_prefixmsg),
            "::",
            stringify!(prefix_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_prefixmsg>())).prefix_pad1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_prefixmsg),
            "::",
            stringify!(prefix_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_prefixmsg>())).prefix_pad2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_prefixmsg),
            "::",
            stringify!(prefix_pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_prefixmsg>())).prefix_ifindex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_prefixmsg),
            "::",
            stringify!(prefix_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_prefixmsg>())).prefix_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_prefixmsg),
            "::",
            stringify!(prefix_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_prefixmsg>())).prefix_len as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_prefixmsg),
            "::",
            stringify!(prefix_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_prefixmsg>())).prefix_flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_prefixmsg),
            "::",
            stringify!(prefix_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_prefixmsg>())).prefix_pad3 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_prefixmsg),
            "::",
            stringify!(prefix_pad3)
        )
    );
}
pub const LKL_PREFIX_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_PREFIX_ADDRESS: ::std::os::raw::c_uint = 1;
pub const LKL_PREFIX_CACHEINFO: ::std::os::raw::c_uint = 2;
pub const __LKL__PREFIX_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_105 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_prefix_cacheinfo {
    pub preferred_time: __lkl__u32,
    pub valid_time: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_prefix_cacheinfo() {
    assert_eq!(
        ::std::mem::size_of::<lkl_prefix_cacheinfo>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_prefix_cacheinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_prefix_cacheinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_prefix_cacheinfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_prefix_cacheinfo>())).preferred_time as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_prefix_cacheinfo),
            "::",
            stringify!(preferred_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_prefix_cacheinfo>())).valid_time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_prefix_cacheinfo),
            "::",
            stringify!(valid_time)
        )
    );
}
#[doc = "\t\tTraffic control messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tcmsg {
    pub tcm_family: ::std::os::raw::c_uchar,
    pub tcm__pad1: ::std::os::raw::c_uchar,
    pub tcm__pad2: ::std::os::raw::c_ushort,
    pub tcm_ifindex: ::std::os::raw::c_int,
    pub tcm_handle: __lkl__u32,
    pub tcm_parent: __lkl__u32,
    pub tcm_info: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tcmsg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tcmsg>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_tcmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tcmsg>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tcmsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tcmsg>())).tcm_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tcmsg),
            "::",
            stringify!(tcm_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tcmsg>())).tcm__pad1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tcmsg),
            "::",
            stringify!(tcm__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tcmsg>())).tcm__pad2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tcmsg),
            "::",
            stringify!(tcm__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tcmsg>())).tcm_ifindex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tcmsg),
            "::",
            stringify!(tcm_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tcmsg>())).tcm_handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tcmsg),
            "::",
            stringify!(tcm_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tcmsg>())).tcm_parent as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tcmsg),
            "::",
            stringify!(tcm_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tcmsg>())).tcm_info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tcmsg),
            "::",
            stringify!(tcm_info)
        )
    );
}
pub const LKL_TCA_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_KIND: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_OPTIONS: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_STATS: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_XSTATS: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_RATE: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_FCNT: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_STATS2: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_STAB: ::std::os::raw::c_uint = 8;
pub const LKL_TCA_PAD: ::std::os::raw::c_uint = 9;
pub const LKL_TCA_DUMP_INVISIBLE: ::std::os::raw::c_uint = 10;
pub const LKL_TCA_CHAIN: ::std::os::raw::c_uint = 11;
pub const LKL_TCA_HW_OFFLOAD: ::std::os::raw::c_uint = 12;
pub const LKL_TCA_INGRESS_BLOCK: ::std::os::raw::c_uint = 13;
pub const LKL_TCA_EGRESS_BLOCK: ::std::os::raw::c_uint = 14;
pub const LKL_TCA_DUMP_FLAGS: ::std::os::raw::c_uint = 15;
pub const __LKL__TCA_MAX: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_106 = ::std::os::raw::c_uint;
#[doc = "\t\tNeighbor Discovery userland options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_nduseroptmsg {
    pub nduseropt_family: ::std::os::raw::c_uchar,
    pub nduseropt_pad1: ::std::os::raw::c_uchar,
    pub nduseropt_opts_len: ::std::os::raw::c_ushort,
    pub nduseropt_ifindex: ::std::os::raw::c_int,
    pub nduseropt_icmp_type: __lkl__u8,
    pub nduseropt_icmp_code: __lkl__u8,
    pub nduseropt_pad2: ::std::os::raw::c_ushort,
    pub nduseropt_pad3: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_nduseroptmsg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_nduseroptmsg>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_nduseroptmsg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_nduseroptmsg>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_nduseroptmsg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_nduseroptmsg>())).nduseropt_family as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nduseroptmsg),
            "::",
            stringify!(nduseropt_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nduseroptmsg>())).nduseropt_pad1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nduseroptmsg),
            "::",
            stringify!(nduseropt_pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_nduseroptmsg>())).nduseropt_opts_len as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nduseroptmsg),
            "::",
            stringify!(nduseropt_opts_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_nduseroptmsg>())).nduseropt_ifindex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nduseroptmsg),
            "::",
            stringify!(nduseropt_ifindex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_nduseroptmsg>())).nduseropt_icmp_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nduseroptmsg),
            "::",
            stringify!(nduseropt_icmp_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_nduseroptmsg>())).nduseropt_icmp_code as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nduseroptmsg),
            "::",
            stringify!(nduseropt_icmp_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nduseroptmsg>())).nduseropt_pad2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nduseroptmsg),
            "::",
            stringify!(nduseropt_pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_nduseroptmsg>())).nduseropt_pad3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_nduseroptmsg),
            "::",
            stringify!(nduseropt_pad3)
        )
    );
}
pub const LKL_NDUSEROPT_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_NDUSEROPT_SRCADDR: ::std::os::raw::c_uint = 1;
pub const __LKL__NDUSEROPT_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_107 = ::std::os::raw::c_uint;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_NONE: lkl_rtnetlink_groups = 0;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_LINK: lkl_rtnetlink_groups = 1;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_NOTIFY: lkl_rtnetlink_groups = 2;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_NEIGH: lkl_rtnetlink_groups = 3;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_TC: lkl_rtnetlink_groups = 4;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV4_IFADDR: lkl_rtnetlink_groups = 5;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV4_MROUTE: lkl_rtnetlink_groups = 6;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV4_ROUTE: lkl_rtnetlink_groups = 7;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV4_RULE: lkl_rtnetlink_groups = 8;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV6_IFADDR: lkl_rtnetlink_groups = 9;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV6_MROUTE: lkl_rtnetlink_groups = 10;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV6_ROUTE: lkl_rtnetlink_groups = 11;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV6_IFINFO: lkl_rtnetlink_groups = 12;
pub const lkl_rtnetlink_groups_lkl_RTNLGRP_DECnet_IFADDR: lkl_rtnetlink_groups = 13;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_NOP2: lkl_rtnetlink_groups = 14;
pub const lkl_rtnetlink_groups_lkl_RTNLGRP_DECnet_ROUTE: lkl_rtnetlink_groups = 15;
pub const lkl_rtnetlink_groups_lkl_RTNLGRP_DECnet_RULE: lkl_rtnetlink_groups = 16;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_NOP4: lkl_rtnetlink_groups = 17;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV6_PREFIX: lkl_rtnetlink_groups = 18;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV6_RULE: lkl_rtnetlink_groups = 19;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_ND_USEROPT: lkl_rtnetlink_groups = 20;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_PHONET_IFADDR: lkl_rtnetlink_groups = 21;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_PHONET_ROUTE: lkl_rtnetlink_groups = 22;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_DCB: lkl_rtnetlink_groups = 23;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV4_NETCONF: lkl_rtnetlink_groups = 24;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV6_NETCONF: lkl_rtnetlink_groups = 25;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_MDB: lkl_rtnetlink_groups = 26;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_MPLS_ROUTE: lkl_rtnetlink_groups = 27;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_NSID: lkl_rtnetlink_groups = 28;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_MPLS_NETCONF: lkl_rtnetlink_groups = 29;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV4_MROUTE_R: lkl_rtnetlink_groups = 30;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_IPV6_MROUTE_R: lkl_rtnetlink_groups = 31;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_NEXTHOP: lkl_rtnetlink_groups = 32;
pub const lkl_rtnetlink_groups_LKL_RTNLGRP_BRVLAN: lkl_rtnetlink_groups = 33;
pub const lkl_rtnetlink_groups___LKL__RTNLGRP_MAX: lkl_rtnetlink_groups = 34;
pub type lkl_rtnetlink_groups = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tcamsg {
    pub tca_family: ::std::os::raw::c_uchar,
    pub tca__pad1: ::std::os::raw::c_uchar,
    pub tca__pad2: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_lkl_tcamsg() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tcamsg>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_tcamsg))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tcamsg>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_tcamsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tcamsg>())).tca_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tcamsg),
            "::",
            stringify!(tca_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tcamsg>())).tca__pad1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tcamsg),
            "::",
            stringify!(tca__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tcamsg>())).tca__pad2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tcamsg),
            "::",
            stringify!(tca__pad2)
        )
    );
}
pub const LKL_TCA_ROOT_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_ROOT_TAB: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_ROOT_FLAGS: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_ROOT_COUNT: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_ROOT_TIME_DELTA: ::std::os::raw::c_uint = 4;
pub const __LKL__TCA_ROOT_MAX: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_108 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_fib_rule_hdr {
    pub family: __lkl__u8,
    pub dst_len: __lkl__u8,
    pub src_len: __lkl__u8,
    pub tos: __lkl__u8,
    pub table: __lkl__u8,
    pub res1: __lkl__u8,
    pub res2: __lkl__u8,
    pub action: __lkl__u8,
    pub flags: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_fib_rule_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fib_rule_hdr>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_fib_rule_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fib_rule_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_fib_rule_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_hdr>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_hdr),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_hdr>())).dst_len as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_hdr),
            "::",
            stringify!(dst_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_hdr>())).src_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_hdr),
            "::",
            stringify!(src_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_hdr>())).tos as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_hdr),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_hdr>())).table as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_hdr),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_hdr>())).res1 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_hdr),
            "::",
            stringify!(res1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_hdr>())).res2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_hdr),
            "::",
            stringify!(res2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_hdr>())).action as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_hdr),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_hdr>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_hdr),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_fib_rule_uid_range {
    pub start: __lkl__u32,
    pub end: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_fib_rule_uid_range() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fib_rule_uid_range>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_fib_rule_uid_range))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fib_rule_uid_range>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_fib_rule_uid_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_uid_range>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_uid_range),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_uid_range>())).end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_uid_range),
            "::",
            stringify!(end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_fib_rule_port_range {
    pub start: __lkl__u16,
    pub end: __lkl__u16,
}
#[test]
fn bindgen_test_layout_lkl_fib_rule_port_range() {
    assert_eq!(
        ::std::mem::size_of::<lkl_fib_rule_port_range>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_fib_rule_port_range))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_fib_rule_port_range>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_fib_rule_port_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_port_range>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_port_range),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_fib_rule_port_range>())).end as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_fib_rule_port_range),
            "::",
            stringify!(end)
        )
    );
}
pub const LKL_FRA_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_FRA_DST: ::std::os::raw::c_uint = 1;
pub const LKL_FRA_SRC: ::std::os::raw::c_uint = 2;
pub const LKL_FRA_IIFNAME: ::std::os::raw::c_uint = 3;
pub const LKL_FRA_GOTO: ::std::os::raw::c_uint = 4;
pub const LKL_FRA_UNUSED2: ::std::os::raw::c_uint = 5;
pub const LKL_FRA_PRIORITY: ::std::os::raw::c_uint = 6;
pub const LKL_FRA_UNUSED3: ::std::os::raw::c_uint = 7;
pub const LKL_FRA_UNUSED4: ::std::os::raw::c_uint = 8;
pub const LKL_FRA_UNUSED5: ::std::os::raw::c_uint = 9;
pub const LKL_FRA_FWMARK: ::std::os::raw::c_uint = 10;
pub const LKL_FRA_FLOW: ::std::os::raw::c_uint = 11;
pub const LKL_FRA_TUN_ID: ::std::os::raw::c_uint = 12;
pub const LKL_FRA_SUPPRESS_IFGROUP: ::std::os::raw::c_uint = 13;
pub const LKL_FRA_SUPPRESS_PREFIXLEN: ::std::os::raw::c_uint = 14;
pub const LKL_FRA_TABLE: ::std::os::raw::c_uint = 15;
pub const LKL_FRA_FWMASK: ::std::os::raw::c_uint = 16;
pub const LKL_FRA_OIFNAME: ::std::os::raw::c_uint = 17;
pub const LKL_FRA_PAD: ::std::os::raw::c_uint = 18;
pub const LKL_FRA_L3MDEV: ::std::os::raw::c_uint = 19;
pub const LKL_FRA_UID_RANGE: ::std::os::raw::c_uint = 20;
pub const LKL_FRA_PROTOCOL: ::std::os::raw::c_uint = 21;
pub const LKL_FRA_IP_PROTO: ::std::os::raw::c_uint = 22;
pub const LKL_FRA_SPORT_RANGE: ::std::os::raw::c_uint = 23;
pub const LKL_FRA_DPORT_RANGE: ::std::os::raw::c_uint = 24;
pub const __LKL__FRA_MAX: ::std::os::raw::c_uint = 25;
pub type _bindgen_ty_109 = ::std::os::raw::c_uint;
pub const LKL_FR_ACT_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_FR_ACT_TO_TBL: ::std::os::raw::c_uint = 1;
pub const LKL_FR_ACT_GOTO: ::std::os::raw::c_uint = 2;
pub const LKL_FR_ACT_NOP: ::std::os::raw::c_uint = 3;
pub const LKL_FR_ACT_RES3: ::std::os::raw::c_uint = 4;
pub const LKL_FR_ACT_RES4: ::std::os::raw::c_uint = 5;
pub const LKL_FR_ACT_BLACKHOLE: ::std::os::raw::c_uint = 6;
pub const LKL_FR_ACT_UNREACHABLE: ::std::os::raw::c_uint = 7;
pub const LKL_FR_ACT_PROHIBIT: ::std::os::raw::c_uint = 8;
pub const __LKL__FR_ACT_MAX: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_110 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " lkl_trigger_irq - generate an interrupt"]
    #[doc = ""]
    #[doc = " This function is used by the device host side to signal its Linux counterpart"]
    #[doc = " that some event happened."]
    #[doc = ""]
    #[doc = " @irq - the irq number to signal"]
    pub fn lkl_trigger_irq(irq: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_get_free_irq - find and reserve a free IRQ number"]
    #[doc = ""]
    #[doc = " This function is called by the host device code to find an unused IRQ number"]
    #[doc = " and reserved it for its own use."]
    #[doc = ""]
    #[doc = " @user - a string to identify the user"]
    #[doc = " @returns - and irq number that can be used by request_irq or an negative"]
    #[doc = " value in case of an error"]
    pub fn lkl_get_free_irq(user: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_put_irq - release an IRQ number previously obtained with lkl_get_free_irq"]
    #[doc = ""]
    #[doc = " @irq - irq number to release"]
    #[doc = " @user - string identifying the user; should be the same as the one passed to"]
    #[doc = " lkl_get_free_irq when the irq number was obtained"]
    pub fn lkl_put_irq(irq: ::std::os::raw::c_int, name: *const ::std::os::raw::c_char);
}
pub type __lkl__virtio16 = __lkl__u16;
pub type __lkl__virtio32 = __lkl__u32;
pub type __lkl__virtio64 = __lkl__u64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_blk_config {
    pub capacity: __lkl__virtio64,
    pub size_max: __lkl__virtio32,
    pub seg_max: __lkl__virtio32,
    pub geometry: lkl_virtio_blk_config_lkl_virtio_blk_geometry,
    pub blk_size: __lkl__virtio32,
    pub physical_block_exp: __lkl__u8,
    pub alignment_offset: __lkl__u8,
    pub min_io_size: __lkl__virtio16,
    pub opt_io_size: __lkl__virtio32,
    pub wce: __lkl__u8,
    pub unused: __lkl__u8,
    pub num_queues: __lkl__virtio16,
    pub max_discard_sectors: __lkl__virtio32,
    pub max_discard_seg: __lkl__virtio32,
    pub discard_sector_alignment: __lkl__virtio32,
    pub max_write_zeroes_sectors: __lkl__virtio32,
    pub max_write_zeroes_seg: __lkl__virtio32,
    pub write_zeroes_may_unmap: __lkl__u8,
    pub unused1: [__lkl__u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_blk_config_lkl_virtio_blk_geometry {
    pub cylinders: __lkl__virtio16,
    pub heads: __lkl__u8,
    pub sectors: __lkl__u8,
}
#[test]
fn bindgen_test_layout_lkl_virtio_blk_config_lkl_virtio_blk_geometry() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_blk_config_lkl_virtio_blk_geometry>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_virtio_blk_config_lkl_virtio_blk_geometry)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_blk_config_lkl_virtio_blk_geometry>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_virtio_blk_config_lkl_virtio_blk_geometry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config_lkl_virtio_blk_geometry>())).cylinders
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config_lkl_virtio_blk_geometry),
            "::",
            stringify!(cylinders)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config_lkl_virtio_blk_geometry>())).heads
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config_lkl_virtio_blk_geometry),
            "::",
            stringify!(heads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config_lkl_virtio_blk_geometry>())).sectors
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config_lkl_virtio_blk_geometry),
            "::",
            stringify!(sectors)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_virtio_blk_config() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_blk_config>(),
        60usize,
        concat!("Size of: ", stringify!(lkl_virtio_blk_config))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_blk_config>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_virtio_blk_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_blk_config>())).capacity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_blk_config>())).size_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(size_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_blk_config>())).seg_max as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(seg_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_blk_config>())).geometry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(geometry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_blk_config>())).blk_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(blk_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config>())).physical_block_exp as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(physical_block_exp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config>())).alignment_offset as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(alignment_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config>())).min_io_size as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(min_io_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config>())).opt_io_size as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(opt_io_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_blk_config>())).wce as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(wce)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_blk_config>())).unused as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config>())).num_queues as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(num_queues)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config>())).max_discard_sectors as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(max_discard_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config>())).max_discard_seg as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(max_discard_seg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config>())).discard_sector_alignment as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(discard_sector_alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config>())).max_write_zeroes_sectors as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(max_write_zeroes_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config>())).max_write_zeroes_seg as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(max_write_zeroes_seg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_config>())).write_zeroes_may_unmap as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(write_zeroes_may_unmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_blk_config>())).unused1 as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_config),
            "::",
            stringify!(unused1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_blk_outhdr {
    pub type_: __lkl__virtio32,
    pub ioprio: __lkl__virtio32,
    pub sector: __lkl__virtio64,
}
#[test]
fn bindgen_test_layout_lkl_virtio_blk_outhdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_blk_outhdr>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_virtio_blk_outhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_blk_outhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_virtio_blk_outhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_blk_outhdr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_outhdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_blk_outhdr>())).ioprio as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_outhdr),
            "::",
            stringify!(ioprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_blk_outhdr>())).sector as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_outhdr),
            "::",
            stringify!(sector)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_blk_discard_write_zeroes {
    pub sector: __lkl__le64,
    pub num_sectors: __lkl__le32,
    pub flags: __lkl__le32,
}
#[test]
fn bindgen_test_layout_lkl_virtio_blk_discard_write_zeroes() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_blk_discard_write_zeroes>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_virtio_blk_discard_write_zeroes))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_blk_discard_write_zeroes>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_virtio_blk_discard_write_zeroes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_discard_write_zeroes>())).sector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_discard_write_zeroes),
            "::",
            stringify!(sector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_discard_write_zeroes>())).num_sectors as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_discard_write_zeroes),
            "::",
            stringify!(num_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_blk_discard_write_zeroes>())).flags as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_blk_discard_write_zeroes),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_scsi_inhdr {
    pub errors: __lkl__virtio32,
    pub data_len: __lkl__virtio32,
    pub sense_len: __lkl__virtio32,
    pub residual: __lkl__virtio32,
}
#[test]
fn bindgen_test_layout_lkl_virtio_scsi_inhdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_scsi_inhdr>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_virtio_scsi_inhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_scsi_inhdr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_virtio_scsi_inhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_scsi_inhdr>())).errors as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_scsi_inhdr),
            "::",
            stringify!(errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_scsi_inhdr>())).data_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_scsi_inhdr),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_scsi_inhdr>())).sense_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_scsi_inhdr),
            "::",
            stringify!(sense_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_scsi_inhdr>())).residual as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_scsi_inhdr),
            "::",
            stringify!(residual)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ethhdr {
    pub h_dest: [::std::os::raw::c_uchar; 6usize],
    pub h_source: [::std::os::raw::c_uchar; 6usize],
    pub h_proto: __lkl__be16,
}
#[test]
fn bindgen_test_layout_lkl_ethhdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ethhdr>(),
        14usize,
        concat!("Size of: ", stringify!(lkl_ethhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ethhdr>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_ethhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ethhdr>())).h_dest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ethhdr),
            "::",
            stringify!(h_dest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ethhdr>())).h_source as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ethhdr),
            "::",
            stringify!(h_source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ethhdr>())).h_proto as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ethhdr),
            "::",
            stringify!(h_proto)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_net_config {
    pub mac: [__lkl__u8; 6usize],
    pub status: __lkl__virtio16,
    pub max_virtqueue_pairs: __lkl__virtio16,
    pub mtu: __lkl__virtio16,
    pub speed: __lkl__le32,
    pub duplex: __lkl__u8,
    pub rss_max_key_size: __lkl__u8,
    pub rss_max_indirection_table_length: __lkl__le16,
    pub supported_hash_types: __lkl__le32,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_config() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_config>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_virtio_net_config))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_config>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_virtio_net_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_config>())).mac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_config),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_config>())).status as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_config),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_config>())).max_virtqueue_pairs as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_config),
            "::",
            stringify!(max_virtqueue_pairs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_config>())).mtu as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_config),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_config>())).speed as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_config),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_config>())).duplex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_config),
            "::",
            stringify!(duplex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_config>())).rss_max_key_size as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_config),
            "::",
            stringify!(rss_max_key_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_config>())).rss_max_indirection_table_length
                as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_config),
            "::",
            stringify!(rss_max_indirection_table_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_config>())).supported_hash_types as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_config),
            "::",
            stringify!(supported_hash_types)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_virtio_net_hdr_v1 {
    pub flags: __lkl__u8,
    pub gso_type: __lkl__u8,
    pub hdr_len: __lkl__virtio16,
    pub gso_size: __lkl__virtio16,
    pub __bindgen_anon_1: lkl_virtio_net_hdr_v1__bindgen_ty_1,
    pub num_buffers: __lkl__virtio16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_virtio_net_hdr_v1__bindgen_ty_1 {
    pub __bindgen_anon_1: lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_1,
    pub csum: lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_2,
    pub rsc: lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_1 {
    pub csum_start: __lkl__virtio16,
    pub csum_offset: __lkl__virtio16,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_1>())).csum_start
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(csum_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_1>()))
                .csum_offset as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(csum_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_2 {
    pub start: __lkl__virtio16,
    pub offset: __lkl__virtio16,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_2>())).start
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_2>())).offset
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_3 {
    pub segments: __lkl__le16,
    pub dup_acks: __lkl__le16,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_3>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_3>())).segments
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(segments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_3>())).dup_acks
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(dup_acks)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_hdr_v1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_hdr_v1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_hdr_v1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1__bindgen_ty_1>())).csum as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1),
            "::",
            stringify!(csum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1__bindgen_ty_1>())).rsc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1__bindgen_ty_1),
            "::",
            stringify!(rsc)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_hdr_v1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_hdr_v1>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_virtio_net_hdr_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_hdr_v1>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_virtio_net_hdr_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1>())).gso_type as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1),
            "::",
            stringify!(gso_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1>())).hdr_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1),
            "::",
            stringify!(hdr_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1>())).gso_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1),
            "::",
            stringify!(gso_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1>())).num_buffers as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1),
            "::",
            stringify!(num_buffers)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_virtio_net_hdr_v1_hash {
    pub hdr: lkl_virtio_net_hdr_v1,
    pub hash_value: __lkl__le32,
    pub hash_report: __lkl__le16,
    pub padding: __lkl__le16,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_hdr_v1_hash() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_hdr_v1_hash>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_virtio_net_hdr_v1_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_hdr_v1_hash>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_virtio_net_hdr_v1_hash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1_hash>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1_hash),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1_hash>())).hash_value as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1_hash),
            "::",
            stringify!(hash_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1_hash>())).hash_report as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1_hash),
            "::",
            stringify!(hash_report)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_v1_hash>())).padding as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_v1_hash),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_net_hdr {
    pub flags: __lkl__u8,
    pub gso_type: __lkl__u8,
    pub hdr_len: __lkl__virtio16,
    pub gso_size: __lkl__virtio16,
    pub csum_start: __lkl__virtio16,
    pub csum_offset: __lkl__virtio16,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_hdr>(),
        10usize,
        concat!("Size of: ", stringify!(lkl_virtio_net_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_hdr>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_virtio_net_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_hdr>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_hdr>())).gso_type as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr),
            "::",
            stringify!(gso_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_hdr>())).hdr_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr),
            "::",
            stringify!(hdr_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_hdr>())).gso_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr),
            "::",
            stringify!(gso_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_hdr>())).csum_start as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr),
            "::",
            stringify!(csum_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_hdr>())).csum_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr),
            "::",
            stringify!(csum_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_net_hdr_mrg_rxbuf {
    pub hdr: lkl_virtio_net_hdr,
    pub num_buffers: __lkl__virtio16,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_hdr_mrg_rxbuf() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_hdr_mrg_rxbuf>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_virtio_net_hdr_mrg_rxbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_hdr_mrg_rxbuf>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_virtio_net_hdr_mrg_rxbuf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_mrg_rxbuf>())).hdr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_mrg_rxbuf),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hdr_mrg_rxbuf>())).num_buffers as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hdr_mrg_rxbuf),
            "::",
            stringify!(num_buffers)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_net_ctrl_hdr {
    pub class: __lkl__u8,
    pub cmd: __lkl__u8,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_ctrl_hdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_ctrl_hdr>(),
        2usize,
        concat!("Size of: ", stringify!(lkl_virtio_net_ctrl_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_ctrl_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_virtio_net_ctrl_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_ctrl_hdr>())).class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_ctrl_hdr),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_ctrl_hdr>())).cmd as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_ctrl_hdr),
            "::",
            stringify!(cmd)
        )
    );
}
pub type lkl_virtio_net_ctrl_ack = __lkl__u8;
#[repr(C, packed)]
#[derive(Debug)]
pub struct lkl_virtio_net_ctrl_mac {
    pub entries: __lkl__virtio32,
    pub macs: __IncompleteArrayField<[__lkl__u8; 6usize]>,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_ctrl_mac() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_ctrl_mac>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_virtio_net_ctrl_mac))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_ctrl_mac>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_virtio_net_ctrl_mac))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_ctrl_mac>())).entries as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_ctrl_mac),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_virtio_net_ctrl_mac>())).macs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_ctrl_mac),
            "::",
            stringify!(macs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_virtio_net_ctrl_mq {
    pub virtqueue_pairs: __lkl__virtio16,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_ctrl_mq() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_ctrl_mq>(),
        2usize,
        concat!("Size of: ", stringify!(lkl_virtio_net_ctrl_mq))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_ctrl_mq>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_virtio_net_ctrl_mq))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_ctrl_mq>())).virtqueue_pairs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_ctrl_mq),
            "::",
            stringify!(virtqueue_pairs)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_virtio_net_rss_config {
    pub hash_types: __lkl__le32,
    pub indirection_table_mask: __lkl__le16,
    pub unclassified_queue: __lkl__le16,
    pub indirection_table: [__lkl__le16; 1usize],
    pub max_tx_vq: __lkl__le16,
    pub hash_key_length: __lkl__u8,
    pub hash_key_data: __IncompleteArrayField<__lkl__u8>,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_rss_config() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_rss_config>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_virtio_net_rss_config))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_rss_config>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_virtio_net_rss_config))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_rss_config>())).hash_types as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_rss_config),
            "::",
            stringify!(hash_types)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_rss_config>())).indirection_table_mask as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_rss_config),
            "::",
            stringify!(indirection_table_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_rss_config>())).unclassified_queue as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_rss_config),
            "::",
            stringify!(unclassified_queue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_rss_config>())).indirection_table as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_rss_config),
            "::",
            stringify!(indirection_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_rss_config>())).max_tx_vq as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_rss_config),
            "::",
            stringify!(max_tx_vq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_rss_config>())).hash_key_length as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_rss_config),
            "::",
            stringify!(hash_key_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_rss_config>())).hash_key_data as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_rss_config),
            "::",
            stringify!(hash_key_data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_virtio_net_hash_config {
    pub hash_types: __lkl__le32,
    pub reserved: [__lkl__le16; 4usize],
    pub hash_key_length: __lkl__u8,
    pub hash_key_data: __IncompleteArrayField<__lkl__u8>,
}
#[test]
fn bindgen_test_layout_lkl_virtio_net_hash_config() {
    assert_eq!(
        ::std::mem::size_of::<lkl_virtio_net_hash_config>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_virtio_net_hash_config))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_virtio_net_hash_config>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_virtio_net_hash_config))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hash_config>())).hash_types as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hash_config),
            "::",
            stringify!(hash_types)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hash_config>())).reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hash_config),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hash_config>())).hash_key_length as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hash_config),
            "::",
            stringify!(hash_key_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_virtio_net_hash_config>())).hash_key_data as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_virtio_net_hash_config),
            "::",
            stringify!(hash_key_data)
        )
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_vring_desc {
    pub addr: __lkl__virtio64,
    pub len: __lkl__virtio32,
    pub flags: __lkl__virtio16,
    pub next: __lkl__virtio16,
}
#[test]
fn bindgen_test_layout_lkl_vring_desc() {
    assert_eq!(
        ::std::mem::size_of::<lkl_vring_desc>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_vring_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_vring_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_vring_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_desc>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_desc),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_desc>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_desc),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_desc>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_desc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_desc>())).next as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_desc),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_vring_avail {
    pub flags: __lkl__virtio16,
    pub idx: __lkl__virtio16,
    pub ring: __IncompleteArrayField<__lkl__virtio16>,
}
#[test]
fn bindgen_test_layout_lkl_vring_avail() {
    assert_eq!(
        ::std::mem::size_of::<lkl_vring_avail>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_vring_avail))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_vring_avail>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_vring_avail))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_avail>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_avail),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_avail>())).idx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_avail),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_avail>())).ring as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_avail),
            "::",
            stringify!(ring)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_vring_used_elem {
    pub id: __lkl__virtio32,
    pub len: __lkl__virtio32,
}
#[test]
fn bindgen_test_layout_lkl_vring_used_elem() {
    assert_eq!(
        ::std::mem::size_of::<lkl_vring_used_elem>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_vring_used_elem))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_vring_used_elem>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_vring_used_elem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_used_elem>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_used_elem),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_used_elem>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_used_elem),
            "::",
            stringify!(len)
        )
    );
}
pub type vring_used_elem_t = lkl_vring_used_elem;
#[repr(C)]
#[derive(Debug)]
pub struct lkl_vring_used {
    pub flags: __lkl__virtio16,
    pub idx: __lkl__virtio16,
    pub ring: __IncompleteArrayField<vring_used_elem_t>,
}
#[test]
fn bindgen_test_layout_lkl_vring_used() {
    assert_eq!(
        ::std::mem::size_of::<lkl_vring_used>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_vring_used))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_vring_used>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_vring_used))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_used>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_used),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_used>())).idx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_used),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_used>())).ring as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_used),
            "::",
            stringify!(ring)
        )
    );
}
pub type vring_desc_t = lkl_vring_desc;
pub type vring_avail_t = lkl_vring_avail;
pub type vring_used_t = lkl_vring_used;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_vring {
    pub num: ::std::os::raw::c_uint,
    pub desc: *mut vring_desc_t,
    pub avail: *mut vring_avail_t,
    pub used: *mut vring_used_t,
}
#[test]
fn bindgen_test_layout_lkl_vring() {
    assert_eq!(
        ::std::mem::size_of::<lkl_vring>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_vring))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_vring>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_vring))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring>())).avail as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring),
            "::",
            stringify!(avail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring>())).used as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring),
            "::",
            stringify!(used)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_vring_packed_desc_event {
    pub off_wrap: __lkl__le16,
    pub flags: __lkl__le16,
}
#[test]
fn bindgen_test_layout_lkl_vring_packed_desc_event() {
    assert_eq!(
        ::std::mem::size_of::<lkl_vring_packed_desc_event>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_vring_packed_desc_event))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_vring_packed_desc_event>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_vring_packed_desc_event))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_vring_packed_desc_event>())).off_wrap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_packed_desc_event),
            "::",
            stringify!(off_wrap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_vring_packed_desc_event>())).flags as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_packed_desc_event),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_vring_packed_desc {
    pub addr: __lkl__le64,
    pub len: __lkl__le32,
    pub id: __lkl__le16,
    pub flags: __lkl__le16,
}
#[test]
fn bindgen_test_layout_lkl_vring_packed_desc() {
    assert_eq!(
        ::std::mem::size_of::<lkl_vring_packed_desc>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_vring_packed_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_vring_packed_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_vring_packed_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_packed_desc>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_packed_desc),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_packed_desc>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_packed_desc),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_packed_desc>())).id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_packed_desc),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_vring_packed_desc>())).flags as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_vring_packed_desc),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_stats {
    pub bytes: __lkl__u64,
    pub packets: __lkl__u32,
    pub drops: __lkl__u32,
    pub overlimits: __lkl__u32,
    pub bps: __lkl__u32,
    pub pps: __lkl__u32,
    pub qlen: __lkl__u32,
    pub backlog: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_stats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_stats>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_tc_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_tc_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_stats>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_stats),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_stats>())).packets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_stats),
            "::",
            stringify!(packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_stats>())).drops as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_stats),
            "::",
            stringify!(drops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_stats>())).overlimits as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_stats),
            "::",
            stringify!(overlimits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_stats>())).bps as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_stats),
            "::",
            stringify!(bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_stats>())).pps as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_stats),
            "::",
            stringify!(pps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_stats>())).qlen as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_stats),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_stats>())).backlog as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_stats),
            "::",
            stringify!(backlog)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_estimator {
    pub interval: ::std::os::raw::c_schar,
    pub ewma_log: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_lkl_tc_estimator() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_estimator>(),
        2usize,
        concat!("Size of: ", stringify!(lkl_tc_estimator))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_estimator>(),
        1usize,
        concat!("Alignment of ", stringify!(lkl_tc_estimator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_estimator>())).interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_estimator),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_estimator>())).ewma_log as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_estimator),
            "::",
            stringify!(ewma_log)
        )
    );
}
pub const lkl_tc_link_layer_LKL_TC_LINKLAYER_UNAWARE: lkl_tc_link_layer = 0;
pub const lkl_tc_link_layer_LKL_TC_LINKLAYER_ETHERNET: lkl_tc_link_layer = 1;
pub const lkl_tc_link_layer_LKL_TC_LINKLAYER_ATM: lkl_tc_link_layer = 2;
pub type lkl_tc_link_layer = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_ratespec {
    pub cell_log: ::std::os::raw::c_uchar,
    pub linklayer: __lkl__u8,
    pub overhead: ::std::os::raw::c_ushort,
    pub cell_align: ::std::os::raw::c_short,
    pub mpu: ::std::os::raw::c_ushort,
    pub rate: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_ratespec() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_ratespec>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_tc_ratespec))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_ratespec>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_ratespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_ratespec>())).cell_log as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_ratespec),
            "::",
            stringify!(cell_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_ratespec>())).linklayer as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_ratespec),
            "::",
            stringify!(linklayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_ratespec>())).overhead as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_ratespec),
            "::",
            stringify!(overhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_ratespec>())).cell_align as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_ratespec),
            "::",
            stringify!(cell_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_ratespec>())).mpu as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_ratespec),
            "::",
            stringify!(mpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_ratespec>())).rate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_ratespec),
            "::",
            stringify!(rate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_sizespec {
    pub cell_log: ::std::os::raw::c_uchar,
    pub size_log: ::std::os::raw::c_uchar,
    pub cell_align: ::std::os::raw::c_short,
    pub overhead: ::std::os::raw::c_int,
    pub linklayer: ::std::os::raw::c_uint,
    pub mpu: ::std::os::raw::c_uint,
    pub mtu: ::std::os::raw::c_uint,
    pub tsize: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_tc_sizespec() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_sizespec>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_tc_sizespec))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_sizespec>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_sizespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sizespec>())).cell_log as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sizespec),
            "::",
            stringify!(cell_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sizespec>())).size_log as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sizespec),
            "::",
            stringify!(size_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sizespec>())).cell_align as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sizespec),
            "::",
            stringify!(cell_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sizespec>())).overhead as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sizespec),
            "::",
            stringify!(overhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sizespec>())).linklayer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sizespec),
            "::",
            stringify!(linklayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sizespec>())).mpu as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sizespec),
            "::",
            stringify!(mpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sizespec>())).mtu as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sizespec),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sizespec>())).tsize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sizespec),
            "::",
            stringify!(tsize)
        )
    );
}
pub const LKL_TCA_STAB_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_STAB_BASE: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_STAB_DATA: ::std::os::raw::c_uint = 2;
pub const __LKL__TCA_STAB_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_111 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_fifo_qopt {
    pub limit: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_fifo_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_fifo_qopt>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_tc_fifo_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_fifo_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_fifo_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fifo_qopt>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fifo_qopt),
            "::",
            stringify!(limit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_skbprio_qopt {
    pub limit: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_skbprio_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_skbprio_qopt>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_tc_skbprio_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_skbprio_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_skbprio_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_skbprio_qopt>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_skbprio_qopt),
            "::",
            stringify!(limit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_prio_qopt {
    pub bands: ::std::os::raw::c_int,
    pub priomap: [__lkl__u8; 16usize],
}
#[test]
fn bindgen_test_layout_lkl_tc_prio_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_prio_qopt>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_tc_prio_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_prio_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_prio_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_prio_qopt>())).bands as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_prio_qopt),
            "::",
            stringify!(bands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_prio_qopt>())).priomap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_prio_qopt),
            "::",
            stringify!(priomap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_multiq_qopt {
    pub bands: __lkl__u16,
    pub max_bands: __lkl__u16,
}
#[test]
fn bindgen_test_layout_lkl_tc_multiq_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_multiq_qopt>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_tc_multiq_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_multiq_qopt>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_tc_multiq_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_multiq_qopt>())).bands as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_multiq_qopt),
            "::",
            stringify!(bands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_multiq_qopt>())).max_bands as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_multiq_qopt),
            "::",
            stringify!(max_bands)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_plug_qopt {
    pub action: ::std::os::raw::c_int,
    pub limit: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_plug_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_plug_qopt>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_tc_plug_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_plug_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_plug_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_plug_qopt>())).action as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_plug_qopt),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_plug_qopt>())).limit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_plug_qopt),
            "::",
            stringify!(limit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_tbf_qopt {
    pub rate: lkl_tc_ratespec,
    pub peakrate: lkl_tc_ratespec,
    pub limit: __lkl__u32,
    pub buffer: __lkl__u32,
    pub mtu: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_tbf_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_tbf_qopt>(),
        36usize,
        concat!("Size of: ", stringify!(lkl_tc_tbf_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_tbf_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_tbf_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_tbf_qopt>())).rate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_tbf_qopt),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_tbf_qopt>())).peakrate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_tbf_qopt),
            "::",
            stringify!(peakrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_tbf_qopt>())).limit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_tbf_qopt),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_tbf_qopt>())).buffer as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_tbf_qopt),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_tbf_qopt>())).mtu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_tbf_qopt),
            "::",
            stringify!(mtu)
        )
    );
}
pub const LKL_TCA_TBF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_TBF_PARMS: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_TBF_RTAB: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_TBF_PTAB: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_TBF_RATE64: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_TBF_PRATE64: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_TBF_BURST: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_TBF_PBURST: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_TBF_PAD: ::std::os::raw::c_uint = 8;
pub const __LKL__TCA_TBF_MAX: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_112 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_sfq_qopt {
    pub quantum: ::std::os::raw::c_uint,
    pub perturb_period: ::std::os::raw::c_int,
    pub limit: __lkl__u32,
    pub divisor: ::std::os::raw::c_uint,
    pub flows: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_tc_sfq_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_sfq_qopt>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_tc_sfq_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_sfq_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_sfq_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt>())).quantum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt),
            "::",
            stringify!(quantum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt>())).perturb_period as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt),
            "::",
            stringify!(perturb_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt>())).limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt>())).divisor as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt),
            "::",
            stringify!(divisor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt>())).flows as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt),
            "::",
            stringify!(flows)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_sfqred_stats {
    pub prob_drop: __lkl__u32,
    pub forced_drop: __lkl__u32,
    pub prob_mark: __lkl__u32,
    pub forced_mark: __lkl__u32,
    pub prob_mark_head: __lkl__u32,
    pub forced_mark_head: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_sfqred_stats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_sfqred_stats>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_tc_sfqred_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_sfqred_stats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_sfqred_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfqred_stats>())).prob_drop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfqred_stats),
            "::",
            stringify!(prob_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfqred_stats>())).forced_drop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfqred_stats),
            "::",
            stringify!(forced_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfqred_stats>())).prob_mark as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfqred_stats),
            "::",
            stringify!(prob_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfqred_stats>())).forced_mark as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfqred_stats),
            "::",
            stringify!(forced_mark)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_sfqred_stats>())).prob_mark_head as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfqred_stats),
            "::",
            stringify!(prob_mark_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_sfqred_stats>())).forced_mark_head as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfqred_stats),
            "::",
            stringify!(forced_mark_head)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_sfq_qopt_v1 {
    pub v0: lkl_tc_sfq_qopt,
    pub depth: ::std::os::raw::c_uint,
    pub headdrop: ::std::os::raw::c_uint,
    pub limit: __lkl__u32,
    pub qth_min: __lkl__u32,
    pub qth_max: __lkl__u32,
    pub Wlog: ::std::os::raw::c_uchar,
    pub Plog: ::std::os::raw::c_uchar,
    pub Scell_log: ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_uchar,
    pub max_P: __lkl__u32,
    pub stats: lkl_tc_sfqred_stats,
}
#[test]
fn bindgen_test_layout_lkl_tc_sfq_qopt_v1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_sfq_qopt_v1>(),
        72usize,
        concat!("Size of: ", stringify!(lkl_tc_sfq_qopt_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_sfq_qopt_v1>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_sfq_qopt_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).v0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(v0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).headdrop as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(headdrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).limit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).qth_min as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(qth_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).qth_max as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(qth_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).Wlog as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(Wlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).Plog as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(Plog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).Scell_log as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(Scell_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).flags as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).max_P as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(max_P)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_qopt_v1>())).stats as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_qopt_v1),
            "::",
            stringify!(stats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_sfq_xstats {
    pub allot: __lkl__s32,
}
#[test]
fn bindgen_test_layout_lkl_tc_sfq_xstats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_sfq_xstats>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_tc_sfq_xstats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_sfq_xstats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_sfq_xstats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfq_xstats>())).allot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfq_xstats),
            "::",
            stringify!(allot)
        )
    );
}
pub const LKL_TCA_RED_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_RED_PARMS: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_RED_STAB: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_RED_MAX_P: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_RED_FLAGS: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_RED_EARLY_DROP_BLOCK: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_RED_MARK_BLOCK: ::std::os::raw::c_uint = 6;
pub const __LKL__TCA_RED_MAX: ::std::os::raw::c_uint = 7;
pub type _bindgen_ty_113 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_red_qopt {
    pub limit: __lkl__u32,
    pub qth_min: __lkl__u32,
    pub qth_max: __lkl__u32,
    pub Wlog: ::std::os::raw::c_uchar,
    pub Plog: ::std::os::raw::c_uchar,
    pub Scell_log: ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_lkl_tc_red_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_red_qopt>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_tc_red_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_red_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_red_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_red_qopt>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_red_qopt),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_red_qopt>())).qth_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_red_qopt),
            "::",
            stringify!(qth_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_red_qopt>())).qth_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_red_qopt),
            "::",
            stringify!(qth_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_red_qopt>())).Wlog as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_red_qopt),
            "::",
            stringify!(Wlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_red_qopt>())).Plog as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_red_qopt),
            "::",
            stringify!(Plog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_red_qopt>())).Scell_log as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_red_qopt),
            "::",
            stringify!(Scell_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_red_qopt>())).flags as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_red_qopt),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_red_xstats {
    pub early: __lkl__u32,
    pub pdrop: __lkl__u32,
    pub other: __lkl__u32,
    pub marked: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_red_xstats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_red_xstats>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_tc_red_xstats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_red_xstats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_red_xstats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_red_xstats>())).early as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_red_xstats),
            "::",
            stringify!(early)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_red_xstats>())).pdrop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_red_xstats),
            "::",
            stringify!(pdrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_red_xstats>())).other as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_red_xstats),
            "::",
            stringify!(other)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_red_xstats>())).marked as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_red_xstats),
            "::",
            stringify!(marked)
        )
    );
}
pub const LKL_TCA_GRED_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_GRED_PARMS: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_GRED_STAB: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_GRED_DPS: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_GRED_MAX_P: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_GRED_LIMIT: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_GRED_VQ_LIST: ::std::os::raw::c_uint = 6;
pub const __LKL__TCA_GRED_MAX: ::std::os::raw::c_uint = 7;
pub type _bindgen_ty_114 = ::std::os::raw::c_uint;
pub const LKL_TCA_GRED_VQ_ENTRY_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_GRED_VQ_ENTRY: ::std::os::raw::c_uint = 1;
pub const __LKL__TCA_GRED_VQ_ENTRY_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_115 = ::std::os::raw::c_uint;
pub const LKL_TCA_GRED_VQ_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_GRED_VQ_PAD: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_GRED_VQ_DP: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_GRED_VQ_STAT_BYTES: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_GRED_VQ_STAT_PACKETS: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_GRED_VQ_STAT_BACKLOG: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_GRED_VQ_STAT_PROB_DROP: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_GRED_VQ_STAT_PROB_MARK: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_GRED_VQ_STAT_FORCED_DROP: ::std::os::raw::c_uint = 8;
pub const LKL_TCA_GRED_VQ_STAT_FORCED_MARK: ::std::os::raw::c_uint = 9;
pub const LKL_TCA_GRED_VQ_STAT_PDROP: ::std::os::raw::c_uint = 10;
pub const LKL_TCA_GRED_VQ_STAT_OTHER: ::std::os::raw::c_uint = 11;
pub const LKL_TCA_GRED_VQ_FLAGS: ::std::os::raw::c_uint = 12;
pub const __LKL__TCA_GRED_VQ_MAX: ::std::os::raw::c_uint = 13;
pub type _bindgen_ty_116 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_gred_qopt {
    pub limit: __lkl__u32,
    pub qth_min: __lkl__u32,
    pub qth_max: __lkl__u32,
    pub DP: __lkl__u32,
    pub backlog: __lkl__u32,
    pub qave: __lkl__u32,
    pub forced: __lkl__u32,
    pub early: __lkl__u32,
    pub other: __lkl__u32,
    pub pdrop: __lkl__u32,
    pub Wlog: __lkl__u8,
    pub Plog: __lkl__u8,
    pub Scell_log: __lkl__u8,
    pub prio: __lkl__u8,
    pub packets: __lkl__u32,
    pub bytesin: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_gred_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_gred_qopt>(),
        52usize,
        concat!("Size of: ", stringify!(lkl_tc_gred_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_gred_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_gred_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).qth_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(qth_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).qth_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(qth_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).DP as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(DP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).backlog as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(backlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).qave as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(qave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).forced as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(forced)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).early as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(early)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).other as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(other)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).pdrop as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(pdrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).Wlog as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(Wlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).Plog as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(Plog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).Scell_log as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(Scell_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).prio as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).packets as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_qopt>())).bytesin as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_qopt),
            "::",
            stringify!(bytesin)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_gred_sopt {
    pub DPs: __lkl__u32,
    pub def_DP: __lkl__u32,
    pub grio: __lkl__u8,
    pub flags: __lkl__u8,
    pub pad1: __lkl__u16,
}
#[test]
fn bindgen_test_layout_lkl_tc_gred_sopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_gred_sopt>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_tc_gred_sopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_gred_sopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_gred_sopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_sopt>())).DPs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_sopt),
            "::",
            stringify!(DPs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_sopt>())).def_DP as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_sopt),
            "::",
            stringify!(def_DP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_sopt>())).grio as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_sopt),
            "::",
            stringify!(grio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_sopt>())).flags as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_sopt),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_gred_sopt>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_gred_sopt),
            "::",
            stringify!(pad1)
        )
    );
}
pub const LKL_TCA_CHOKE_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_CHOKE_PARMS: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_CHOKE_STAB: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_CHOKE_MAX_P: ::std::os::raw::c_uint = 3;
pub const __LKL__TCA_CHOKE_MAX: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_117 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_choke_qopt {
    pub limit: __lkl__u32,
    pub qth_min: __lkl__u32,
    pub qth_max: __lkl__u32,
    pub Wlog: ::std::os::raw::c_uchar,
    pub Plog: ::std::os::raw::c_uchar,
    pub Scell_log: ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_lkl_tc_choke_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_choke_qopt>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_tc_choke_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_choke_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_choke_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_qopt>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_qopt),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_qopt>())).qth_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_qopt),
            "::",
            stringify!(qth_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_qopt>())).qth_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_qopt),
            "::",
            stringify!(qth_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_qopt>())).Wlog as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_qopt),
            "::",
            stringify!(Wlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_qopt>())).Plog as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_qopt),
            "::",
            stringify!(Plog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_qopt>())).Scell_log as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_qopt),
            "::",
            stringify!(Scell_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_qopt>())).flags as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_qopt),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_choke_xstats {
    pub early: __lkl__u32,
    pub pdrop: __lkl__u32,
    pub other: __lkl__u32,
    pub marked: __lkl__u32,
    pub matched: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_choke_xstats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_choke_xstats>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_tc_choke_xstats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_choke_xstats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_choke_xstats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_xstats>())).early as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_xstats),
            "::",
            stringify!(early)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_xstats>())).pdrop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_xstats),
            "::",
            stringify!(pdrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_xstats>())).other as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_xstats),
            "::",
            stringify!(other)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_xstats>())).marked as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_xstats),
            "::",
            stringify!(marked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_choke_xstats>())).matched as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_choke_xstats),
            "::",
            stringify!(matched)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_htb_opt {
    pub rate: lkl_tc_ratespec,
    pub ceil: lkl_tc_ratespec,
    pub buffer: __lkl__u32,
    pub cbuffer: __lkl__u32,
    pub quantum: __lkl__u32,
    pub level: __lkl__u32,
    pub prio: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_htb_opt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_htb_opt>(),
        44usize,
        concat!("Size of: ", stringify!(lkl_tc_htb_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_htb_opt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_htb_opt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_opt>())).rate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_opt),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_opt>())).ceil as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_opt),
            "::",
            stringify!(ceil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_opt>())).buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_opt),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_opt>())).cbuffer as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_opt),
            "::",
            stringify!(cbuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_opt>())).quantum as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_opt),
            "::",
            stringify!(quantum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_opt>())).level as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_opt),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_opt>())).prio as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_opt),
            "::",
            stringify!(prio)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_htb_glob {
    pub version: __lkl__u32,
    pub rate2quantum: __lkl__u32,
    pub defcls: __lkl__u32,
    pub debug: __lkl__u32,
    pub direct_pkts: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_htb_glob() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_htb_glob>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_tc_htb_glob))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_htb_glob>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_htb_glob))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_glob>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_glob),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_glob>())).rate2quantum as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_glob),
            "::",
            stringify!(rate2quantum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_glob>())).defcls as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_glob),
            "::",
            stringify!(defcls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_glob>())).debug as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_glob),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_glob>())).direct_pkts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_glob),
            "::",
            stringify!(direct_pkts)
        )
    );
}
pub const LKL_TCA_HTB_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_HTB_PARMS: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_HTB_INIT: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_HTB_CTAB: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_HTB_RTAB: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_HTB_DIRECT_QLEN: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_HTB_RATE64: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_HTB_CEIL64: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_HTB_PAD: ::std::os::raw::c_uint = 8;
pub const __LKL__TCA_HTB_MAX: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_118 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_htb_xstats {
    pub lends: __lkl__u32,
    pub borrows: __lkl__u32,
    pub giants: __lkl__u32,
    pub tokens: __lkl__s32,
    pub ctokens: __lkl__s32,
}
#[test]
fn bindgen_test_layout_lkl_tc_htb_xstats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_htb_xstats>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_tc_htb_xstats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_htb_xstats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_htb_xstats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_xstats>())).lends as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_xstats),
            "::",
            stringify!(lends)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_xstats>())).borrows as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_xstats),
            "::",
            stringify!(borrows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_xstats>())).giants as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_xstats),
            "::",
            stringify!(giants)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_xstats>())).tokens as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_xstats),
            "::",
            stringify!(tokens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_htb_xstats>())).ctokens as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_htb_xstats),
            "::",
            stringify!(ctokens)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_hfsc_qopt {
    pub defcls: __lkl__u16,
}
#[test]
fn bindgen_test_layout_lkl_tc_hfsc_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_hfsc_qopt>(),
        2usize,
        concat!("Size of: ", stringify!(lkl_tc_hfsc_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_hfsc_qopt>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_tc_hfsc_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_hfsc_qopt>())).defcls as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_hfsc_qopt),
            "::",
            stringify!(defcls)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_service_curve {
    pub m1: __lkl__u32,
    pub d: __lkl__u32,
    pub m2: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_service_curve() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_service_curve>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_tc_service_curve))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_service_curve>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_service_curve))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_service_curve>())).m1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_service_curve),
            "::",
            stringify!(m1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_service_curve>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_service_curve),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_service_curve>())).m2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_service_curve),
            "::",
            stringify!(m2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_hfsc_stats {
    pub work: __lkl__u64,
    pub rtwork: __lkl__u64,
    pub period: __lkl__u32,
    pub level: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_hfsc_stats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_hfsc_stats>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_tc_hfsc_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_hfsc_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_tc_hfsc_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_hfsc_stats>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_hfsc_stats),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_hfsc_stats>())).rtwork as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_hfsc_stats),
            "::",
            stringify!(rtwork)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_hfsc_stats>())).period as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_hfsc_stats),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_hfsc_stats>())).level as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_hfsc_stats),
            "::",
            stringify!(level)
        )
    );
}
pub const LKL_TCA_HFSC_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_HFSC_RSC: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_HFSC_FSC: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_HFSC_USC: ::std::os::raw::c_uint = 3;
pub const __LKL__TCA_HFSC_MAX: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_119 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_cbq_lssopt {
    pub change: ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_uchar,
    pub ewma_log: ::std::os::raw::c_uchar,
    pub level: ::std::os::raw::c_uchar,
    pub maxidle: __lkl__u32,
    pub minidle: __lkl__u32,
    pub offtime: __lkl__u32,
    pub avpkt: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_cbq_lssopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_cbq_lssopt>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_tc_cbq_lssopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_cbq_lssopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_cbq_lssopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_lssopt>())).change as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_lssopt),
            "::",
            stringify!(change)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_lssopt>())).flags as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_lssopt),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_lssopt>())).ewma_log as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_lssopt),
            "::",
            stringify!(ewma_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_lssopt>())).level as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_lssopt),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_lssopt>())).maxidle as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_lssopt),
            "::",
            stringify!(maxidle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_lssopt>())).minidle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_lssopt),
            "::",
            stringify!(minidle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_lssopt>())).offtime as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_lssopt),
            "::",
            stringify!(offtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_lssopt>())).avpkt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_lssopt),
            "::",
            stringify!(avpkt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_cbq_wrropt {
    pub flags: ::std::os::raw::c_uchar,
    pub priority: ::std::os::raw::c_uchar,
    pub cpriority: ::std::os::raw::c_uchar,
    pub __reserved: ::std::os::raw::c_uchar,
    pub allot: __lkl__u32,
    pub weight: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_cbq_wrropt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_cbq_wrropt>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_tc_cbq_wrropt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_cbq_wrropt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_cbq_wrropt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_wrropt>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_wrropt),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_wrropt>())).priority as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_wrropt),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_wrropt>())).cpriority as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_wrropt),
            "::",
            stringify!(cpriority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_wrropt>())).__reserved as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_wrropt),
            "::",
            stringify!(__reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_wrropt>())).allot as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_wrropt),
            "::",
            stringify!(allot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_wrropt>())).weight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_wrropt),
            "::",
            stringify!(weight)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_cbq_ovl {
    pub strategy: ::std::os::raw::c_uchar,
    pub priority2: ::std::os::raw::c_uchar,
    pub pad: __lkl__u16,
    pub penalty: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_cbq_ovl() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_cbq_ovl>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_tc_cbq_ovl))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_cbq_ovl>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_cbq_ovl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_ovl>())).strategy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_ovl),
            "::",
            stringify!(strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_ovl>())).priority2 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_ovl),
            "::",
            stringify!(priority2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_ovl>())).pad as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_ovl),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_ovl>())).penalty as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_ovl),
            "::",
            stringify!(penalty)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_cbq_police {
    pub police: ::std::os::raw::c_uchar,
    pub __res1: ::std::os::raw::c_uchar,
    pub __res2: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_lkl_tc_cbq_police() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_cbq_police>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_tc_cbq_police))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_cbq_police>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_tc_cbq_police))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_police>())).police as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_police),
            "::",
            stringify!(police)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_police>())).__res1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_police),
            "::",
            stringify!(__res1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_police>())).__res2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_police),
            "::",
            stringify!(__res2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_cbq_fopt {
    pub split: __lkl__u32,
    pub defmap: __lkl__u32,
    pub defchange: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_cbq_fopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_cbq_fopt>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_tc_cbq_fopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_cbq_fopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_cbq_fopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_fopt>())).split as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_fopt),
            "::",
            stringify!(split)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_fopt>())).defmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_fopt),
            "::",
            stringify!(defmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_fopt>())).defchange as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_fopt),
            "::",
            stringify!(defchange)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_cbq_xstats {
    pub borrows: __lkl__u32,
    pub overactions: __lkl__u32,
    pub avgidle: __lkl__s32,
    pub undertime: __lkl__s32,
}
#[test]
fn bindgen_test_layout_lkl_tc_cbq_xstats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_cbq_xstats>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_tc_cbq_xstats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_cbq_xstats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_cbq_xstats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_xstats>())).borrows as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_xstats),
            "::",
            stringify!(borrows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_xstats>())).overactions as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_xstats),
            "::",
            stringify!(overactions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_xstats>())).avgidle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_xstats),
            "::",
            stringify!(avgidle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbq_xstats>())).undertime as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbq_xstats),
            "::",
            stringify!(undertime)
        )
    );
}
pub const LKL_TCA_CBQ_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_CBQ_LSSOPT: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_CBQ_WRROPT: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_CBQ_FOPT: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_CBQ_OVL_STRATEGY: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_CBQ_RATE: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_CBQ_RTAB: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_CBQ_POLICE: ::std::os::raw::c_uint = 7;
pub const __LKL__TCA_CBQ_MAX: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_120 = ::std::os::raw::c_uint;
pub const LKL_TCA_DSMARK_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_DSMARK_INDICES: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_DSMARK_DEFAULT_INDEX: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_DSMARK_SET_TC_INDEX: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_DSMARK_MASK: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_DSMARK_VALUE: ::std::os::raw::c_uint = 5;
pub const __LKL__TCA_DSMARK_MAX: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_121 = ::std::os::raw::c_uint;
pub const LKL_TCA_ATM_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_ATM_FD: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_ATM_PTR: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_ATM_HDR: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_ATM_EXCESS: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_ATM_ADDR: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_ATM_STATE: ::std::os::raw::c_uint = 6;
pub const __LKL__TCA_ATM_MAX: ::std::os::raw::c_uint = 7;
pub type _bindgen_ty_122 = ::std::os::raw::c_uint;
pub const LKL_TCA_NETEM_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_NETEM_CORR: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_NETEM_DELAY_DIST: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_NETEM_REORDER: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_NETEM_CORRUPT: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_NETEM_LOSS: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_NETEM_RATE: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_NETEM_ECN: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_NETEM_RATE64: ::std::os::raw::c_uint = 8;
pub const LKL_TCA_NETEM_PAD: ::std::os::raw::c_uint = 9;
pub const LKL_TCA_NETEM_LATENCY64: ::std::os::raw::c_uint = 10;
pub const LKL_TCA_NETEM_JITTER64: ::std::os::raw::c_uint = 11;
pub const LKL_TCA_NETEM_SLOT: ::std::os::raw::c_uint = 12;
pub const LKL_TCA_NETEM_SLOT_DIST: ::std::os::raw::c_uint = 13;
pub const __LKL__TCA_NETEM_MAX: ::std::os::raw::c_uint = 14;
pub type _bindgen_ty_123 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_netem_qopt {
    pub latency: __lkl__u32,
    pub limit: __lkl__u32,
    pub loss: __lkl__u32,
    pub gap: __lkl__u32,
    pub duplicate: __lkl__u32,
    pub jitter: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_netem_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_netem_qopt>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_tc_netem_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_netem_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_netem_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_qopt>())).latency as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_qopt),
            "::",
            stringify!(latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_qopt>())).limit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_qopt),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_qopt>())).loss as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_qopt),
            "::",
            stringify!(loss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_qopt>())).gap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_qopt),
            "::",
            stringify!(gap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_qopt>())).duplicate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_qopt),
            "::",
            stringify!(duplicate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_qopt>())).jitter as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_qopt),
            "::",
            stringify!(jitter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_netem_corr {
    pub delay_corr: __lkl__u32,
    pub loss_corr: __lkl__u32,
    pub dup_corr: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_netem_corr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_netem_corr>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_tc_netem_corr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_netem_corr>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_netem_corr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_corr>())).delay_corr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_corr),
            "::",
            stringify!(delay_corr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_corr>())).loss_corr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_corr),
            "::",
            stringify!(loss_corr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_corr>())).dup_corr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_corr),
            "::",
            stringify!(dup_corr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_netem_reorder {
    pub probability: __lkl__u32,
    pub correlation: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_netem_reorder() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_netem_reorder>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_tc_netem_reorder))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_netem_reorder>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_netem_reorder))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_netem_reorder>())).probability as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_reorder),
            "::",
            stringify!(probability)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_netem_reorder>())).correlation as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_reorder),
            "::",
            stringify!(correlation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_netem_corrupt {
    pub probability: __lkl__u32,
    pub correlation: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_netem_corrupt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_netem_corrupt>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_tc_netem_corrupt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_netem_corrupt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_netem_corrupt))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_netem_corrupt>())).probability as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_corrupt),
            "::",
            stringify!(probability)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_netem_corrupt>())).correlation as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_corrupt),
            "::",
            stringify!(correlation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_netem_rate {
    pub rate: __lkl__u32,
    pub packet_overhead: __lkl__s32,
    pub cell_size: __lkl__u32,
    pub cell_overhead: __lkl__s32,
}
#[test]
fn bindgen_test_layout_lkl_tc_netem_rate() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_netem_rate>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_tc_netem_rate))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_netem_rate>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_netem_rate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_rate>())).rate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_rate),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_netem_rate>())).packet_overhead as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_rate),
            "::",
            stringify!(packet_overhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_rate>())).cell_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_rate),
            "::",
            stringify!(cell_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_rate>())).cell_overhead as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_rate),
            "::",
            stringify!(cell_overhead)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_netem_slot {
    pub min_delay: __lkl__s64,
    pub max_delay: __lkl__s64,
    pub max_packets: __lkl__s32,
    pub max_bytes: __lkl__s32,
    pub dist_delay: __lkl__s64,
    pub dist_jitter: __lkl__s64,
}
#[test]
fn bindgen_test_layout_lkl_tc_netem_slot() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_netem_slot>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_tc_netem_slot))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_netem_slot>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_tc_netem_slot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_slot>())).min_delay as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_slot),
            "::",
            stringify!(min_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_slot>())).max_delay as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_slot),
            "::",
            stringify!(max_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_slot>())).max_packets as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_slot),
            "::",
            stringify!(max_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_slot>())).max_bytes as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_slot),
            "::",
            stringify!(max_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_slot>())).dist_delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_slot),
            "::",
            stringify!(dist_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_slot>())).dist_jitter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_slot),
            "::",
            stringify!(dist_jitter)
        )
    );
}
pub const LKL_NETEM_LOSS_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_NETEM_LOSS_GI: ::std::os::raw::c_uint = 1;
pub const LKL_NETEM_LOSS_GE: ::std::os::raw::c_uint = 2;
pub const __LKL__NETEM_LOSS_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_124 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_netem_gimodel {
    pub p13: __lkl__u32,
    pub p31: __lkl__u32,
    pub p32: __lkl__u32,
    pub p14: __lkl__u32,
    pub p23: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_netem_gimodel() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_netem_gimodel>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_tc_netem_gimodel))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_netem_gimodel>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_netem_gimodel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_gimodel>())).p13 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_gimodel),
            "::",
            stringify!(p13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_gimodel>())).p31 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_gimodel),
            "::",
            stringify!(p31)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_gimodel>())).p32 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_gimodel),
            "::",
            stringify!(p32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_gimodel>())).p14 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_gimodel),
            "::",
            stringify!(p14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_gimodel>())).p23 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_gimodel),
            "::",
            stringify!(p23)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_netem_gemodel {
    pub p: __lkl__u32,
    pub r: __lkl__u32,
    pub h: __lkl__u32,
    pub k1: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_netem_gemodel() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_netem_gemodel>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_tc_netem_gemodel))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_netem_gemodel>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_netem_gemodel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_gemodel>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_gemodel),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_gemodel>())).r as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_gemodel),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_gemodel>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_gemodel),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_netem_gemodel>())).k1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_netem_gemodel),
            "::",
            stringify!(k1)
        )
    );
}
pub const LKL_TCA_DRR_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_DRR_QUANTUM: ::std::os::raw::c_uint = 1;
pub const __LKL__TCA_DRR_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_125 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_drr_stats {
    pub deficit: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_drr_stats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_drr_stats>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_tc_drr_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_drr_stats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_drr_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_drr_stats>())).deficit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_drr_stats),
            "::",
            stringify!(deficit)
        )
    );
}
pub const LKL_TC_MQPRIO_HW_OFFLOAD_NONE: ::std::os::raw::c_uint = 0;
pub const LKL_TC_MQPRIO_HW_OFFLOAD_TCS: ::std::os::raw::c_uint = 1;
pub const __LKL__TC_MQPRIO_HW_OFFLOAD_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_126 = ::std::os::raw::c_uint;
pub const LKL_TC_MQPRIO_MODE_DCB: ::std::os::raw::c_uint = 0;
pub const LKL_TC_MQPRIO_MODE_CHANNEL: ::std::os::raw::c_uint = 1;
pub const __LKL__TC_MQPRIO_MODE_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_127 = ::std::os::raw::c_uint;
pub const LKL_TC_MQPRIO_SHAPER_DCB: ::std::os::raw::c_uint = 0;
pub const LKL_TC_MQPRIO_SHAPER_BW_RATE: ::std::os::raw::c_uint = 1;
pub const __LKL__TC_MQPRIO_SHAPER_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_128 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_mqprio_qopt {
    pub num_tc: __lkl__u8,
    pub prio_tc_map: [__lkl__u8; 16usize],
    pub hw: __lkl__u8,
    pub count: [__lkl__u16; 16usize],
    pub offset: [__lkl__u16; 16usize],
}
#[test]
fn bindgen_test_layout_lkl_tc_mqprio_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_mqprio_qopt>(),
        82usize,
        concat!("Size of: ", stringify!(lkl_tc_mqprio_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_mqprio_qopt>(),
        2usize,
        concat!("Alignment of ", stringify!(lkl_tc_mqprio_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_mqprio_qopt>())).num_tc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_mqprio_qopt),
            "::",
            stringify!(num_tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_mqprio_qopt>())).prio_tc_map as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_mqprio_qopt),
            "::",
            stringify!(prio_tc_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_mqprio_qopt>())).hw as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_mqprio_qopt),
            "::",
            stringify!(hw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_mqprio_qopt>())).count as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_mqprio_qopt),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_mqprio_qopt>())).offset as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_mqprio_qopt),
            "::",
            stringify!(offset)
        )
    );
}
pub const LKL_TCA_MQPRIO_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_MQPRIO_MODE: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_MQPRIO_SHAPER: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_MQPRIO_MIN_RATE64: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_MQPRIO_MAX_RATE64: ::std::os::raw::c_uint = 4;
pub const __LKL__TCA_MQPRIO_MAX: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_129 = ::std::os::raw::c_uint;
pub const LKL_TCA_SFB_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_SFB_PARMS: ::std::os::raw::c_uint = 1;
pub const __LKL__TCA_SFB_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_130 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_sfb_qopt {
    pub rehash_interval: __lkl__u32,
    pub warmup_time: __lkl__u32,
    pub max: __lkl__u32,
    pub bin_size: __lkl__u32,
    pub increment: __lkl__u32,
    pub decrement: __lkl__u32,
    pub limit: __lkl__u32,
    pub penalty_rate: __lkl__u32,
    pub penalty_burst: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_sfb_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_sfb_qopt>(),
        36usize,
        concat!("Size of: ", stringify!(lkl_tc_sfb_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_sfb_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_sfb_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_qopt>())).rehash_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_qopt),
            "::",
            stringify!(rehash_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_qopt>())).warmup_time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_qopt),
            "::",
            stringify!(warmup_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_qopt>())).max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_qopt),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_qopt>())).bin_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_qopt),
            "::",
            stringify!(bin_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_qopt>())).increment as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_qopt),
            "::",
            stringify!(increment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_qopt>())).decrement as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_qopt),
            "::",
            stringify!(decrement)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_qopt>())).limit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_qopt),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_qopt>())).penalty_rate as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_qopt),
            "::",
            stringify!(penalty_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_qopt>())).penalty_burst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_qopt),
            "::",
            stringify!(penalty_burst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_sfb_xstats {
    pub earlydrop: __lkl__u32,
    pub penaltydrop: __lkl__u32,
    pub bucketdrop: __lkl__u32,
    pub queuedrop: __lkl__u32,
    pub childdrop: __lkl__u32,
    pub marked: __lkl__u32,
    pub maxqlen: __lkl__u32,
    pub maxprob: __lkl__u32,
    pub avgprob: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_sfb_xstats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_sfb_xstats>(),
        36usize,
        concat!("Size of: ", stringify!(lkl_tc_sfb_xstats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_sfb_xstats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_sfb_xstats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_xstats>())).earlydrop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_xstats),
            "::",
            stringify!(earlydrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_xstats>())).penaltydrop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_xstats),
            "::",
            stringify!(penaltydrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_xstats>())).bucketdrop as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_xstats),
            "::",
            stringify!(bucketdrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_xstats>())).queuedrop as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_xstats),
            "::",
            stringify!(queuedrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_xstats>())).childdrop as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_xstats),
            "::",
            stringify!(childdrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_xstats>())).marked as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_xstats),
            "::",
            stringify!(marked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_xstats>())).maxqlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_xstats),
            "::",
            stringify!(maxqlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_xstats>())).maxprob as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_xstats),
            "::",
            stringify!(maxprob)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_sfb_xstats>())).avgprob as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_sfb_xstats),
            "::",
            stringify!(avgprob)
        )
    );
}
pub const LKL_TCA_QFQ_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_QFQ_WEIGHT: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_QFQ_LMAX: ::std::os::raw::c_uint = 2;
pub const __LKL__TCA_QFQ_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_131 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_qfq_stats {
    pub weight: __lkl__u32,
    pub lmax: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_qfq_stats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_qfq_stats>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_tc_qfq_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_qfq_stats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_qfq_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_qfq_stats>())).weight as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_qfq_stats),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_qfq_stats>())).lmax as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_qfq_stats),
            "::",
            stringify!(lmax)
        )
    );
}
pub const LKL_TCA_CODEL_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_CODEL_TARGET: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_CODEL_LIMIT: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_CODEL_INTERVAL: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_CODEL_ECN: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_CODEL_CE_THRESHOLD: ::std::os::raw::c_uint = 5;
pub const __LKL__TCA_CODEL_MAX: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_132 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_codel_xstats {
    pub maxpacket: __lkl__u32,
    pub count: __lkl__u32,
    pub lastcount: __lkl__u32,
    pub ldelay: __lkl__u32,
    pub drop_next: __lkl__s32,
    pub drop_overlimit: __lkl__u32,
    pub ecn_mark: __lkl__u32,
    pub dropping: __lkl__u32,
    pub ce_mark: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_codel_xstats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_codel_xstats>(),
        36usize,
        concat!("Size of: ", stringify!(lkl_tc_codel_xstats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_codel_xstats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_codel_xstats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_codel_xstats>())).maxpacket as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_codel_xstats),
            "::",
            stringify!(maxpacket)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_codel_xstats>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_codel_xstats),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_codel_xstats>())).lastcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_codel_xstats),
            "::",
            stringify!(lastcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_codel_xstats>())).ldelay as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_codel_xstats),
            "::",
            stringify!(ldelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_codel_xstats>())).drop_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_codel_xstats),
            "::",
            stringify!(drop_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_codel_xstats>())).drop_overlimit as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_codel_xstats),
            "::",
            stringify!(drop_overlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_codel_xstats>())).ecn_mark as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_codel_xstats),
            "::",
            stringify!(ecn_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_codel_xstats>())).dropping as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_codel_xstats),
            "::",
            stringify!(dropping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_codel_xstats>())).ce_mark as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_codel_xstats),
            "::",
            stringify!(ce_mark)
        )
    );
}
pub const LKL_TCA_FQ_CODEL_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_FQ_CODEL_TARGET: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_FQ_CODEL_LIMIT: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_FQ_CODEL_INTERVAL: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_FQ_CODEL_ECN: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_FQ_CODEL_FLOWS: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_FQ_CODEL_QUANTUM: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_FQ_CODEL_CE_THRESHOLD: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_FQ_CODEL_DROP_BATCH_SIZE: ::std::os::raw::c_uint = 8;
pub const LKL_TCA_FQ_CODEL_MEMORY_LIMIT: ::std::os::raw::c_uint = 9;
pub const __LKL__TCA_FQ_CODEL_MAX: ::std::os::raw::c_uint = 10;
pub type _bindgen_ty_133 = ::std::os::raw::c_uint;
pub const LKL_TCA_FQ_CODEL_XSTATS_QDISC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_FQ_CODEL_XSTATS_CLASS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_134 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_fq_codel_qd_stats {
    pub maxpacket: __lkl__u32,
    pub drop_overlimit: __lkl__u32,
    pub ecn_mark: __lkl__u32,
    pub new_flow_count: __lkl__u32,
    pub new_flows_len: __lkl__u32,
    pub old_flows_len: __lkl__u32,
    pub ce_mark: __lkl__u32,
    pub memory_usage: __lkl__u32,
    pub drop_overmemory: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_fq_codel_qd_stats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_fq_codel_qd_stats>(),
        36usize,
        concat!("Size of: ", stringify!(lkl_tc_fq_codel_qd_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_fq_codel_qd_stats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_fq_codel_qd_stats))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_qd_stats>())).maxpacket as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_qd_stats),
            "::",
            stringify!(maxpacket)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_qd_stats>())).drop_overlimit as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_qd_stats),
            "::",
            stringify!(drop_overlimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_qd_stats>())).ecn_mark as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_qd_stats),
            "::",
            stringify!(ecn_mark)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_qd_stats>())).new_flow_count as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_qd_stats),
            "::",
            stringify!(new_flow_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_qd_stats>())).new_flows_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_qd_stats),
            "::",
            stringify!(new_flows_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_qd_stats>())).old_flows_len as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_qd_stats),
            "::",
            stringify!(old_flows_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_qd_stats>())).ce_mark as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_qd_stats),
            "::",
            stringify!(ce_mark)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_qd_stats>())).memory_usage as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_qd_stats),
            "::",
            stringify!(memory_usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_qd_stats>())).drop_overmemory as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_qd_stats),
            "::",
            stringify!(drop_overmemory)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_fq_codel_cl_stats {
    pub deficit: __lkl__s32,
    pub ldelay: __lkl__u32,
    pub count: __lkl__u32,
    pub lastcount: __lkl__u32,
    pub dropping: __lkl__u32,
    pub drop_next: __lkl__s32,
}
#[test]
fn bindgen_test_layout_lkl_tc_fq_codel_cl_stats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_fq_codel_cl_stats>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_tc_fq_codel_cl_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_fq_codel_cl_stats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_fq_codel_cl_stats))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_cl_stats>())).deficit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_cl_stats),
            "::",
            stringify!(deficit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_codel_cl_stats>())).ldelay as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_cl_stats),
            "::",
            stringify!(ldelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_codel_cl_stats>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_cl_stats),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_cl_stats>())).lastcount as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_cl_stats),
            "::",
            stringify!(lastcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_cl_stats>())).dropping as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_cl_stats),
            "::",
            stringify!(dropping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_cl_stats>())).drop_next as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_cl_stats),
            "::",
            stringify!(drop_next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_tc_fq_codel_xstats {
    pub type_: __lkl__u32,
    pub __bindgen_anon_1: lkl_tc_fq_codel_xstats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_tc_fq_codel_xstats__bindgen_ty_1 {
    pub qdisc_stats: lkl_tc_fq_codel_qd_stats,
    pub class_stats: lkl_tc_fq_codel_cl_stats,
}
#[test]
fn bindgen_test_layout_lkl_tc_fq_codel_xstats__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_fq_codel_xstats__bindgen_ty_1>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(lkl_tc_fq_codel_xstats__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_fq_codel_xstats__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_tc_fq_codel_xstats__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_xstats__bindgen_ty_1>())).qdisc_stats as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_xstats__bindgen_ty_1),
            "::",
            stringify!(qdisc_stats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_codel_xstats__bindgen_ty_1>())).class_stats as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_xstats__bindgen_ty_1),
            "::",
            stringify!(class_stats)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_tc_fq_codel_xstats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_fq_codel_xstats>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_tc_fq_codel_xstats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_fq_codel_xstats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_fq_codel_xstats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_codel_xstats>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_codel_xstats),
            "::",
            stringify!(type_)
        )
    );
}
pub const LKL_TCA_FQ_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_FQ_PLIMIT: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_FQ_FLOW_PLIMIT: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_FQ_QUANTUM: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_FQ_INITIAL_QUANTUM: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_FQ_RATE_ENABLE: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_FQ_FLOW_DEFAULT_RATE: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_FQ_FLOW_MAX_RATE: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_FQ_BUCKETS_LOG: ::std::os::raw::c_uint = 8;
pub const LKL_TCA_FQ_FLOW_REFILL_DELAY: ::std::os::raw::c_uint = 9;
pub const LKL_TCA_FQ_ORPHAN_MASK: ::std::os::raw::c_uint = 10;
pub const LKL_TCA_FQ_LOW_RATE_THRESHOLD: ::std::os::raw::c_uint = 11;
pub const LKL_TCA_FQ_CE_THRESHOLD: ::std::os::raw::c_uint = 12;
pub const LKL_TCA_FQ_TIMER_SLACK: ::std::os::raw::c_uint = 13;
pub const LKL_TCA_FQ_HORIZON: ::std::os::raw::c_uint = 14;
pub const LKL_TCA_FQ_HORIZON_DROP: ::std::os::raw::c_uint = 15;
pub const __LKL__TCA_FQ_MAX: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_135 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_fq_qd_stats {
    pub gc_flows: __lkl__u64,
    pub highprio_packets: __lkl__u64,
    pub tcp_retrans: __lkl__u64,
    pub throttled: __lkl__u64,
    pub flows_plimit: __lkl__u64,
    pub pkts_too_long: __lkl__u64,
    pub allocation_errors: __lkl__u64,
    pub time_next_delayed_flow: __lkl__s64,
    pub flows: __lkl__u32,
    pub inactive_flows: __lkl__u32,
    pub throttled_flows: __lkl__u32,
    pub unthrottle_latency_ns: __lkl__u32,
    pub ce_mark: __lkl__u64,
    pub horizon_drops: __lkl__u64,
    pub horizon_caps: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_tc_fq_qd_stats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_fq_qd_stats>(),
        104usize,
        concat!("Size of: ", stringify!(lkl_tc_fq_qd_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_fq_qd_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_tc_fq_qd_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).gc_flows as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(gc_flows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).highprio_packets as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(highprio_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).tcp_retrans as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(tcp_retrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).throttled as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(throttled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).flows_plimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(flows_plimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).pkts_too_long as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(pkts_too_long)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).allocation_errors as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(allocation_errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).time_next_delayed_flow as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(time_next_delayed_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).flows as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(flows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).inactive_flows as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(inactive_flows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).throttled_flows as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(throttled_flows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).unthrottle_latency_ns as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(unthrottle_latency_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).ce_mark as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(ce_mark)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).horizon_drops as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(horizon_drops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_qd_stats>())).horizon_caps as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_qd_stats),
            "::",
            stringify!(horizon_caps)
        )
    );
}
pub const LKL_TCA_HHF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_HHF_BACKLOG_LIMIT: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_HHF_QUANTUM: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_HHF_HH_FLOWS_LIMIT: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_HHF_RESET_TIMEOUT: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_HHF_ADMIT_BYTES: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_HHF_EVICT_TIMEOUT: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_HHF_NON_HH_WEIGHT: ::std::os::raw::c_uint = 7;
pub const __LKL__TCA_HHF_MAX: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_136 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_hhf_xstats {
    pub drop_overlimit: __lkl__u32,
    pub hh_overlimit: __lkl__u32,
    pub hh_tot_count: __lkl__u32,
    pub hh_cur_count: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_hhf_xstats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_hhf_xstats>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_tc_hhf_xstats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_hhf_xstats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_hhf_xstats))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_hhf_xstats>())).drop_overlimit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_hhf_xstats),
            "::",
            stringify!(drop_overlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_hhf_xstats>())).hh_overlimit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_hhf_xstats),
            "::",
            stringify!(hh_overlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_hhf_xstats>())).hh_tot_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_hhf_xstats),
            "::",
            stringify!(hh_tot_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_hhf_xstats>())).hh_cur_count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_hhf_xstats),
            "::",
            stringify!(hh_cur_count)
        )
    );
}
pub const LKL_TCA_PIE_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_PIE_TARGET: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_PIE_LIMIT: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_PIE_TUPDATE: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_PIE_ALPHA: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_PIE_BETA: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_PIE_ECN: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_PIE_BYTEMODE: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_PIE_DQ_RATE_ESTIMATOR: ::std::os::raw::c_uint = 8;
pub const __LKL__TCA_PIE_MAX: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_137 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_pie_xstats {
    pub prob: __lkl__u64,
    pub delay: __lkl__u32,
    pub avg_dq_rate: __lkl__u32,
    pub dq_rate_estimating: __lkl__u32,
    pub packets_in: __lkl__u32,
    pub dropped: __lkl__u32,
    pub overlimit: __lkl__u32,
    pub maxq: __lkl__u32,
    pub ecn_mark: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_pie_xstats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_pie_xstats>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_tc_pie_xstats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_pie_xstats>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_tc_pie_xstats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_pie_xstats>())).prob as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_pie_xstats),
            "::",
            stringify!(prob)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_pie_xstats>())).delay as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_pie_xstats),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_pie_xstats>())).avg_dq_rate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_pie_xstats),
            "::",
            stringify!(avg_dq_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_pie_xstats>())).dq_rate_estimating as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_pie_xstats),
            "::",
            stringify!(dq_rate_estimating)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_pie_xstats>())).packets_in as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_pie_xstats),
            "::",
            stringify!(packets_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_pie_xstats>())).dropped as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_pie_xstats),
            "::",
            stringify!(dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_pie_xstats>())).overlimit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_pie_xstats),
            "::",
            stringify!(overlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_pie_xstats>())).maxq as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_pie_xstats),
            "::",
            stringify!(maxq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_pie_xstats>())).ecn_mark as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_pie_xstats),
            "::",
            stringify!(ecn_mark)
        )
    );
}
pub const LKL_TCA_FQ_PIE_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_FQ_PIE_LIMIT: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_FQ_PIE_FLOWS: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_FQ_PIE_TARGET: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_FQ_PIE_TUPDATE: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_FQ_PIE_ALPHA: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_FQ_PIE_BETA: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_FQ_PIE_QUANTUM: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_FQ_PIE_MEMORY_LIMIT: ::std::os::raw::c_uint = 8;
pub const LKL_TCA_FQ_PIE_ECN_PROB: ::std::os::raw::c_uint = 9;
pub const LKL_TCA_FQ_PIE_ECN: ::std::os::raw::c_uint = 10;
pub const LKL_TCA_FQ_PIE_BYTEMODE: ::std::os::raw::c_uint = 11;
pub const LKL_TCA_FQ_PIE_DQ_RATE_ESTIMATOR: ::std::os::raw::c_uint = 12;
pub const __LKL__TCA_FQ_PIE_MAX: ::std::os::raw::c_uint = 13;
pub type _bindgen_ty_138 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_fq_pie_xstats {
    pub packets_in: __lkl__u32,
    pub dropped: __lkl__u32,
    pub overlimit: __lkl__u32,
    pub overmemory: __lkl__u32,
    pub ecn_mark: __lkl__u32,
    pub new_flow_count: __lkl__u32,
    pub new_flows_len: __lkl__u32,
    pub old_flows_len: __lkl__u32,
    pub memory_usage: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_fq_pie_xstats() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_fq_pie_xstats>(),
        36usize,
        concat!("Size of: ", stringify!(lkl_tc_fq_pie_xstats))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_fq_pie_xstats>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_fq_pie_xstats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_pie_xstats>())).packets_in as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_pie_xstats),
            "::",
            stringify!(packets_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_pie_xstats>())).dropped as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_pie_xstats),
            "::",
            stringify!(dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_pie_xstats>())).overlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_pie_xstats),
            "::",
            stringify!(overlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_pie_xstats>())).overmemory as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_pie_xstats),
            "::",
            stringify!(overmemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_fq_pie_xstats>())).ecn_mark as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_pie_xstats),
            "::",
            stringify!(ecn_mark)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_pie_xstats>())).new_flow_count as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_pie_xstats),
            "::",
            stringify!(new_flow_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_pie_xstats>())).new_flows_len as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_pie_xstats),
            "::",
            stringify!(new_flows_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_pie_xstats>())).old_flows_len as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_pie_xstats),
            "::",
            stringify!(old_flows_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_tc_fq_pie_xstats>())).memory_usage as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_fq_pie_xstats),
            "::",
            stringify!(memory_usage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_cbs_qopt {
    pub offload: __lkl__u8,
    pub _pad: [__lkl__u8; 3usize],
    pub hicredit: __lkl__s32,
    pub locredit: __lkl__s32,
    pub idleslope: __lkl__s32,
    pub sendslope: __lkl__s32,
}
#[test]
fn bindgen_test_layout_lkl_tc_cbs_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_cbs_qopt>(),
        20usize,
        concat!("Size of: ", stringify!(lkl_tc_cbs_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_cbs_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_cbs_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbs_qopt>())).offload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbs_qopt),
            "::",
            stringify!(offload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbs_qopt>()))._pad as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbs_qopt),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbs_qopt>())).hicredit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbs_qopt),
            "::",
            stringify!(hicredit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbs_qopt>())).locredit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbs_qopt),
            "::",
            stringify!(locredit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbs_qopt>())).idleslope as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbs_qopt),
            "::",
            stringify!(idleslope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_cbs_qopt>())).sendslope as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_cbs_qopt),
            "::",
            stringify!(sendslope)
        )
    );
}
pub const LKL_TCA_CBS_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_CBS_PARMS: ::std::os::raw::c_uint = 1;
pub const __LKL__TCA_CBS_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_139 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_tc_etf_qopt {
    pub delta: __lkl__s32,
    pub clockid: __lkl__s32,
    pub flags: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_tc_etf_qopt() {
    assert_eq!(
        ::std::mem::size_of::<lkl_tc_etf_qopt>(),
        12usize,
        concat!("Size of: ", stringify!(lkl_tc_etf_qopt))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_tc_etf_qopt>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_tc_etf_qopt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_etf_qopt>())).delta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_etf_qopt),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_etf_qopt>())).clockid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_etf_qopt),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_tc_etf_qopt>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_tc_etf_qopt),
            "::",
            stringify!(flags)
        )
    );
}
pub const LKL_TCA_ETF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_ETF_PARMS: ::std::os::raw::c_uint = 1;
pub const __LKL__TCA_ETF_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_140 = ::std::os::raw::c_uint;
pub const LKL_TCA_CAKE_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_CAKE_PAD: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_CAKE_BASE_RATE64: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_CAKE_DIFFSERV_MODE: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_CAKE_ATM: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_CAKE_FLOW_MODE: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_CAKE_OVERHEAD: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_CAKE_RTT: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_CAKE_TARGET: ::std::os::raw::c_uint = 8;
pub const LKL_TCA_CAKE_AUTORATE: ::std::os::raw::c_uint = 9;
pub const LKL_TCA_CAKE_MEMORY: ::std::os::raw::c_uint = 10;
pub const LKL_TCA_CAKE_NAT: ::std::os::raw::c_uint = 11;
pub const LKL_TCA_CAKE_RAW: ::std::os::raw::c_uint = 12;
pub const LKL_TCA_CAKE_WASH: ::std::os::raw::c_uint = 13;
pub const LKL_TCA_CAKE_MPU: ::std::os::raw::c_uint = 14;
pub const LKL_TCA_CAKE_INGRESS: ::std::os::raw::c_uint = 15;
pub const LKL_TCA_CAKE_ACK_FILTER: ::std::os::raw::c_uint = 16;
pub const LKL_TCA_CAKE_SPLIT_GSO: ::std::os::raw::c_uint = 17;
pub const LKL_TCA_CAKE_FWMARK: ::std::os::raw::c_uint = 18;
pub const __LKL__TCA_CAKE_MAX: ::std::os::raw::c_uint = 19;
pub type _bindgen_ty_141 = ::std::os::raw::c_uint;
pub const __LKL__TCA_CAKE_STATS_INVALID: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_CAKE_STATS_PAD: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_CAKE_STATS_CAPACITY_ESTIMATE64: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_CAKE_STATS_MEMORY_LIMIT: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_CAKE_STATS_MEMORY_USED: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_CAKE_STATS_AVG_NETOFF: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_CAKE_STATS_MIN_NETLEN: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_CAKE_STATS_MAX_NETLEN: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_CAKE_STATS_MIN_ADJLEN: ::std::os::raw::c_uint = 8;
pub const LKL_TCA_CAKE_STATS_MAX_ADJLEN: ::std::os::raw::c_uint = 9;
pub const LKL_TCA_CAKE_STATS_TIN_STATS: ::std::os::raw::c_uint = 10;
pub const LKL_TCA_CAKE_STATS_DEFICIT: ::std::os::raw::c_uint = 11;
pub const LKL_TCA_CAKE_STATS_COBALT_COUNT: ::std::os::raw::c_uint = 12;
pub const LKL_TCA_CAKE_STATS_DROPPING: ::std::os::raw::c_uint = 13;
pub const LKL_TCA_CAKE_STATS_DROP_NEXT_US: ::std::os::raw::c_uint = 14;
pub const LKL_TCA_CAKE_STATS_P_DROP: ::std::os::raw::c_uint = 15;
pub const LKL_TCA_CAKE_STATS_BLUE_TIMER_US: ::std::os::raw::c_uint = 16;
pub const __LKL__TCA_CAKE_STATS_MAX: ::std::os::raw::c_uint = 17;
pub type _bindgen_ty_142 = ::std::os::raw::c_uint;
pub const __LKL__TCA_CAKE_TIN_STATS_INVALID: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_CAKE_TIN_STATS_PAD: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_CAKE_TIN_STATS_SENT_PACKETS: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_CAKE_TIN_STATS_SENT_BYTES64: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_CAKE_TIN_STATS_DROPPED_PACKETS: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_CAKE_TIN_STATS_DROPPED_BYTES64: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_CAKE_TIN_STATS_ACKS_DROPPED_PACKETS: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_CAKE_TIN_STATS_ACKS_DROPPED_BYTES64: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_CAKE_TIN_STATS_ECN_MARKED_PACKETS: ::std::os::raw::c_uint = 8;
pub const LKL_TCA_CAKE_TIN_STATS_ECN_MARKED_BYTES64: ::std::os::raw::c_uint = 9;
pub const LKL_TCA_CAKE_TIN_STATS_BACKLOG_PACKETS: ::std::os::raw::c_uint = 10;
pub const LKL_TCA_CAKE_TIN_STATS_BACKLOG_BYTES: ::std::os::raw::c_uint = 11;
pub const LKL_TCA_CAKE_TIN_STATS_THRESHOLD_RATE64: ::std::os::raw::c_uint = 12;
pub const LKL_TCA_CAKE_TIN_STATS_TARGET_US: ::std::os::raw::c_uint = 13;
pub const LKL_TCA_CAKE_TIN_STATS_INTERVAL_US: ::std::os::raw::c_uint = 14;
pub const LKL_TCA_CAKE_TIN_STATS_WAY_INDIRECT_HITS: ::std::os::raw::c_uint = 15;
pub const LKL_TCA_CAKE_TIN_STATS_WAY_MISSES: ::std::os::raw::c_uint = 16;
pub const LKL_TCA_CAKE_TIN_STATS_WAY_COLLISIONS: ::std::os::raw::c_uint = 17;
pub const LKL_TCA_CAKE_TIN_STATS_PEAK_DELAY_US: ::std::os::raw::c_uint = 18;
pub const LKL_TCA_CAKE_TIN_STATS_AVG_DELAY_US: ::std::os::raw::c_uint = 19;
pub const LKL_TCA_CAKE_TIN_STATS_BASE_DELAY_US: ::std::os::raw::c_uint = 20;
pub const LKL_TCA_CAKE_TIN_STATS_SPARSE_FLOWS: ::std::os::raw::c_uint = 21;
pub const LKL_TCA_CAKE_TIN_STATS_BULK_FLOWS: ::std::os::raw::c_uint = 22;
pub const LKL_TCA_CAKE_TIN_STATS_UNRESPONSIVE_FLOWS: ::std::os::raw::c_uint = 23;
pub const LKL_TCA_CAKE_TIN_STATS_MAX_SKBLEN: ::std::os::raw::c_uint = 24;
pub const LKL_TCA_CAKE_TIN_STATS_FLOW_QUANTUM: ::std::os::raw::c_uint = 25;
pub const __LKL__TCA_CAKE_TIN_STATS_MAX: ::std::os::raw::c_uint = 26;
pub type _bindgen_ty_143 = ::std::os::raw::c_uint;
pub const LKL_CAKE_FLOW_NONE: ::std::os::raw::c_uint = 0;
pub const LKL_CAKE_FLOW_SRC_IP: ::std::os::raw::c_uint = 1;
pub const LKL_CAKE_FLOW_DST_IP: ::std::os::raw::c_uint = 2;
pub const LKL_CAKE_FLOW_HOSTS: ::std::os::raw::c_uint = 3;
pub const LKL_CAKE_FLOW_FLOWS: ::std::os::raw::c_uint = 4;
pub const LKL_CAKE_FLOW_DUAL_SRC: ::std::os::raw::c_uint = 5;
pub const LKL_CAKE_FLOW_DUAL_DST: ::std::os::raw::c_uint = 6;
pub const LKL_CAKE_FLOW_TRIPLE: ::std::os::raw::c_uint = 7;
pub const LKL_CAKE_FLOW_MAX: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_144 = ::std::os::raw::c_uint;
pub const LKL_CAKE_DIFFSERV_DIFFSERV3: ::std::os::raw::c_uint = 0;
pub const LKL_CAKE_DIFFSERV_DIFFSERV4: ::std::os::raw::c_uint = 1;
pub const LKL_CAKE_DIFFSERV_DIFFSERV8: ::std::os::raw::c_uint = 2;
pub const LKL_CAKE_DIFFSERV_BESTEFFORT: ::std::os::raw::c_uint = 3;
pub const LKL_CAKE_DIFFSERV_PRECEDENCE: ::std::os::raw::c_uint = 4;
pub const LKL_CAKE_DIFFSERV_MAX: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_145 = ::std::os::raw::c_uint;
pub const LKL_CAKE_ACK_NONE: ::std::os::raw::c_uint = 0;
pub const LKL_CAKE_ACK_FILTER: ::std::os::raw::c_uint = 1;
pub const LKL_CAKE_ACK_AGGRESSIVE: ::std::os::raw::c_uint = 2;
pub const LKL_CAKE_ACK_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_146 = ::std::os::raw::c_uint;
pub const LKL_CAKE_ATM_NONE: ::std::os::raw::c_uint = 0;
pub const LKL_CAKE_ATM_ATM: ::std::os::raw::c_uint = 1;
pub const LKL_CAKE_ATM_PTM: ::std::os::raw::c_uint = 2;
pub const LKL_CAKE_ATM_MAX: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_147 = ::std::os::raw::c_uint;
pub const LKL_TC_TAPRIO_CMD_SET_GATES: ::std::os::raw::c_uint = 0;
pub const LKL_TC_TAPRIO_CMD_SET_AND_HOLD: ::std::os::raw::c_uint = 1;
pub const LKL_TC_TAPRIO_CMD_SET_AND_RELEASE: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_148 = ::std::os::raw::c_uint;
pub const LKL_TCA_TAPRIO_SCHED_ENTRY_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_TAPRIO_SCHED_ENTRY_INDEX: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_TAPRIO_SCHED_ENTRY_CMD: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_TAPRIO_SCHED_ENTRY_GATE_MASK: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_TAPRIO_SCHED_ENTRY_INTERVAL: ::std::os::raw::c_uint = 4;
pub const __LKL__TCA_TAPRIO_SCHED_ENTRY_MAX: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_149 = ::std::os::raw::c_uint;
pub const LKL_TCA_TAPRIO_SCHED_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_TAPRIO_SCHED_ENTRY: ::std::os::raw::c_uint = 1;
pub const __LKL__TCA_TAPRIO_SCHED_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_150 = ::std::os::raw::c_uint;
pub const LKL_TCA_TAPRIO_ATTR_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_TAPRIO_ATTR_PRIOMAP: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_TAPRIO_ATTR_SCHED_ENTRY_LIST: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_TAPRIO_ATTR_SCHED_BASE_TIME: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_TAPRIO_ATTR_SCHED_SINGLE_ENTRY: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_TAPRIO_ATTR_SCHED_CLOCKID: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_TAPRIO_PAD: ::std::os::raw::c_uint = 6;
pub const LKL_TCA_TAPRIO_ATTR_ADMIN_SCHED: ::std::os::raw::c_uint = 7;
pub const LKL_TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME: ::std::os::raw::c_uint = 8;
pub const LKL_TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION: ::std::os::raw::c_uint = 9;
pub const LKL_TCA_TAPRIO_ATTR_FLAGS: ::std::os::raw::c_uint = 10;
pub const LKL_TCA_TAPRIO_ATTR_TXTIME_DELAY: ::std::os::raw::c_uint = 11;
pub const __LKL__TCA_TAPRIO_ATTR_MAX: ::std::os::raw::c_uint = 12;
pub type _bindgen_ty_151 = ::std::os::raw::c_uint;
pub const LKL_TCA_ETS_UNSPEC: ::std::os::raw::c_uint = 0;
pub const LKL_TCA_ETS_NBANDS: ::std::os::raw::c_uint = 1;
pub const LKL_TCA_ETS_NSTRICT: ::std::os::raw::c_uint = 2;
pub const LKL_TCA_ETS_QUANTA: ::std::os::raw::c_uint = 3;
pub const LKL_TCA_ETS_QUANTA_BAND: ::std::os::raw::c_uint = 4;
pub const LKL_TCA_ETS_PRIOMAP: ::std::os::raw::c_uint = 5;
pub const LKL_TCA_ETS_PRIOMAP_BAND: ::std::os::raw::c_uint = 6;
pub const __LKL__TCA_ETS_MAX: ::std::os::raw::c_uint = 7;
pub type _bindgen_ty_152 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_io_uring_sqe {
    pub opcode: __lkl__u8,
    pub flags: __lkl__u8,
    pub ioprio: __lkl__u16,
    pub fd: __lkl__s32,
    pub __bindgen_anon_1: lkl_io_uring_sqe__bindgen_ty_1,
    pub __bindgen_anon_2: lkl_io_uring_sqe__bindgen_ty_2,
    pub len: __lkl__u32,
    pub __bindgen_anon_3: lkl_io_uring_sqe__bindgen_ty_3,
    pub user_data: __lkl__u64,
    pub __bindgen_anon_4: lkl_io_uring_sqe__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_io_uring_sqe__bindgen_ty_1 {
    pub off: __lkl__u64,
    pub addr2: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_io_uring_sqe__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_sqe__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_io_uring_sqe__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_sqe__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_io_uring_sqe__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_1>())).off as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_1),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_1>())).addr2 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_1),
            "::",
            stringify!(addr2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_io_uring_sqe__bindgen_ty_2 {
    pub addr: __lkl__u64,
    pub splice_off_in: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_io_uring_sqe__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_sqe__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_io_uring_sqe__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_sqe__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_io_uring_sqe__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_2>())).addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_2),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_2>())).splice_off_in as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_2),
            "::",
            stringify!(splice_off_in)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_io_uring_sqe__bindgen_ty_3 {
    pub rw_flags: __lkl__kernel_rwf_t,
    pub fsync_flags: __lkl__u32,
    pub poll_events: __lkl__u16,
    pub poll32_events: __lkl__u32,
    pub sync_range_flags: __lkl__u32,
    pub msg_flags: __lkl__u32,
    pub timeout_flags: __lkl__u32,
    pub accept_flags: __lkl__u32,
    pub cancel_flags: __lkl__u32,
    pub open_flags: __lkl__u32,
    pub statx_flags: __lkl__u32,
    pub fadvise_advice: __lkl__u32,
    pub splice_flags: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_io_uring_sqe__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_sqe__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(lkl_io_uring_sqe__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_sqe__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_io_uring_sqe__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).rw_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(rw_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).fsync_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(fsync_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).poll_events as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(poll_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).poll32_events as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(poll32_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).sync_range_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(sync_range_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).msg_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(msg_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).timeout_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(timeout_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).accept_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(accept_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).cancel_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(cancel_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).open_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(open_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).statx_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(statx_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).fadvise_advice as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(fadvise_advice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_3>())).splice_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_3),
            "::",
            stringify!(splice_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_io_uring_sqe__bindgen_ty_4 {
    pub __bindgen_anon_1: lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1,
    pub __pad2: [__lkl__u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1 {
    pub __bindgen_anon_1: lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub personality: __lkl__u16,
    pub splice_fd_in: __lkl__s32,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub buf_index: __lkl__u16,
    pub buf_group: __lkl__u16,
}
#[test]
fn bindgen_test_layout_lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>()))
                .buf_index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(buf_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>()))
                .buf_group as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(buf_group)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1>())).personality
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(personality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1>())).splice_fd_in
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(splice_fd_in)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_io_uring_sqe__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_sqe__bindgen_ty_4>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_io_uring_sqe__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_sqe__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_io_uring_sqe__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_sqe__bindgen_ty_4>())).__pad2 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe__bindgen_ty_4),
            "::",
            stringify!(__pad2)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_io_uring_sqe() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_sqe>(),
        64usize,
        concat!("Size of: ", stringify!(lkl_io_uring_sqe))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_sqe>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_io_uring_sqe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_sqe>())).opcode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_sqe>())).flags as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_sqe>())).ioprio as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe),
            "::",
            stringify!(ioprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_sqe>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_sqe>())).len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_sqe>())).user_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_sqe),
            "::",
            stringify!(user_data)
        )
    );
}
pub const LKL_IOSQE_FIXED_FILE_BIT: ::std::os::raw::c_uint = 0;
pub const LKL_IOSQE_IO_DRAIN_BIT: ::std::os::raw::c_uint = 1;
pub const LKL_IOSQE_IO_LINK_BIT: ::std::os::raw::c_uint = 2;
pub const LKL_IOSQE_IO_HARDLINK_BIT: ::std::os::raw::c_uint = 3;
pub const LKL_IOSQE_ASYNC_BIT: ::std::os::raw::c_uint = 4;
pub const LKL_IOSQE_BUFFER_SELECT_BIT: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_153 = ::std::os::raw::c_uint;
pub const LKL_IORING_OP_NOP: ::std::os::raw::c_uint = 0;
pub const LKL_IORING_OP_READV: ::std::os::raw::c_uint = 1;
pub const LKL_IORING_OP_WRITEV: ::std::os::raw::c_uint = 2;
pub const LKL_IORING_OP_FSYNC: ::std::os::raw::c_uint = 3;
pub const LKL_IORING_OP_READ_FIXED: ::std::os::raw::c_uint = 4;
pub const LKL_IORING_OP_WRITE_FIXED: ::std::os::raw::c_uint = 5;
pub const LKL_IORING_OP_POLL_ADD: ::std::os::raw::c_uint = 6;
pub const LKL_IORING_OP_POLL_REMOVE: ::std::os::raw::c_uint = 7;
pub const LKL_IORING_OP_SYNC_FILE_RANGE: ::std::os::raw::c_uint = 8;
pub const LKL_IORING_OP_SENDMSG: ::std::os::raw::c_uint = 9;
pub const LKL_IORING_OP_RECVMSG: ::std::os::raw::c_uint = 10;
pub const LKL_IORING_OP_TIMEOUT: ::std::os::raw::c_uint = 11;
pub const LKL_IORING_OP_TIMEOUT_REMOVE: ::std::os::raw::c_uint = 12;
pub const LKL_IORING_OP_ACCEPT: ::std::os::raw::c_uint = 13;
pub const LKL_IORING_OP_ASYNC_CANCEL: ::std::os::raw::c_uint = 14;
pub const LKL_IORING_OP_LINK_TIMEOUT: ::std::os::raw::c_uint = 15;
pub const LKL_IORING_OP_CONNECT: ::std::os::raw::c_uint = 16;
pub const LKL_IORING_OP_FALLOCATE: ::std::os::raw::c_uint = 17;
pub const LKL_IORING_OP_OPENAT: ::std::os::raw::c_uint = 18;
pub const LKL_IORING_OP_CLOSE: ::std::os::raw::c_uint = 19;
pub const LKL_IORING_OP_FILES_UPDATE: ::std::os::raw::c_uint = 20;
pub const LKL_IORING_OP_STATX: ::std::os::raw::c_uint = 21;
pub const LKL_IORING_OP_READ: ::std::os::raw::c_uint = 22;
pub const LKL_IORING_OP_WRITE: ::std::os::raw::c_uint = 23;
pub const LKL_IORING_OP_FADVISE: ::std::os::raw::c_uint = 24;
pub const LKL_IORING_OP_MADVISE: ::std::os::raw::c_uint = 25;
pub const LKL_IORING_OP_SEND: ::std::os::raw::c_uint = 26;
pub const LKL_IORING_OP_RECV: ::std::os::raw::c_uint = 27;
pub const LKL_IORING_OP_OPENAT2: ::std::os::raw::c_uint = 28;
pub const LKL_IORING_OP_EPOLL_CTL: ::std::os::raw::c_uint = 29;
pub const LKL_IORING_OP_SPLICE: ::std::os::raw::c_uint = 30;
pub const LKL_IORING_OP_PROVIDE_BUFFERS: ::std::os::raw::c_uint = 31;
pub const LKL_IORING_OP_REMOVE_BUFFERS: ::std::os::raw::c_uint = 32;
pub const LKL_IORING_OP_TEE: ::std::os::raw::c_uint = 33;
pub const LKL_IORING_OP_LAST: ::std::os::raw::c_uint = 34;
pub type _bindgen_ty_154 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_io_uring_cqe {
    pub user_data: __lkl__u64,
    pub res: __lkl__s32,
    pub flags: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_io_uring_cqe() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_cqe>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_io_uring_cqe))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_cqe>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_io_uring_cqe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_cqe>())).user_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_cqe),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_cqe>())).res as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_cqe),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_cqe>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_cqe),
            "::",
            stringify!(flags)
        )
    );
}
pub const LKL_IORING_CQE_BUFFER_SHIFT: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_155 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_io_sqring_offsets {
    pub head: __lkl__u32,
    pub tail: __lkl__u32,
    pub ring_mask: __lkl__u32,
    pub ring_entries: __lkl__u32,
    pub flags: __lkl__u32,
    pub dropped: __lkl__u32,
    pub array: __lkl__u32,
    pub resv1: __lkl__u32,
    pub resv2: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_io_sqring_offsets() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_sqring_offsets>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_io_sqring_offsets))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_sqring_offsets>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_io_sqring_offsets))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_sqring_offsets>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_sqring_offsets),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_sqring_offsets>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_sqring_offsets),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_sqring_offsets>())).ring_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_sqring_offsets),
            "::",
            stringify!(ring_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_sqring_offsets>())).ring_entries as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_sqring_offsets),
            "::",
            stringify!(ring_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_sqring_offsets>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_sqring_offsets),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_sqring_offsets>())).dropped as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_sqring_offsets),
            "::",
            stringify!(dropped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_sqring_offsets>())).array as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_sqring_offsets),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_sqring_offsets>())).resv1 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_sqring_offsets),
            "::",
            stringify!(resv1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_sqring_offsets>())).resv2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_sqring_offsets),
            "::",
            stringify!(resv2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_io_cqring_offsets {
    pub head: __lkl__u32,
    pub tail: __lkl__u32,
    pub ring_mask: __lkl__u32,
    pub ring_entries: __lkl__u32,
    pub overflow: __lkl__u32,
    pub cqes: __lkl__u32,
    pub flags: __lkl__u32,
    pub resv1: __lkl__u32,
    pub resv2: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_io_cqring_offsets() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_cqring_offsets>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_io_cqring_offsets))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_cqring_offsets>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_io_cqring_offsets))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_cqring_offsets>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_cqring_offsets),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_cqring_offsets>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_cqring_offsets),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_cqring_offsets>())).ring_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_cqring_offsets),
            "::",
            stringify!(ring_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_cqring_offsets>())).ring_entries as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_cqring_offsets),
            "::",
            stringify!(ring_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_cqring_offsets>())).overflow as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_cqring_offsets),
            "::",
            stringify!(overflow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_cqring_offsets>())).cqes as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_cqring_offsets),
            "::",
            stringify!(cqes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_cqring_offsets>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_cqring_offsets),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_cqring_offsets>())).resv1 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_cqring_offsets),
            "::",
            stringify!(resv1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_cqring_offsets>())).resv2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_cqring_offsets),
            "::",
            stringify!(resv2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_io_uring_params {
    pub sq_entries: __lkl__u32,
    pub cq_entries: __lkl__u32,
    pub flags: __lkl__u32,
    pub sq_thread_cpu: __lkl__u32,
    pub sq_thread_idle: __lkl__u32,
    pub features: __lkl__u32,
    pub wq_fd: __lkl__u32,
    pub resv: [__lkl__u32; 3usize],
    pub sq_off: lkl_io_sqring_offsets,
    pub cq_off: lkl_io_cqring_offsets,
}
#[test]
fn bindgen_test_layout_lkl_io_uring_params() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_params>(),
        120usize,
        concat!("Size of: ", stringify!(lkl_io_uring_params))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_params>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_io_uring_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_params>())).sq_entries as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_params),
            "::",
            stringify!(sq_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_params>())).cq_entries as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_params),
            "::",
            stringify!(cq_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_params>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_params),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_params>())).sq_thread_cpu as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_params),
            "::",
            stringify!(sq_thread_cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_params>())).sq_thread_idle as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_params),
            "::",
            stringify!(sq_thread_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_params>())).features as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_params),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_params>())).wq_fd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_params),
            "::",
            stringify!(wq_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_params>())).resv as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_params),
            "::",
            stringify!(resv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_params>())).sq_off as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_params),
            "::",
            stringify!(sq_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_params>())).cq_off as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_params),
            "::",
            stringify!(cq_off)
        )
    );
}
pub const LKL_IORING_REGISTER_BUFFERS: ::std::os::raw::c_uint = 0;
pub const LKL_IORING_UNREGISTER_BUFFERS: ::std::os::raw::c_uint = 1;
pub const LKL_IORING_REGISTER_FILES: ::std::os::raw::c_uint = 2;
pub const LKL_IORING_UNREGISTER_FILES: ::std::os::raw::c_uint = 3;
pub const LKL_IORING_REGISTER_EVENTFD: ::std::os::raw::c_uint = 4;
pub const LKL_IORING_UNREGISTER_EVENTFD: ::std::os::raw::c_uint = 5;
pub const LKL_IORING_REGISTER_FILES_UPDATE: ::std::os::raw::c_uint = 6;
pub const LKL_IORING_REGISTER_EVENTFD_ASYNC: ::std::os::raw::c_uint = 7;
pub const LKL_IORING_REGISTER_PROBE: ::std::os::raw::c_uint = 8;
pub const LKL_IORING_REGISTER_PERSONALITY: ::std::os::raw::c_uint = 9;
pub const LKL_IORING_UNREGISTER_PERSONALITY: ::std::os::raw::c_uint = 10;
pub const LKL_IORING_REGISTER_RESTRICTIONS: ::std::os::raw::c_uint = 11;
pub const LKL_IORING_REGISTER_ENABLE_RINGS: ::std::os::raw::c_uint = 12;
pub const LKL_IORING_REGISTER_LAST: ::std::os::raw::c_uint = 13;
pub type _bindgen_ty_156 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_io_uring_files_update {
    pub offset: __lkl__u32,
    pub resv: __lkl__u32,
    pub fds: __lkl__u64,
}
#[test]
fn bindgen_test_layout_lkl_io_uring_files_update() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_files_update>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_io_uring_files_update))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_files_update>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_io_uring_files_update))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_files_update>())).offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_files_update),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_files_update>())).resv as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_files_update),
            "::",
            stringify!(resv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_files_update>())).fds as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_files_update),
            "::",
            stringify!(fds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_io_uring_probe_op {
    pub op: __lkl__u8,
    pub resv: __lkl__u8,
    pub flags: __lkl__u16,
    pub resv2: __lkl__u32,
}
#[test]
fn bindgen_test_layout_lkl_io_uring_probe_op() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_probe_op>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_io_uring_probe_op))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_probe_op>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_io_uring_probe_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_probe_op>())).op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_probe_op),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_probe_op>())).resv as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_probe_op),
            "::",
            stringify!(resv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_probe_op>())).flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_probe_op),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_probe_op>())).resv2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_probe_op),
            "::",
            stringify!(resv2)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_io_uring_probe {
    pub last_op: __lkl__u8,
    pub ops_len: __lkl__u8,
    pub resv: __lkl__u16,
    pub resv2: [__lkl__u32; 3usize],
    pub ops: __IncompleteArrayField<lkl_io_uring_probe_op>,
}
#[test]
fn bindgen_test_layout_lkl_io_uring_probe() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_probe>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_io_uring_probe))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_probe>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_io_uring_probe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_probe>())).last_op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_probe),
            "::",
            stringify!(last_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_probe>())).ops_len as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_probe),
            "::",
            stringify!(ops_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_probe>())).resv as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_probe),
            "::",
            stringify!(resv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_probe>())).resv2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_probe),
            "::",
            stringify!(resv2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_probe>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_probe),
            "::",
            stringify!(ops)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_io_uring_restriction {
    pub opcode: __lkl__u16,
    pub __bindgen_anon_1: lkl_io_uring_restriction__bindgen_ty_1,
    pub resv: __lkl__u8,
    pub resv2: [__lkl__u32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_io_uring_restriction__bindgen_ty_1 {
    pub register_op: __lkl__u8,
    pub sqe_op: __lkl__u8,
    pub sqe_flags: __lkl__u8,
}
#[test]
fn bindgen_test_layout_lkl_io_uring_restriction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_restriction__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(lkl_io_uring_restriction__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_restriction__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(lkl_io_uring_restriction__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_restriction__bindgen_ty_1>())).register_op
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_restriction__bindgen_ty_1),
            "::",
            stringify!(register_op)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_restriction__bindgen_ty_1>())).sqe_op as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_restriction__bindgen_ty_1),
            "::",
            stringify!(sqe_op)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lkl_io_uring_restriction__bindgen_ty_1>())).sqe_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_restriction__bindgen_ty_1),
            "::",
            stringify!(sqe_flags)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_io_uring_restriction() {
    assert_eq!(
        ::std::mem::size_of::<lkl_io_uring_restriction>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_io_uring_restriction))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_io_uring_restriction>(),
        4usize,
        concat!("Alignment of ", stringify!(lkl_io_uring_restriction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_restriction>())).opcode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_restriction),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_restriction>())).resv as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_restriction),
            "::",
            stringify!(resv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_io_uring_restriction>())).resv2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_io_uring_restriction),
            "::",
            stringify!(resv2)
        )
    );
}
pub const LKL_IORING_RESTRICTION_REGISTER_OP: ::std::os::raw::c_uint = 0;
pub const LKL_IORING_RESTRICTION_SQE_OP: ::std::os::raw::c_uint = 1;
pub const LKL_IORING_RESTRICTION_SQE_FLAGS_ALLOWED: ::std::os::raw::c_uint = 2;
pub const LKL_IORING_RESTRICTION_SQE_FLAGS_REQUIRED: ::std::os::raw::c_uint = 3;
pub const LKL_IORING_RESTRICTION_LAST: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_157 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_user_msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: ::std::os::raw::c_int,
    pub msg_iov: *mut lkl_iovec,
    pub msg_iovlen: __lkl__kernel_size_t,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: __lkl__kernel_size_t,
    pub msg_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_user_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_user_msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(lkl_user_msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_user_msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_user_msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_user_msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_user_msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_user_msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_user_msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_user_msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_user_msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_user_msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_user_msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_user_msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_user_msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_user_msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_user_msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_user_msghdr>())).msg_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_user_msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
pub type lkl_key_serial_t = __lkl__u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_mmsghdr {
    pub msg_hdr: lkl_user_msghdr,
    pub msg_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_mmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<lkl_mmsghdr>(),
        64usize,
        concat!("Size of: ", stringify!(lkl_mmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_mmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_mmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_mmsghdr>())).msg_hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_mmsghdr),
            "::",
            stringify!(msg_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_mmsghdr>())).msg_len as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_mmsghdr),
            "::",
            stringify!(msg_len)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct lkl_linux_dirent64 {
    pub d_ino: lkl_u64,
    pub d_off: lkl_s64,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_lkl_linux_dirent64() {
    assert_eq!(
        ::std::mem::size_of::<lkl_linux_dirent64>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_linux_dirent64))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_linux_dirent64>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_linux_dirent64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_linux_dirent64>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_linux_dirent64),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_linux_dirent64>())).d_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_linux_dirent64),
            "::",
            stringify!(d_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_linux_dirent64>())).d_reclen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_linux_dirent64),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_linux_dirent64>())).d_type as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_linux_dirent64),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_linux_dirent64>())).d_name as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_linux_dirent64),
            "::",
            stringify!(d_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_linux_dirent {
    pub d_ino: ::std::os::raw::c_ulong,
    pub d_off: ::std::os::raw::c_ulong,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_name: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_lkl_linux_dirent() {
    assert_eq!(
        ::std::mem::size_of::<lkl_linux_dirent>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_linux_dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_linux_dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_linux_dirent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_linux_dirent>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_linux_dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_linux_dirent>())).d_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_linux_dirent),
            "::",
            stringify!(d_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_linux_dirent>())).d_reclen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_linux_dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_linux_dirent>())).d_name as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_linux_dirent),
            "::",
            stringify!(d_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_ustat {
    pub f_tfree: __lkl__kernel_daddr_t,
    pub f_tinode: __lkl__kernel_ino_t,
    pub f_fname: [::std::os::raw::c_char; 6usize],
    pub f_fpack: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_lkl_ustat() {
    assert_eq!(
        ::std::mem::size_of::<lkl_ustat>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_ustat))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_ustat>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_ustat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ustat>())).f_tfree as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ustat),
            "::",
            stringify!(f_tfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ustat>())).f_tinode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ustat),
            "::",
            stringify!(f_tinode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ustat>())).f_fname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ustat),
            "::",
            stringify!(f_fname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_ustat>())).f_fpack as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_ustat),
            "::",
            stringify!(f_fpack)
        )
    );
}
pub type lkl_rwf_t = __lkl__kernel_rwf_t;
extern "C" {
    pub fn lkl_syscall(
        no: ::std::os::raw::c_long,
        params: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lkl_sys_halt() -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " lkl_strerror - returns a string describing the given error code"]
    #[doc = ""]
    #[doc = " @err - error code"]
    #[doc = " @returns - string for the given error code"]
    pub fn lkl_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " lkl_perror - prints a string describing the given error code"]
    #[doc = ""]
    #[doc = " @msg - prefix for the error message"]
    #[doc = " @err - error code"]
    pub fn lkl_perror(msg: *mut ::std::os::raw::c_char, err: ::std::os::raw::c_int);
}
#[doc = " lkl_disk - host disk handle"]
#[doc = ""]
#[doc = " @dev - a pointer to 'virtio_blk_dev' structure for this disk"]
#[doc = " @fd - a POSIX file descriptor that can be used by preadv/pwritev"]
#[doc = " @handle - an NT file handle that can be used by ReadFile/WriteFile"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lkl_disk {
    pub dev: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: lkl_disk__bindgen_ty_1,
    pub ops: *mut lkl_dev_blk_ops,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lkl_disk__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lkl_disk__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lkl_disk__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lkl_disk__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_disk__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_disk__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_disk__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_disk__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_disk__bindgen_ty_1>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_disk__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
}
#[test]
fn bindgen_test_layout_lkl_disk() {
    assert_eq!(
        ::std::mem::size_of::<lkl_disk>(),
        24usize,
        concat!("Size of: ", stringify!(lkl_disk))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_disk>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_disk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_disk>())).dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_disk),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_disk>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_disk),
            "::",
            stringify!(ops)
        )
    );
}
extern "C" {
    #[doc = " lkl_disk_add - add a new disk"]
    #[doc = ""]
    #[doc = " @disk - the host disk handle"]
    #[doc = " @returns a disk id (0 is valid) or a strictly negative value in case of error"]
    pub fn lkl_disk_add(disk: *mut lkl_disk) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_disk_remove - remove a disk"]
    #[doc = ""]
    #[doc = " This function makes a cleanup of the @disk's virtio_dev structure"]
    #[doc = " that was initialized by lkl_disk_add before."]
    #[doc = ""]
    #[doc = " @disk - the host disk handle"]
    pub fn lkl_disk_remove(disk: lkl_disk) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_get_virtiolkl_encode_dev_from_sysfs_blkdev - extract device id from sysfs"]
    #[doc = ""]
    #[doc = " This function returns the device id for the given sysfs dev node."]
    #[doc = " The content of the node has to be in the form 'MAJOR:MINOR'."]
    #[doc = " Also, this function expects an absolute path which means that sysfs"]
    #[doc = " already has to be mounted at the given path"]
    #[doc = ""]
    #[doc = " @sysfs_path - absolute path to the sysfs dev node"]
    #[doc = " @pdevid - pointer to memory where dev id will be returned"]
    #[doc = " @returns - 0 on success, a negative value on error"]
    pub fn lkl_encode_dev_from_sysfs(
        sysfs_path: *const ::std::os::raw::c_char,
        pdevid: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_get_virtio_blkdev - get device id of a disk (partition)"]
    #[doc = ""]
    #[doc = " This function returns the device id for the given disk."]
    #[doc = ""]
    #[doc = " @disk_id - the disk id identifying the disk"]
    #[doc = " @part - disk partition or zero for full disk"]
    #[doc = " @pdevid - pointer to memory where dev id will be returned"]
    #[doc = " @returns - 0 on success, a negative value on error"]
    pub fn lkl_get_virtio_blkdev(
        disk_id: ::std::os::raw::c_int,
        part: ::std::os::raw::c_uint,
        pdevid: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_mount_dev - mount a disk"]
    #[doc = ""]
    #[doc = " This functions creates a device file for the given disk, creates a mount"]
    #[doc = " point and mounts the device over the mount point."]
    #[doc = ""]
    #[doc = " @disk_id - the disk id identifying the disk to be mounted"]
    #[doc = " @part - disk partition or zero for full disk"]
    #[doc = " @fs_type - filesystem type"]
    #[doc = " @flags - mount flags"]
    #[doc = " @opts - additional filesystem specific mount options"]
    #[doc = " @mnt_str - a string that will be filled by this function with the path where"]
    #[doc = " the filesystem has been mounted"]
    #[doc = " @mnt_str_len - size of mnt_str"]
    #[doc = " @returns - 0 on success, a negative value on error"]
    pub fn lkl_mount_dev(
        disk_id: ::std::os::raw::c_uint,
        part: ::std::os::raw::c_uint,
        fs_type: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        opts: *const ::std::os::raw::c_char,
        mnt_str: *mut ::std::os::raw::c_char,
        mnt_str_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " lkl_mount_blkdev - mount a block device"]
    #[doc = ""]
    #[doc = " Like lkl_mount_dev, but mounts the device specified by dev."]
    #[doc = ""]
    #[doc = " @dev - the device id (can be generated by LKL_MKDEV()) identifying the device"]
    #[doc = " to be mounted"]
    #[doc = " @fs_type - filesystem type"]
    #[doc = " @flags - mount flags"]
    #[doc = " @opts - additional filesystem specific mount options"]
    #[doc = " @mnt_str - a string that will be filled by this function with the path where"]
    #[doc = " the filesystem has been mounted"]
    #[doc = " @mnt_str_len - size of mnt_str"]
    #[doc = " @returns - 0 on success, a negative value on error"]
    pub fn lkl_mount_blkdev(
        dev: ::std::os::raw::c_uint,
        fs_type: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        opts: *const ::std::os::raw::c_char,
        mnt_str: *mut ::std::os::raw::c_char,
        mnt_str_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " lkl_umount_dev - umount a disk"]
    #[doc = ""]
    #[doc = " This functions umounts the given disks and removes the device file and the"]
    #[doc = " mount point."]
    #[doc = ""]
    #[doc = " @disk_id - the disk id identifying the disk to be mounted"]
    #[doc = " @part - disk partition or zero for full disk"]
    #[doc = " @flags - umount flags"]
    #[doc = " @timeout_ms - timeout to wait for the kernel to flush closed files so that"]
    #[doc = " umount can succeed"]
    #[doc = " @returns - 0 on success, a negative value on error"]
    pub fn lkl_umount_dev(
        disk_id: ::std::os::raw::c_uint,
        part: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_int,
        timeout_ms: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " lkl_umount_blkdev - umount a block device"]
    #[doc = ""]
    #[doc = " Like lkl_umount_dev, but unmounts the device specified by dev."]
    #[doc = ""]
    #[doc = " @dev - the device id identifying the device to be mounted"]
    #[doc = " @flags - umount flags"]
    #[doc = " @timeout_ms - timeout to wait for the kernel to flush closed files so that"]
    #[doc = " umount can succeed"]
    #[doc = " @returns - 0 on success, a negative value on error"]
    pub fn lkl_umount_blkdev(
        dev: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_int,
        timeout_ms: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " lkl_umount_timeout - umount filesystem with timeout"]
    #[doc = ""]
    #[doc = " @path - the path to unmount"]
    #[doc = " @flags - umount flags"]
    #[doc = " @timeout_ms - timeout to wait for the kernel to flush closed files so that"]
    #[doc = " umount can succeed"]
    #[doc = " @returns - 0 on success, a negative value on error"]
    pub fn lkl_umount_timeout(
        path: *mut ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        timeout_ms: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_dir {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " lkl_opendir - open a directory"]
    #[doc = ""]
    #[doc = " @path - directory path"]
    #[doc = " @err - pointer to store the error in case of failure"]
    #[doc = " @returns - a handle to be used when calling lkl_readdir"]
    pub fn lkl_opendir(
        path: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut lkl_dir;
}
extern "C" {
    #[doc = " lkl_fdopendir - open a directory"]
    #[doc = ""]
    #[doc = " @fd - file descriptor"]
    #[doc = " @err - pointer to store the error in case of failure"]
    #[doc = " @returns - a handle to be used when calling lkl_readdir"]
    pub fn lkl_fdopendir(
        fd: ::std::os::raw::c_int,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut lkl_dir;
}
extern "C" {
    #[doc = " lkl_rewinddir - reset directory stream"]
    #[doc = ""]
    #[doc = " @dir - the directory handler as returned by lkl_opendir"]
    pub fn lkl_rewinddir(dir: *mut lkl_dir);
}
extern "C" {
    #[doc = " lkl_closedir - close the directory"]
    #[doc = ""]
    #[doc = " @dir - the directory handler as returned by lkl_opendir"]
    pub fn lkl_closedir(dir: *mut lkl_dir) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_readdir - get the next available entry of the directory"]
    #[doc = ""]
    #[doc = " @dir - the directory handler as returned by lkl_opendir"]
    #[doc = " @returns - a lkl_dirent64 entry or NULL if the end of the directory stream is"]
    #[doc = " reached or if an error occurred; check lkl_errdir() to distinguish between"]
    #[doc = " errors or end of the directory stream"]
    pub fn lkl_readdir(dir: *mut lkl_dir) -> *mut lkl_linux_dirent64;
}
extern "C" {
    #[doc = " lkl_errdir - checks if an error occurred during the last lkl_readdir call"]
    #[doc = ""]
    #[doc = " @dir - the directory handler as returned by lkl_opendir"]
    #[doc = " @returns - 0 if no error occurred, or a negative value otherwise"]
    pub fn lkl_errdir(dir: *mut lkl_dir) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_dirfd - gets the file descriptor associated with the directory handle"]
    #[doc = ""]
    #[doc = " @dir - the directory handle as returned by lkl_opendir"]
    #[doc = " @returns - a positive value,which is the LKL file descriptor associated with"]
    #[doc = " the directory handle, or a negative value otherwise"]
    pub fn lkl_dirfd(dir: *mut lkl_dir) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_up - activate network interface"]
    #[doc = ""]
    #[doc = " @ifindex - the ifindex of the interface"]
    #[doc = " @returns - return 0 if no error: otherwise negative value returns"]
    pub fn lkl_if_up(ifindex: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_down - deactivate network interface"]
    #[doc = ""]
    #[doc = " @ifindex - the ifindex of the interface"]
    #[doc = " @returns - return 0 if no error: otherwise negative value returns"]
    pub fn lkl_if_down(ifindex: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_set_mtu - set MTU on interface"]
    #[doc = ""]
    #[doc = " @ifindex - the ifindex of the interface"]
    #[doc = " @mtu - the requested MTU size"]
    #[doc = " @returns - return 0 if no error: otherwise negative value returns"]
    pub fn lkl_if_set_mtu(
        ifindex: ::std::os::raw::c_int,
        mtu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_set_ipv4 - set IPv4 address on interface"]
    #[doc = ""]
    #[doc = " @ifindex - the ifindex of the interface"]
    #[doc = " @addr - 4-byte IP address (i.e., struct in_addr)"]
    #[doc = " @netmask_len - prefix length of the @addr"]
    #[doc = " @returns - return 0 if no error: otherwise negative value returns"]
    pub fn lkl_if_set_ipv4(
        ifindex: ::std::os::raw::c_int,
        addr: ::std::os::raw::c_uint,
        netmask_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_set_ipv4_gateway - add an IPv4 default route"]
    #[doc = ""]
    #[doc = " @addr - 4-byte IP address of the gateway (i.e., struct in_addr)"]
    #[doc = " @returns - return 0 if no error: otherwise negative value returns"]
    pub fn lkl_set_ipv4_gateway(addr: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_set_ipv4_gateway - add an IPv4 default route in rule table"]
    #[doc = ""]
    #[doc = " @ifindex - the ifindex of the interface, used for tableid calculation"]
    #[doc = " @addr - 4-byte IP address of the interface"]
    #[doc = " @netmask_len - prefix length of the @addr"]
    #[doc = " @gw_addr - 4-byte IP address of the gateway"]
    #[doc = " @returns - return 0 if no error: otherwise negative value returns"]
    pub fn lkl_if_set_ipv4_gateway(
        ifindex: ::std::os::raw::c_int,
        addr: ::std::os::raw::c_uint,
        netmask_len: ::std::os::raw::c_uint,
        gw_addr: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_set_ipv6 - set IPv6 address on interface"]
    #[doc = " must be called after interface is up."]
    #[doc = ""]
    #[doc = " @ifindex - the ifindex of the interface"]
    #[doc = " @addr - 16-byte IPv6 address (i.e., struct in6_addr)"]
    #[doc = " @netprefix_len - prefix length of the @addr"]
    #[doc = " @returns - return 0 if no error: otherwise negative value returns"]
    pub fn lkl_if_set_ipv6(
        ifindex: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        netprefix_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_set_ipv6_gateway - add an IPv6 default route"]
    #[doc = ""]
    #[doc = " @addr - 16-byte IPv6 address of the gateway (i.e., struct in6_addr)"]
    #[doc = " @returns - return 0 if no error: otherwise negative value returns"]
    pub fn lkl_set_ipv6_gateway(addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_set_ipv6_gateway - add an IPv6 default route in rule table"]
    #[doc = ""]
    #[doc = " @ifindex - the ifindex of the interface, used for tableid calculation"]
    #[doc = " @addr - 16-byte IP address of the interface"]
    #[doc = " @netmask_len - prefix length of the @addr"]
    #[doc = " @gw_addr - 16-byte IP address of the gateway (i.e., struct in_addr)"]
    #[doc = " @returns - return 0 if no error: otherwise negative value returns"]
    pub fn lkl_if_set_ipv6_gateway(
        ifindex: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        netmask_len: ::std::os::raw::c_uint,
        gw_addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_ifname_to_ifindex - obtain ifindex of an interface by name"]
    #[doc = ""]
    #[doc = " @name - string of an interface"]
    #[doc = " @returns - return an integer of ifindex if no error"]
    pub fn lkl_ifname_to_ifindex(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[doc = " lkl_netdev_args - arguments to lkl_netdev_add"]
#[doc = " @mac - optional MAC address for the device"]
#[doc = " @offload - offload bits for the device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_netdev_args {
    pub mac: *mut ::std::os::raw::c_void,
    pub offload: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lkl_netdev_args() {
    assert_eq!(
        ::std::mem::size_of::<lkl_netdev_args>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_netdev_args))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_netdev_args>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_netdev_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_netdev_args>())).mac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_netdev_args),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_netdev_args>())).offload as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_netdev_args),
            "::",
            stringify!(offload)
        )
    );
}
extern "C" {
    pub fn lkl_netdev_add(nd: *mut lkl_netdev, args: *mut lkl_netdev_args)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lkl_netdev_remove(id: ::std::os::raw::c_int);
}
extern "C" {
    pub fn lkl_netdev_free(nd: *mut lkl_netdev);
}
extern "C" {
    #[doc = " lkl_netdev_get_ifindex - retrieve the interface index for a given network"]
    #[doc = " device id"]
    #[doc = ""]
    #[doc = " @id - the network device id"]
    #[doc = " @returns the interface index or a stricly negative value in case of error"]
    pub fn lkl_netdev_get_ifindex(id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lkl_netdev_tap_create(
        ifname: *const ::std::os::raw::c_char,
        offload: ::std::os::raw::c_int,
    ) -> *mut lkl_netdev;
}
extern "C" {
    pub fn lkl_netdev_raw_create(ifname: *const ::std::os::raw::c_char) -> *mut lkl_netdev;
}
extern "C" {
    pub fn lkl_netdev_macvtap_create(
        path: *const ::std::os::raw::c_char,
        offload: ::std::os::raw::c_int,
    ) -> *mut lkl_netdev;
}
extern "C" {
    pub fn lkl_netdev_pipe_create(
        ifname: *const ::std::os::raw::c_char,
        offload: ::std::os::raw::c_int,
    ) -> *mut lkl_netdev;
}
extern "C" {
    pub fn lkl_register_dbg_handler();
}
extern "C" {
    #[doc = " lkl_add_neighbor - add a permanent arp entry"]
    #[doc = " @ifindex - the ifindex of the interface"]
    #[doc = " @af - address family of the ip address. Must be LKL_AF_INET or LKL_AF_INET6"]
    #[doc = " @ip - ip address of the entry in network byte order"]
    #[doc = " @mac - mac address of the entry"]
    pub fn lkl_add_neighbor(
        ifindex: ::std::os::raw::c_int,
        af: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        mac: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_mount_fs - mount a file system type like proc, sys"]
    #[doc = " @fstype - file system type. e.g. proc, sys"]
    #[doc = " @returns - 0 on success. 1 if it's already mounted. negative on failure."]
    pub fn lkl_mount_fs(fstype: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_add_ip - add an ip address"]
    #[doc = " @ifindex - the ifindex of the interface"]
    #[doc = " @af - address family of the ip address. Must be LKL_AF_INET or LKL_AF_INET6"]
    #[doc = " @addr - ip address of the entry in network byte order"]
    #[doc = " @netprefix_len - prefix length of the @addr"]
    pub fn lkl_if_add_ip(
        ifindex: ::std::os::raw::c_int,
        af: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        netprefix_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_del_ip - add an ip address"]
    #[doc = " @ifindex - the ifindex of the interface"]
    #[doc = " @af - address family of the ip address. Must be LKL_AF_INET or LKL_AF_INET6"]
    #[doc = " @addr - ip address of the entry in network byte order"]
    #[doc = " @netprefix_len - prefix length of the @addr"]
    pub fn lkl_if_del_ip(
        ifindex: ::std::os::raw::c_int,
        af: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        netprefix_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_add_gateway - add a gateway"]
    #[doc = " @af - address family of the ip address. Must be LKL_AF_INET or LKL_AF_INET6"]
    #[doc = " @gwaddr - 4-byte IP address of the gateway (i.e., struct in_addr)"]
    pub fn lkl_add_gateway(
        af: ::std::os::raw::c_int,
        gwaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XXX Should I use OIF selector?"]
    #[doc = " temporary table idx = ifindex * 2 + 0 <- ipv4"]
    #[doc = " temporary table idx = ifindex * 2 + 1 <- ipv6"]
    #[doc = " lkl_if_add_rule_from_addr - create an ip rule table with \"from\" selector"]
    #[doc = " @ifindex - the ifindex of the interface, used for table id calculation"]
    #[doc = " @af - address family of the ip address. Must be LKL_AF_INET or LKL_AF_INET6"]
    #[doc = " @saddr - network byte order ip address, \"from\" selector address of this rule"]
    pub fn lkl_if_add_rule_from_saddr(
        ifindex: ::std::os::raw::c_int,
        af: ::std::os::raw::c_int,
        saddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_add_gateway - add gateway to rule table"]
    #[doc = " @ifindex - the ifindex of the interface, used for table id calculation"]
    #[doc = " @af - address family of the ip address. Must be LKL_AF_INET or LKL_AF_INET6"]
    #[doc = " @gwaddr - 4-byte IP address of the gateway (i.e., struct in_addr)"]
    pub fn lkl_if_add_gateway(
        ifindex: ::std::os::raw::c_int,
        af: ::std::os::raw::c_int,
        gwaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_add_linklocal - add linklocal route to rule table"]
    #[doc = " @ifindex - the ifindex of the interface, used for table id calculation"]
    #[doc = " @af - address family of the ip address. Must be LKL_AF_INET or LKL_AF_INET6"]
    #[doc = " @addr - ip address of the entry in network byte order"]
    #[doc = " @netprefix_len - prefix length of the @addr"]
    pub fn lkl_if_add_linklocal(
        ifindex: ::std::os::raw::c_int,
        af: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        netprefix_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_if_wait_ipv6_dad - wait for DAD to be done for a ipv6 address"]
    #[doc = " must be called after interface is up"]
    #[doc = ""]
    #[doc = " @ifindex - the ifindex of the interface"]
    #[doc = " @addr - ip address of the entry in network byte order"]
    pub fn lkl_if_wait_ipv6_dad(
        ifindex: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_set_fd_limit - set the maximum number of file descriptors allowed"]
    #[doc = " @fd_limit - fd max limit"]
    pub fn lkl_set_fd_limit(fd_limit: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_qdisc_add - set qdisc rule onto an interface"]
    #[doc = ""]
    #[doc = " @ifindex - the ifindex of the interface"]
    #[doc = " @root - the name of root class (e.g., \"root\");"]
    #[doc = " @type - the type of qdisc (e.g., \"fq\")"]
    pub fn lkl_qdisc_add(
        ifindex: ::std::os::raw::c_int,
        root: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_qdisc_parse_add - Add a qdisc entry for an interface with strings"]
    #[doc = ""]
    #[doc = " @ifindex - the ifindex of the interface"]
    #[doc = " @entries - strings of qdisc configurations in the form of"]
    #[doc = "            \"root|type;root|type;...\""]
    pub fn lkl_qdisc_parse_add(
        ifindex: ::std::os::raw::c_int,
        entries: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " lkl_sysctl - write a sysctl value"]
    #[doc = ""]
    #[doc = " @path - the path to an sysctl entry (e.g., \"net.ipv4.tcp_wmem\");"]
    #[doc = " @value - the value of the sysctl (e.g., \"4096 87380 2147483647\")"]
    pub fn lkl_sysctl(
        path: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " lkl_sysctl_parse_write - Configure sysctl parameters with strings"]
    #[doc = ""]
    #[doc = " @sysctls - Configure sysctl parameters as the form of \"key=value;...\""]
    pub fn lkl_sysctl_parse_write(sysctls: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut lkl_host_ops: lkl_host_operations;
}
extern "C" {
    pub static mut lkl_virtio_devs: [::std::os::raw::c_char; 4096usize];
}
extern "C" {
    pub fn readv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn writev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
#[doc = " struct lkl_dev_blk_ops - block device host operations, defined in lkl_host.h."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_dev_blk_ops {
    #[doc = " @get_capacity: returns the disk capacity in bytes"]
    #[doc = ""]
    #[doc = " @disk - the disk for which the capacity is requested;"]
    #[doc = " @res - pointer to receive the capacity, in bytes;"]
    #[doc = " @returns - 0 in case of success, negative value in case of error"]
    pub get_capacity: ::std::option::Option<
        unsafe extern "C" fn(
            disk: lkl_disk,
            res: *mut ::std::os::raw::c_ulonglong,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @request: issue a block request"]
    #[doc = ""]
    #[doc = " @disk - the disk the request is issued to;"]
    #[doc = " @req - a request described by &struct lkl_blk_req"]
    pub request: ::std::option::Option<
        unsafe extern "C" fn(disk: lkl_disk, req: *mut lkl_blk_req) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_lkl_dev_blk_ops() {
    assert_eq!(
        ::std::mem::size_of::<lkl_dev_blk_ops>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_dev_blk_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_dev_blk_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_dev_blk_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_blk_ops>())).get_capacity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_blk_ops),
            "::",
            stringify!(get_capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_blk_ops>())).request as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_blk_ops),
            "::",
            stringify!(request)
        )
    );
}
extern "C" {
    pub static mut lkl_dev_blk_ops: lkl_dev_blk_ops;
}
#[doc = " struct lkl_blk_req - block device request"]
#[doc = ""]
#[doc = " @type: type of request"]
#[doc = " @prio: priority of request - currently unused"]
#[doc = " @sector: offset in units 512 bytes for read / write requests"]
#[doc = " @buf: an array of buffers to be used for read / write requests"]
#[doc = " @count: the number of buffers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_blk_req {
    pub type_: ::std::os::raw::c_uint,
    pub prio: ::std::os::raw::c_uint,
    pub sector: ::std::os::raw::c_ulonglong,
    pub buf: *mut iovec,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lkl_blk_req() {
    assert_eq!(
        ::std::mem::size_of::<lkl_blk_req>(),
        32usize,
        concat!("Size of: ", stringify!(lkl_blk_req))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_blk_req>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_blk_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_blk_req>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_blk_req),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_blk_req>())).prio as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_blk_req),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_blk_req>())).sector as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_blk_req),
            "::",
            stringify!(sector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_blk_req>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_blk_req),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_blk_req>())).count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_blk_req),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " lkl_netdev - host network device handle, defined in lkl_host.h."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_netdev {
    pub ops: *mut lkl_dev_net_ops,
    pub id: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_lkl_netdev() {
    assert_eq!(
        ::std::mem::size_of::<lkl_netdev>(),
        16usize,
        concat!("Size of: ", stringify!(lkl_netdev))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_netdev>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_netdev))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_netdev>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_netdev),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_netdev>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_netdev),
            "::",
            stringify!(id)
        )
    );
}
impl lkl_netdev {
    #[inline]
    pub fn has_vnet_hdr(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_has_vnet_hdr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_vnet_hdr: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_vnet_hdr: u8 = unsafe { ::std::mem::transmute(has_vnet_hdr) };
            has_vnet_hdr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " struct lkl_dev_net_ops - network device host operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lkl_dev_net_ops {
    #[doc = " @tx: writes a L2 packet into the net device"]
    #[doc = ""]
    #[doc = " The data buffer can only hold 0 or 1 complete packets."]
    #[doc = ""]
    #[doc = " @nd - pointer to the network device;"]
    #[doc = " @iov - pointer to the buffer vector;"]
    #[doc = " @cnt - # of vectors in iov."]
    #[doc = ""]
    #[doc = " @returns number of bytes transmitted"]
    pub tx: ::std::option::Option<
        unsafe extern "C" fn(
            nd: *mut lkl_netdev,
            iov: *mut iovec,
            cnt: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @rx: reads a packet from the net device."]
    #[doc = ""]
    #[doc = " It must only read one complete packet if present."]
    #[doc = ""]
    #[doc = " If the buffer is too small for the packet, the implementation may"]
    #[doc = " decide to drop it or trim it."]
    #[doc = ""]
    #[doc = " @nd - pointer to the network device"]
    #[doc = " @iov - pointer to the buffer vector to store the packet"]
    #[doc = " @cnt - # of vectors in iov."]
    #[doc = ""]
    #[doc = " @returns number of bytes read for success or < 0 if error"]
    pub rx: ::std::option::Option<
        unsafe extern "C" fn(
            nd: *mut lkl_netdev,
            iov: *mut iovec,
            cnt: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @poll: polls a net device"]
    #[doc = ""]
    #[doc = " Supports the following events: LKL_DEV_NET_POLL_RX"]
    #[doc = " (readable), LKL_DEV_NET_POLL_TX (writable) or"]
    #[doc = " LKL_DEV_NET_POLL_HUP (the close operations has been issued"]
    #[doc = " and we need to clean up). Blocks until one event is"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " @nd - pointer to the network device"]
    #[doc = ""]
    #[doc = " @returns - LKL_DEV_NET_POLL_RX, LKL_DEV_NET_POLL_TX,"]
    #[doc = " LKL_DEV_NET_POLL_HUP or a negative value for errors"]
    pub poll:
        ::std::option::Option<unsafe extern "C" fn(nd: *mut lkl_netdev) -> ::std::os::raw::c_int>,
    #[doc = " @poll_hup: make poll wakeup and return LKL_DEV_NET_POLL_HUP"]
    #[doc = ""]
    #[doc = " @nd - pointer to the network device"]
    pub poll_hup: ::std::option::Option<unsafe extern "C" fn(nd: *mut lkl_netdev)>,
    #[doc = " @free: frees a network device"]
    #[doc = ""]
    #[doc = " Implementation must release its resources and free the network device"]
    #[doc = " structure."]
    #[doc = ""]
    #[doc = " @nd - pointer to the network device"]
    pub free: ::std::option::Option<unsafe extern "C" fn(nd: *mut lkl_netdev)>,
}
#[test]
fn bindgen_test_layout_lkl_dev_net_ops() {
    assert_eq!(
        ::std::mem::size_of::<lkl_dev_net_ops>(),
        40usize,
        concat!("Size of: ", stringify!(lkl_dev_net_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<lkl_dev_net_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(lkl_dev_net_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_net_ops>())).tx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_net_ops),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_net_ops>())).rx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_net_ops),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_net_ops>())).poll as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_net_ops),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_net_ops>())).poll_hup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_net_ops),
            "::",
            stringify!(poll_hup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lkl_dev_net_ops>())).free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lkl_dev_net_ops),
            "::",
            stringify!(free)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem_undo {
    pub _address: u8,
}
