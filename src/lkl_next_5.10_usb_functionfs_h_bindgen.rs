/* automatically generated by rust-bindgen 0.57.0 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __BITS_PER_LONG: u32 = 32;
pub const __FD_SETSIZE: u32 = 1024;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const USB_DIR_OUT: u32 = 0;
pub const USB_DIR_IN: u32 = 128;
pub const USB_TYPE_MASK: u32 = 96;
pub const USB_TYPE_STANDARD: u32 = 0;
pub const USB_TYPE_CLASS: u32 = 32;
pub const USB_TYPE_VENDOR: u32 = 64;
pub const USB_TYPE_RESERVED: u32 = 96;
pub const USB_RECIP_MASK: u32 = 31;
pub const USB_RECIP_DEVICE: u32 = 0;
pub const USB_RECIP_INTERFACE: u32 = 1;
pub const USB_RECIP_ENDPOINT: u32 = 2;
pub const USB_RECIP_OTHER: u32 = 3;
pub const USB_RECIP_PORT: u32 = 4;
pub const USB_RECIP_RPIPE: u32 = 5;
pub const USB_REQ_GET_STATUS: u32 = 0;
pub const USB_REQ_CLEAR_FEATURE: u32 = 1;
pub const USB_REQ_SET_FEATURE: u32 = 3;
pub const USB_REQ_SET_ADDRESS: u32 = 5;
pub const USB_REQ_GET_DESCRIPTOR: u32 = 6;
pub const USB_REQ_SET_DESCRIPTOR: u32 = 7;
pub const USB_REQ_GET_CONFIGURATION: u32 = 8;
pub const USB_REQ_SET_CONFIGURATION: u32 = 9;
pub const USB_REQ_GET_INTERFACE: u32 = 10;
pub const USB_REQ_SET_INTERFACE: u32 = 11;
pub const USB_REQ_SYNCH_FRAME: u32 = 12;
pub const USB_REQ_SET_SEL: u32 = 48;
pub const USB_REQ_SET_ISOCH_DELAY: u32 = 49;
pub const USB_REQ_SET_ENCRYPTION: u32 = 13;
pub const USB_REQ_GET_ENCRYPTION: u32 = 14;
pub const USB_REQ_RPIPE_ABORT: u32 = 14;
pub const USB_REQ_SET_HANDSHAKE: u32 = 15;
pub const USB_REQ_RPIPE_RESET: u32 = 15;
pub const USB_REQ_GET_HANDSHAKE: u32 = 16;
pub const USB_REQ_SET_CONNECTION: u32 = 17;
pub const USB_REQ_SET_SECURITY_DATA: u32 = 18;
pub const USB_REQ_GET_SECURITY_DATA: u32 = 19;
pub const USB_REQ_SET_WUSB_DATA: u32 = 20;
pub const USB_REQ_LOOPBACK_DATA_WRITE: u32 = 21;
pub const USB_REQ_LOOPBACK_DATA_READ: u32 = 22;
pub const USB_REQ_SET_INTERFACE_DS: u32 = 23;
pub const USB_REQ_GET_PARTNER_PDO: u32 = 20;
pub const USB_REQ_GET_BATTERY_STATUS: u32 = 21;
pub const USB_REQ_SET_PDO: u32 = 22;
pub const USB_REQ_GET_VDM: u32 = 23;
pub const USB_REQ_SEND_VDM: u32 = 24;
pub const USB_DEVICE_SELF_POWERED: u32 = 0;
pub const USB_DEVICE_REMOTE_WAKEUP: u32 = 1;
pub const USB_DEVICE_TEST_MODE: u32 = 2;
pub const USB_DEVICE_BATTERY: u32 = 2;
pub const USB_DEVICE_B_HNP_ENABLE: u32 = 3;
pub const USB_DEVICE_WUSB_DEVICE: u32 = 3;
pub const USB_DEVICE_A_HNP_SUPPORT: u32 = 4;
pub const USB_DEVICE_A_ALT_HNP_SUPPORT: u32 = 5;
pub const USB_DEVICE_DEBUG_MODE: u32 = 6;
pub const USB_TEST_J: u32 = 1;
pub const USB_TEST_K: u32 = 2;
pub const USB_TEST_SE0_NAK: u32 = 3;
pub const USB_TEST_PACKET: u32 = 4;
pub const USB_TEST_FORCE_ENABLE: u32 = 5;
pub const USB_STATUS_TYPE_STANDARD: u32 = 0;
pub const USB_STATUS_TYPE_PTM: u32 = 1;
pub const USB_DEVICE_U1_ENABLE: u32 = 48;
pub const USB_DEVICE_U2_ENABLE: u32 = 49;
pub const USB_DEVICE_LTM_ENABLE: u32 = 50;
pub const USB_INTRF_FUNC_SUSPEND: u32 = 0;
pub const USB_INTR_FUNC_SUSPEND_OPT_MASK: u32 = 65280;
pub const USB_INTRF_FUNC_SUSPEND_LP: u32 = 256;
pub const USB_INTRF_FUNC_SUSPEND_RW: u32 = 512;
pub const USB_INTRF_STAT_FUNC_RW_CAP: u32 = 1;
pub const USB_INTRF_STAT_FUNC_RW: u32 = 2;
pub const USB_ENDPOINT_HALT: u32 = 0;
pub const USB_DEV_STAT_U1_ENABLED: u32 = 2;
pub const USB_DEV_STAT_U2_ENABLED: u32 = 3;
pub const USB_DEV_STAT_LTM_ENABLED: u32 = 4;
pub const USB_DEVICE_BATTERY_WAKE_MASK: u32 = 40;
pub const USB_DEVICE_OS_IS_PD_AWARE: u32 = 41;
pub const USB_DEVICE_POLICY_MODE: u32 = 42;
pub const USB_PORT_PR_SWAP: u32 = 43;
pub const USB_PORT_GOTO_MIN: u32 = 44;
pub const USB_PORT_RETURN_POWER: u32 = 45;
pub const USB_PORT_ACCEPT_PD_REQUEST: u32 = 46;
pub const USB_PORT_REJECT_PD_REQUEST: u32 = 47;
pub const USB_PORT_PORT_PD_RESET: u32 = 48;
pub const USB_PORT_C_PORT_PD_CHANGE: u32 = 49;
pub const USB_PORT_CABLE_PD_RESET: u32 = 50;
pub const USB_DEVICE_CHARGING_POLICY: u32 = 54;
pub const USB_DT_DEVICE: u32 = 1;
pub const USB_DT_CONFIG: u32 = 2;
pub const USB_DT_STRING: u32 = 3;
pub const USB_DT_INTERFACE: u32 = 4;
pub const USB_DT_ENDPOINT: u32 = 5;
pub const USB_DT_DEVICE_QUALIFIER: u32 = 6;
pub const USB_DT_OTHER_SPEED_CONFIG: u32 = 7;
pub const USB_DT_INTERFACE_POWER: u32 = 8;
pub const USB_DT_OTG: u32 = 9;
pub const USB_DT_DEBUG: u32 = 10;
pub const USB_DT_INTERFACE_ASSOCIATION: u32 = 11;
pub const USB_DT_SECURITY: u32 = 12;
pub const USB_DT_KEY: u32 = 13;
pub const USB_DT_ENCRYPTION_TYPE: u32 = 14;
pub const USB_DT_BOS: u32 = 15;
pub const USB_DT_DEVICE_CAPABILITY: u32 = 16;
pub const USB_DT_WIRELESS_ENDPOINT_COMP: u32 = 17;
pub const USB_DT_WIRE_ADAPTER: u32 = 33;
pub const USB_DT_RPIPE: u32 = 34;
pub const USB_DT_CS_RADIO_CONTROL: u32 = 35;
pub const USB_DT_PIPE_USAGE: u32 = 36;
pub const USB_DT_SS_ENDPOINT_COMP: u32 = 48;
pub const USB_DT_SSP_ISOC_ENDPOINT_COMP: u32 = 49;
pub const USB_DT_CS_DEVICE: u32 = 33;
pub const USB_DT_CS_CONFIG: u32 = 34;
pub const USB_DT_CS_STRING: u32 = 35;
pub const USB_DT_CS_INTERFACE: u32 = 36;
pub const USB_DT_CS_ENDPOINT: u32 = 37;
pub const USB_DT_DEVICE_SIZE: u32 = 18;
pub const USB_CLASS_PER_INTERFACE: u32 = 0;
pub const USB_CLASS_AUDIO: u32 = 1;
pub const USB_CLASS_COMM: u32 = 2;
pub const USB_CLASS_HID: u32 = 3;
pub const USB_CLASS_PHYSICAL: u32 = 5;
pub const USB_CLASS_STILL_IMAGE: u32 = 6;
pub const USB_CLASS_PRINTER: u32 = 7;
pub const USB_CLASS_MASS_STORAGE: u32 = 8;
pub const USB_CLASS_HUB: u32 = 9;
pub const USB_CLASS_CDC_DATA: u32 = 10;
pub const USB_CLASS_CSCID: u32 = 11;
pub const USB_CLASS_CONTENT_SEC: u32 = 13;
pub const USB_CLASS_VIDEO: u32 = 14;
pub const USB_CLASS_WIRELESS_CONTROLLER: u32 = 224;
pub const USB_CLASS_PERSONAL_HEALTHCARE: u32 = 15;
pub const USB_CLASS_AUDIO_VIDEO: u32 = 16;
pub const USB_CLASS_BILLBOARD: u32 = 17;
pub const USB_CLASS_USB_TYPE_C_BRIDGE: u32 = 18;
pub const USB_CLASS_MISC: u32 = 239;
pub const USB_CLASS_APP_SPEC: u32 = 254;
pub const USB_CLASS_VENDOR_SPEC: u32 = 255;
pub const USB_SUBCLASS_VENDOR_SPEC: u32 = 255;
pub const USB_DT_CONFIG_SIZE: u32 = 9;
pub const USB_CONFIG_ATT_ONE: u32 = 128;
pub const USB_CONFIG_ATT_SELFPOWER: u32 = 64;
pub const USB_CONFIG_ATT_WAKEUP: u32 = 32;
pub const USB_CONFIG_ATT_BATTERY: u32 = 16;
pub const USB_MAX_STRING_LEN: u32 = 126;
pub const USB_DT_INTERFACE_SIZE: u32 = 9;
pub const USB_DT_ENDPOINT_SIZE: u32 = 7;
pub const USB_DT_ENDPOINT_AUDIO_SIZE: u32 = 9;
pub const USB_ENDPOINT_NUMBER_MASK: u32 = 15;
pub const USB_ENDPOINT_DIR_MASK: u32 = 128;
pub const USB_ENDPOINT_XFERTYPE_MASK: u32 = 3;
pub const USB_ENDPOINT_XFER_CONTROL: u32 = 0;
pub const USB_ENDPOINT_XFER_ISOC: u32 = 1;
pub const USB_ENDPOINT_XFER_BULK: u32 = 2;
pub const USB_ENDPOINT_XFER_INT: u32 = 3;
pub const USB_ENDPOINT_MAX_ADJUSTABLE: u32 = 128;
pub const USB_ENDPOINT_MAXP_MASK: u32 = 2047;
pub const USB_EP_MAXP_MULT_SHIFT: u32 = 11;
pub const USB_EP_MAXP_MULT_MASK: u32 = 6144;
pub const USB_ENDPOINT_INTRTYPE: u32 = 48;
pub const USB_ENDPOINT_INTR_PERIODIC: u32 = 0;
pub const USB_ENDPOINT_INTR_NOTIFICATION: u32 = 16;
pub const USB_ENDPOINT_SYNCTYPE: u32 = 12;
pub const USB_ENDPOINT_SYNC_NONE: u32 = 0;
pub const USB_ENDPOINT_SYNC_ASYNC: u32 = 4;
pub const USB_ENDPOINT_SYNC_ADAPTIVE: u32 = 8;
pub const USB_ENDPOINT_SYNC_SYNC: u32 = 12;
pub const USB_ENDPOINT_USAGE_MASK: u32 = 48;
pub const USB_ENDPOINT_USAGE_DATA: u32 = 0;
pub const USB_ENDPOINT_USAGE_FEEDBACK: u32 = 16;
pub const USB_ENDPOINT_USAGE_IMPLICIT_FB: u32 = 32;
pub const USB_DT_SSP_ISOC_EP_COMP_SIZE: u32 = 8;
pub const USB_DT_SS_EP_COMP_SIZE: u32 = 6;
pub const USB_OTG_SRP: u32 = 1;
pub const USB_OTG_HNP: u32 = 2;
pub const USB_OTG_ADP: u32 = 4;
pub const OTG_STS_SELECTOR: u32 = 61440;
pub const USB_DT_INTERFACE_ASSOCIATION_SIZE: u32 = 8;
pub const USB_ENC_TYPE_UNSECURE: u32 = 0;
pub const USB_ENC_TYPE_WIRED: u32 = 1;
pub const USB_ENC_TYPE_CCM_1: u32 = 2;
pub const USB_ENC_TYPE_RSA_1: u32 = 3;
pub const USB_DT_BOS_SIZE: u32 = 5;
pub const USB_CAP_TYPE_WIRELESS_USB: u32 = 1;
pub const USB_WIRELESS_P2P_DRD: u32 = 2;
pub const USB_WIRELESS_BEACON_MASK: u32 = 12;
pub const USB_WIRELESS_BEACON_SELF: u32 = 4;
pub const USB_WIRELESS_BEACON_DIRECTED: u32 = 8;
pub const USB_WIRELESS_BEACON_NONE: u32 = 12;
pub const USB_WIRELESS_PHY_53: u32 = 1;
pub const USB_WIRELESS_PHY_80: u32 = 2;
pub const USB_WIRELESS_PHY_107: u32 = 4;
pub const USB_WIRELESS_PHY_160: u32 = 8;
pub const USB_WIRELESS_PHY_200: u32 = 16;
pub const USB_WIRELESS_PHY_320: u32 = 32;
pub const USB_WIRELESS_PHY_400: u32 = 64;
pub const USB_WIRELESS_PHY_480: u32 = 128;
pub const USB_DT_USB_WIRELESS_CAP_SIZE: u32 = 11;
pub const USB_CAP_TYPE_EXT: u32 = 2;
pub const USB_LPM_SUPPORT: u32 = 2;
pub const USB_BESL_SUPPORT: u32 = 4;
pub const USB_BESL_BASELINE_VALID: u32 = 8;
pub const USB_BESL_DEEP_VALID: u32 = 16;
pub const USB_DT_USB_EXT_CAP_SIZE: u32 = 7;
pub const USB_SS_CAP_TYPE: u32 = 3;
pub const USB_LTM_SUPPORT: u32 = 2;
pub const USB_LOW_SPEED_OPERATION: u32 = 1;
pub const USB_FULL_SPEED_OPERATION: u32 = 2;
pub const USB_HIGH_SPEED_OPERATION: u32 = 4;
pub const USB_5GBPS_OPERATION: u32 = 8;
pub const USB_DT_USB_SS_CAP_SIZE: u32 = 10;
pub const CONTAINER_ID_TYPE: u32 = 4;
pub const USB_DT_USB_SS_CONTN_ID_SIZE: u32 = 20;
pub const USB_SSP_CAP_TYPE: u32 = 10;
pub const USB_SSP_SUBLINK_SPEED_ATTRIBS: u32 = 31;
pub const USB_SSP_SUBLINK_SPEED_IDS: u32 = 480;
pub const USB_SSP_MIN_SUBLINK_SPEED_ATTRIBUTE_ID: u32 = 15;
pub const USB_SSP_MIN_RX_LANE_COUNT: u32 = 3840;
pub const USB_SSP_MIN_TX_LANE_COUNT: u32 = 61440;
pub const USB_SSP_SUBLINK_SPEED_SSID: u32 = 15;
pub const USB_SSP_SUBLINK_SPEED_LSE: u32 = 48;
pub const USB_SSP_SUBLINK_SPEED_ST: u32 = 192;
pub const USB_SSP_SUBLINK_SPEED_RSVD: u32 = 16128;
pub const USB_SSP_SUBLINK_SPEED_LP: u32 = 49152;
pub const USB_SSP_SUBLINK_SPEED_LSM: u32 = 16711680;
pub const USB_PD_POWER_DELIVERY_CAPABILITY: u32 = 6;
pub const USB_PD_BATTERY_INFO_CAPABILITY: u32 = 7;
pub const USB_PD_PD_CONSUMER_PORT_CAPABILITY: u32 = 8;
pub const USB_PD_PD_PROVIDER_PORT_CAPABILITY: u32 = 9;
pub const USB_PD_CAP_BATTERY_CHARGING: u32 = 2;
pub const USB_PD_CAP_USB_PD: u32 = 4;
pub const USB_PD_CAP_PROVIDER: u32 = 8;
pub const USB_PD_CAP_CONSUMER: u32 = 16;
pub const USB_PD_CAP_CHARGING_POLICY: u32 = 32;
pub const USB_PD_CAP_TYPE_C_CURRENT: u32 = 64;
pub const USB_PD_CAP_PWR_AC: u32 = 256;
pub const USB_PD_CAP_PWR_BAT: u32 = 512;
pub const USB_PD_CAP_PWR_USE_V_BUS: u32 = 16384;
pub const USB_PD_CAP_CONSUMER_BC: u32 = 1;
pub const USB_PD_CAP_CONSUMER_PD: u32 = 2;
pub const USB_PD_CAP_CONSUMER_TYPE_C: u32 = 4;
pub const USB_PD_CAP_CONSUMER_UNKNOWN_PEAK_POWER_TIME: u32 = 65535;
pub const USB_PD_CAP_PROVIDER_BC: u32 = 1;
pub const USB_PD_CAP_PROVIDER_PD: u32 = 2;
pub const USB_PD_CAP_PROVIDER_TYPE_C: u32 = 4;
pub const USB_PTM_CAP_TYPE: u32 = 11;
pub const USB_DT_USB_PTM_ID_SIZE: u32 = 3;
pub const USB_ENDPOINT_SWITCH_MASK: u32 = 3;
pub const USB_ENDPOINT_SWITCH_NO: u32 = 0;
pub const USB_ENDPOINT_SWITCH_SWITCH: u32 = 1;
pub const USB_ENDPOINT_SWITCH_SCALE: u32 = 2;
pub const USB3_LPM_DISABLED: u32 = 0;
pub const USB3_LPM_U1_MAX_TIMEOUT: u32 = 127;
pub const USB3_LPM_U2_MAX_TIMEOUT: u32 = 254;
pub const USB3_LPM_DEVICE_INITIATED: u32 = 255;
pub const USB3_LPM_MAX_U1_SEL_PEL: u32 = 255;
pub const USB3_LPM_MAX_U2_SEL_PEL: u32 = 65535;
pub const USB_SELF_POWER_VBUS_MAX_DRAW: u32 = 100;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_old_uid_t = __kernel_uid_t;
pub type __kernel_old_gid_t = __kernel_gid_t;
pub type __kernel_old_dev_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = ::std::os::raw::c_uint;
pub type __kernel_ssize_t = ::std::os::raw::c_int;
pub type __kernel_ptrdiff_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[doc = " struct usb_ctrlrequest - SETUP data for a USB device control request"]
#[doc = " @bRequestType: matches the USB bmRequestType field"]
#[doc = " @bRequest: matches the USB bRequest field"]
#[doc = " @wValue: matches the USB wValue field (le16 byte order)"]
#[doc = " @wIndex: matches the USB wIndex field (le16 byte order)"]
#[doc = " @wLength: matches the USB wLength field (le16 byte order)"]
#[doc = ""]
#[doc = " This structure is used to send control requests to a USB device.  It matches"]
#[doc = " the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the"]
#[doc = " USB spec for a fuller description of the different fields, and what they are"]
#[doc = " used for."]
#[doc = ""]
#[doc = " Note that the driver for any interface can issue control requests."]
#[doc = " For most devices, interfaces don't coordinate with each other, so"]
#[doc = " such requests may be made at any time."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ctrlrequest {
    pub bRequestType: __u8,
    pub bRequest: __u8,
    pub wValue: __le16,
    pub wIndex: __le16,
    pub wLength: __le16,
}
#[test]
fn bindgen_test_layout_usb_ctrlrequest() {
    assert_eq!(
        ::std::mem::size_of::<usb_ctrlrequest>(),
        8usize,
        concat!("Size of: ", stringify!(usb_ctrlrequest))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ctrlrequest>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ctrlrequest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ctrlrequest>())).bRequestType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ctrlrequest),
            "::",
            stringify!(bRequestType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ctrlrequest>())).bRequest as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ctrlrequest),
            "::",
            stringify!(bRequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ctrlrequest>())).wValue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ctrlrequest),
            "::",
            stringify!(wValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ctrlrequest>())).wIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ctrlrequest),
            "::",
            stringify!(wIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ctrlrequest>())).wLength as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ctrlrequest),
            "::",
            stringify!(wLength)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_descriptor_header {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
}
#[test]
fn bindgen_test_layout_usb_descriptor_header() {
    assert_eq!(
        ::std::mem::size_of::<usb_descriptor_header>(),
        2usize,
        concat!("Size of: ", stringify!(usb_descriptor_header))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_descriptor_header>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_descriptor_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_descriptor_header>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_descriptor_header),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_descriptor_header>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_descriptor_header),
            "::",
            stringify!(bDescriptorType)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_device_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bcdUSB: __le16,
    pub bDeviceClass: __u8,
    pub bDeviceSubClass: __u8,
    pub bDeviceProtocol: __u8,
    pub bMaxPacketSize0: __u8,
    pub idVendor: __le16,
    pub idProduct: __le16,
    pub bcdDevice: __le16,
    pub iManufacturer: __u8,
    pub iProduct: __u8,
    pub iSerialNumber: __u8,
    pub bNumConfigurations: __u8,
}
#[test]
fn bindgen_test_layout_usb_device_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_device_descriptor>(),
        18usize,
        concat!("Size of: ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_device_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_device_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_device_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_device_descriptor>())).bcdUSB as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdUSB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_device_descriptor>())).bDeviceClass as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_device_descriptor>())).bDeviceSubClass as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_device_descriptor>())).bDeviceProtocol as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_device_descriptor>())).bMaxPacketSize0 as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bMaxPacketSize0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_device_descriptor>())).idVendor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_device_descriptor>())).idProduct as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_device_descriptor>())).bcdDevice as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_device_descriptor>())).iManufacturer as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iManufacturer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_device_descriptor>())).iProduct as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iProduct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_device_descriptor>())).iSerialNumber as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iSerialNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_device_descriptor>())).bNumConfigurations as *const _
                as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bNumConfigurations)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_config_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub wTotalLength: __le16,
    pub bNumInterfaces: __u8,
    pub bConfigurationValue: __u8,
    pub iConfiguration: __u8,
    pub bmAttributes: __u8,
    pub bMaxPower: __u8,
}
#[test]
fn bindgen_test_layout_usb_config_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_config_descriptor>(),
        9usize,
        concat!("Size of: ", stringify!(usb_config_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_config_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_config_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_config_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_config_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_config_descriptor>())).wTotalLength as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(wTotalLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_config_descriptor>())).bNumInterfaces as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bNumInterfaces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_config_descriptor>())).bConfigurationValue as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bConfigurationValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_config_descriptor>())).iConfiguration as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(iConfiguration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_config_descriptor>())).bmAttributes as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_config_descriptor>())).bMaxPower as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bMaxPower)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_string_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub wData: [__le16; 1usize],
}
#[test]
fn bindgen_test_layout_usb_string_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_string_descriptor>(),
        4usize,
        concat!("Size of: ", stringify!(usb_string_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_string_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_string_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_string_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_string_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_string_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_string_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_string_descriptor>())).wData as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_string_descriptor),
            "::",
            stringify!(wData)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_interface_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bInterfaceNumber: __u8,
    pub bAlternateSetting: __u8,
    pub bNumEndpoints: __u8,
    pub bInterfaceClass: __u8,
    pub bInterfaceSubClass: __u8,
    pub bInterfaceProtocol: __u8,
    pub iInterface: __u8,
}
#[test]
fn bindgen_test_layout_usb_interface_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_interface_descriptor>(),
        9usize,
        concat!("Size of: ", stringify!(usb_interface_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_interface_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_interface_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_descriptor>())).bInterfaceNumber as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_descriptor>())).bAlternateSetting as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bAlternateSetting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_descriptor>())).bNumEndpoints as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bNumEndpoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_descriptor>())).bInterfaceClass as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_descriptor>())).bInterfaceSubClass as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_descriptor>())).bInterfaceProtocol as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_descriptor>())).iInterface as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(iInterface)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_endpoint_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bEndpointAddress: __u8,
    pub bmAttributes: __u8,
    pub wMaxPacketSize: __le16,
    pub bInterval: __u8,
    pub bRefresh: __u8,
    pub bSynchAddress: __u8,
}
#[test]
fn bindgen_test_layout_usb_endpoint_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_endpoint_descriptor>(),
        9usize,
        concat!("Size of: ", stringify!(usb_endpoint_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_endpoint_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_endpoint_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_endpoint_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor>())).bEndpointAddress as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bEndpointAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor>())).bmAttributes as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor>())).wMaxPacketSize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(wMaxPacketSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor>())).bInterval as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor>())).bRefresh as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bRefresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor>())).bSynchAddress as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bSynchAddress)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ssp_isoc_ep_comp_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub wReseved: __le16,
    pub dwBytesPerInterval: __le32,
}
#[test]
fn bindgen_test_layout_usb_ssp_isoc_ep_comp_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_ssp_isoc_ep_comp_descriptor>(),
        8usize,
        concat!("Size of: ", stringify!(usb_ssp_isoc_ep_comp_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ssp_isoc_ep_comp_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ssp_isoc_ep_comp_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ssp_isoc_ep_comp_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_isoc_ep_comp_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ssp_isoc_ep_comp_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_isoc_ep_comp_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ssp_isoc_ep_comp_descriptor>())).wReseved as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_isoc_ep_comp_descriptor),
            "::",
            stringify!(wReseved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ssp_isoc_ep_comp_descriptor>())).dwBytesPerInterval
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_isoc_ep_comp_descriptor),
            "::",
            stringify!(dwBytesPerInterval)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ss_ep_comp_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bMaxBurst: __u8,
    pub bmAttributes: __u8,
    pub wBytesPerInterval: __le16,
}
#[test]
fn bindgen_test_layout_usb_ss_ep_comp_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_ss_ep_comp_descriptor>(),
        6usize,
        concat!("Size of: ", stringify!(usb_ss_ep_comp_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ss_ep_comp_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ss_ep_comp_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_ep_comp_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_ep_comp_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_ep_comp_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_ep_comp_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_ep_comp_descriptor>())).bMaxBurst as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_ep_comp_descriptor),
            "::",
            stringify!(bMaxBurst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_ep_comp_descriptor>())).bmAttributes as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_ep_comp_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_ep_comp_descriptor>())).wBytesPerInterval as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_ep_comp_descriptor),
            "::",
            stringify!(wBytesPerInterval)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_qualifier_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bcdUSB: __le16,
    pub bDeviceClass: __u8,
    pub bDeviceSubClass: __u8,
    pub bDeviceProtocol: __u8,
    pub bMaxPacketSize0: __u8,
    pub bNumConfigurations: __u8,
    pub bRESERVED: __u8,
}
#[test]
fn bindgen_test_layout_usb_qualifier_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_qualifier_descriptor>(),
        10usize,
        concat!("Size of: ", stringify!(usb_qualifier_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_qualifier_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_qualifier_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_qualifier_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_qualifier_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_qualifier_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_qualifier_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_qualifier_descriptor>())).bcdUSB as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_qualifier_descriptor),
            "::",
            stringify!(bcdUSB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_qualifier_descriptor>())).bDeviceClass as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_qualifier_descriptor),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_qualifier_descriptor>())).bDeviceSubClass as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_qualifier_descriptor),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_qualifier_descriptor>())).bDeviceProtocol as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_qualifier_descriptor),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_qualifier_descriptor>())).bMaxPacketSize0 as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_qualifier_descriptor),
            "::",
            stringify!(bMaxPacketSize0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_qualifier_descriptor>())).bNumConfigurations as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_qualifier_descriptor),
            "::",
            stringify!(bNumConfigurations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_qualifier_descriptor>())).bRESERVED as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_qualifier_descriptor),
            "::",
            stringify!(bRESERVED)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_otg_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bmAttributes: __u8,
}
#[test]
fn bindgen_test_layout_usb_otg_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_otg_descriptor>(),
        3usize,
        concat!("Size of: ", stringify!(usb_otg_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_otg_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_otg_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_otg_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_otg_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_otg_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_otg_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_otg_descriptor>())).bmAttributes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_otg_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_otg20_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bmAttributes: __u8,
    pub bcdOTG: __le16,
}
#[test]
fn bindgen_test_layout_usb_otg20_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_otg20_descriptor>(),
        5usize,
        concat!("Size of: ", stringify!(usb_otg20_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_otg20_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_otg20_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_otg20_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_otg20_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_otg20_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_otg20_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_otg20_descriptor>())).bmAttributes as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_otg20_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_otg20_descriptor>())).bcdOTG as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_otg20_descriptor),
            "::",
            stringify!(bcdOTG)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_debug_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDebugInEndpoint: __u8,
    pub bDebugOutEndpoint: __u8,
}
#[test]
fn bindgen_test_layout_usb_debug_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_debug_descriptor>(),
        4usize,
        concat!("Size of: ", stringify!(usb_debug_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_debug_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_debug_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_debug_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_debug_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_debug_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_debug_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_debug_descriptor>())).bDebugInEndpoint as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_debug_descriptor),
            "::",
            stringify!(bDebugInEndpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_debug_descriptor>())).bDebugOutEndpoint as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_debug_descriptor),
            "::",
            stringify!(bDebugOutEndpoint)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_interface_assoc_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bFirstInterface: __u8,
    pub bInterfaceCount: __u8,
    pub bFunctionClass: __u8,
    pub bFunctionSubClass: __u8,
    pub bFunctionProtocol: __u8,
    pub iFunction: __u8,
}
#[test]
fn bindgen_test_layout_usb_interface_assoc_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_interface_assoc_descriptor>(),
        8usize,
        concat!("Size of: ", stringify!(usb_interface_assoc_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_interface_assoc_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_interface_assoc_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_assoc_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_assoc_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_assoc_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_assoc_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_assoc_descriptor>())).bFirstInterface as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_assoc_descriptor),
            "::",
            stringify!(bFirstInterface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_assoc_descriptor>())).bInterfaceCount as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_assoc_descriptor),
            "::",
            stringify!(bInterfaceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_assoc_descriptor>())).bFunctionClass as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_assoc_descriptor),
            "::",
            stringify!(bFunctionClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_assoc_descriptor>())).bFunctionSubClass as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_assoc_descriptor),
            "::",
            stringify!(bFunctionSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_assoc_descriptor>())).bFunctionProtocol as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_assoc_descriptor),
            "::",
            stringify!(bFunctionProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_interface_assoc_descriptor>())).iFunction as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_assoc_descriptor),
            "::",
            stringify!(iFunction)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_security_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub wTotalLength: __le16,
    pub bNumEncryptionTypes: __u8,
}
#[test]
fn bindgen_test_layout_usb_security_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_security_descriptor>(),
        5usize,
        concat!("Size of: ", stringify!(usb_security_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_security_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_security_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_security_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_security_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_security_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_security_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_security_descriptor>())).wTotalLength as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_security_descriptor),
            "::",
            stringify!(wTotalLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_security_descriptor>())).bNumEncryptionTypes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_security_descriptor),
            "::",
            stringify!(bNumEncryptionTypes)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug)]
pub struct usb_key_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub tTKID: [__u8; 3usize],
    pub bReserved: __u8,
    pub bKeyData: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_usb_key_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_key_descriptor>(),
        6usize,
        concat!("Size of: ", stringify!(usb_key_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_key_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_key_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_key_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_key_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_key_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_key_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_key_descriptor>())).tTKID as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_key_descriptor),
            "::",
            stringify!(tTKID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_key_descriptor>())).bReserved as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_key_descriptor),
            "::",
            stringify!(bReserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_key_descriptor>())).bKeyData as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_key_descriptor),
            "::",
            stringify!(bKeyData)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_encryption_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bEncryptionType: __u8,
    pub bEncryptionValue: __u8,
    pub bAuthKeyIndex: __u8,
}
#[test]
fn bindgen_test_layout_usb_encryption_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_encryption_descriptor>(),
        5usize,
        concat!("Size of: ", stringify!(usb_encryption_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_encryption_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_encryption_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_encryption_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_encryption_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_encryption_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_encryption_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_encryption_descriptor>())).bEncryptionType as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_encryption_descriptor),
            "::",
            stringify!(bEncryptionType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_encryption_descriptor>())).bEncryptionValue as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_encryption_descriptor),
            "::",
            stringify!(bEncryptionValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_encryption_descriptor>())).bAuthKeyIndex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_encryption_descriptor),
            "::",
            stringify!(bAuthKeyIndex)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_bos_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub wTotalLength: __le16,
    pub bNumDeviceCaps: __u8,
}
#[test]
fn bindgen_test_layout_usb_bos_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_bos_descriptor>(),
        5usize,
        concat!("Size of: ", stringify!(usb_bos_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_bos_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_bos_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_bos_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_bos_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_bos_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_bos_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_bos_descriptor>())).wTotalLength as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_bos_descriptor),
            "::",
            stringify!(wTotalLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_bos_descriptor>())).bNumDeviceCaps as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_bos_descriptor),
            "::",
            stringify!(bNumDeviceCaps)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_dev_cap_header {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDevCapabilityType: __u8,
}
#[test]
fn bindgen_test_layout_usb_dev_cap_header() {
    assert_eq!(
        ::std::mem::size_of::<usb_dev_cap_header>(),
        3usize,
        concat!("Size of: ", stringify!(usb_dev_cap_header))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_dev_cap_header>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_dev_cap_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_dev_cap_header>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_cap_header),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_dev_cap_header>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_cap_header),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_dev_cap_header>())).bDevCapabilityType as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_cap_header),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_wireless_cap_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDevCapabilityType: __u8,
    pub bmAttributes: __u8,
    pub wPHYRates: __le16,
    pub bmTFITXPowerInfo: __u8,
    pub bmFFITXPowerInfo: __u8,
    pub bmBandGroup: __le16,
    pub bReserved: __u8,
}
#[test]
fn bindgen_test_layout_usb_wireless_cap_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_wireless_cap_descriptor>(),
        11usize,
        concat!("Size of: ", stringify!(usb_wireless_cap_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_wireless_cap_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_wireless_cap_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_cap_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_cap_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_cap_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_cap_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_cap_descriptor>())).bDevCapabilityType as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_cap_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_cap_descriptor>())).bmAttributes as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_cap_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_cap_descriptor>())).wPHYRates as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_cap_descriptor),
            "::",
            stringify!(wPHYRates)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_cap_descriptor>())).bmTFITXPowerInfo as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_cap_descriptor),
            "::",
            stringify!(bmTFITXPowerInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_cap_descriptor>())).bmFFITXPowerInfo as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_cap_descriptor),
            "::",
            stringify!(bmFFITXPowerInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_cap_descriptor>())).bmBandGroup as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_cap_descriptor),
            "::",
            stringify!(bmBandGroup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_cap_descriptor>())).bReserved as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_cap_descriptor),
            "::",
            stringify!(bReserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ext_cap_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDevCapabilityType: __u8,
    pub bmAttributes: __le32,
}
#[test]
fn bindgen_test_layout_usb_ext_cap_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_ext_cap_descriptor>(),
        7usize,
        concat!("Size of: ", stringify!(usb_ext_cap_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ext_cap_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ext_cap_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ext_cap_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_cap_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ext_cap_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_cap_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ext_cap_descriptor>())).bDevCapabilityType as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_cap_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ext_cap_descriptor>())).bmAttributes as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_cap_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ss_cap_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDevCapabilityType: __u8,
    pub bmAttributes: __u8,
    pub wSpeedSupported: __le16,
    pub bFunctionalitySupport: __u8,
    pub bU1devExitLat: __u8,
    pub bU2DevExitLat: __le16,
}
#[test]
fn bindgen_test_layout_usb_ss_cap_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_ss_cap_descriptor>(),
        10usize,
        concat!("Size of: ", stringify!(usb_ss_cap_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ss_cap_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ss_cap_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ss_cap_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_cap_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_cap_descriptor>())).bDevCapabilityType as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_cap_descriptor>())).bmAttributes as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_cap_descriptor>())).wSpeedSupported as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_descriptor),
            "::",
            stringify!(wSpeedSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_cap_descriptor>())).bFunctionalitySupport as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_descriptor),
            "::",
            stringify!(bFunctionalitySupport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_cap_descriptor>())).bU1devExitLat as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_descriptor),
            "::",
            stringify!(bU1devExitLat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_cap_descriptor>())).bU2DevExitLat as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_descriptor),
            "::",
            stringify!(bU2DevExitLat)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ss_container_id_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDevCapabilityType: __u8,
    pub bReserved: __u8,
    pub ContainerID: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_usb_ss_container_id_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_ss_container_id_descriptor>(),
        20usize,
        concat!("Size of: ", stringify!(usb_ss_container_id_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ss_container_id_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ss_container_id_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_container_id_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_container_id_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_container_id_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_container_id_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_container_id_descriptor>())).bDevCapabilityType
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_container_id_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_container_id_descriptor>())).bReserved as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_container_id_descriptor),
            "::",
            stringify!(bReserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ss_container_id_descriptor>())).ContainerID as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_container_id_descriptor),
            "::",
            stringify!(ContainerID)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ssp_cap_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDevCapabilityType: __u8,
    pub bReserved: __u8,
    pub bmAttributes: __le32,
    pub wFunctionalitySupport: __le16,
    pub wReserved: __le16,
    pub bmSublinkSpeedAttr: [__le32; 1usize],
}
#[test]
fn bindgen_test_layout_usb_ssp_cap_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_ssp_cap_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(usb_ssp_cap_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ssp_cap_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ssp_cap_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ssp_cap_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_cap_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ssp_cap_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_cap_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ssp_cap_descriptor>())).bDevCapabilityType as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_cap_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ssp_cap_descriptor>())).bReserved as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_cap_descriptor),
            "::",
            stringify!(bReserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ssp_cap_descriptor>())).bmAttributes as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_cap_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ssp_cap_descriptor>())).wFunctionalitySupport as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_cap_descriptor),
            "::",
            stringify!(wFunctionalitySupport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ssp_cap_descriptor>())).wReserved as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_cap_descriptor),
            "::",
            stringify!(wReserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ssp_cap_descriptor>())).bmSublinkSpeedAttr as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ssp_cap_descriptor),
            "::",
            stringify!(bmSublinkSpeedAttr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_pd_cap_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDevCapabilityType: __u8,
    pub bReserved: __u8,
    pub bmAttributes: __le32,
    pub bmProviderPorts: __le16,
    pub bmConsumerPorts: __le16,
    pub bcdBCVersion: __le16,
    pub bcdPDVersion: __le16,
    pub bcdUSBTypeCVersion: __le16,
}
#[test]
fn bindgen_test_layout_usb_pd_cap_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_pd_cap_descriptor>(),
        18usize,
        concat!("Size of: ", stringify!(usb_pd_cap_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_pd_cap_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_pd_cap_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_pd_cap_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_descriptor>())).bDevCapabilityType as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_pd_cap_descriptor>())).bReserved as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_descriptor),
            "::",
            stringify!(bReserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_descriptor>())).bmAttributes as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_descriptor>())).bmProviderPorts as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_descriptor),
            "::",
            stringify!(bmProviderPorts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_descriptor>())).bmConsumerPorts as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_descriptor),
            "::",
            stringify!(bmConsumerPorts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_descriptor>())).bcdBCVersion as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_descriptor),
            "::",
            stringify!(bcdBCVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_descriptor>())).bcdPDVersion as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_descriptor),
            "::",
            stringify!(bcdPDVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_descriptor>())).bcdUSBTypeCVersion as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_descriptor),
            "::",
            stringify!(bcdUSBTypeCVersion)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_pd_cap_battery_info_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDevCapabilityType: __u8,
    pub iBattery: __u8,
    pub iSerial: __u8,
    pub iManufacturer: __u8,
    pub bBatteryId: __u8,
    pub bReserved: __u8,
    pub dwChargedThreshold: __le32,
    pub dwWeakThreshold: __le32,
    pub dwBatteryDesignCapacity: __le32,
    pub dwBatteryLastFullchargeCapacity: __le32,
}
#[test]
fn bindgen_test_layout_usb_pd_cap_battery_info_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_pd_cap_battery_info_descriptor>(),
        24usize,
        concat!("Size of: ", stringify!(usb_pd_cap_battery_info_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_pd_cap_battery_info_descriptor>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_pd_cap_battery_info_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>())).bLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>())).bDescriptorType
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>())).bDevCapabilityType
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>())).iBattery as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(iBattery)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>())).iSerial as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(iSerial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>())).iManufacturer as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(iManufacturer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>())).bBatteryId as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(bBatteryId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>())).bReserved as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(bReserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>())).dwChargedThreshold
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(dwChargedThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>())).dwWeakThreshold
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(dwWeakThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>())).dwBatteryDesignCapacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(dwBatteryDesignCapacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_battery_info_descriptor>()))
                .dwBatteryLastFullchargeCapacity as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_battery_info_descriptor),
            "::",
            stringify!(dwBatteryLastFullchargeCapacity)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_pd_cap_consumer_port_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDevCapabilityType: __u8,
    pub bReserved: __u8,
    pub bmCapabilities: __u8,
    pub wMinVoltage: __le16,
    pub wMaxVoltage: __le16,
    pub wReserved: __u16,
    pub dwMaxOperatingPower: __le32,
    pub dwMaxPeakPower: __le32,
    pub dwMaxPeakPowerTime: __le32,
}
#[test]
fn bindgen_test_layout_usb_pd_cap_consumer_port_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_pd_cap_consumer_port_descriptor>(),
        23usize,
        concat!("Size of: ", stringify!(usb_pd_cap_consumer_port_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_pd_cap_consumer_port_descriptor>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_pd_cap_consumer_port_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_consumer_port_descriptor>())).bLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_consumer_port_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_consumer_port_descriptor>())).bDescriptorType
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_consumer_port_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_consumer_port_descriptor>())).bDevCapabilityType
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_consumer_port_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_consumer_port_descriptor>())).bReserved as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_consumer_port_descriptor),
            "::",
            stringify!(bReserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_consumer_port_descriptor>())).bmCapabilities
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_consumer_port_descriptor),
            "::",
            stringify!(bmCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_consumer_port_descriptor>())).wMinVoltage as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_consumer_port_descriptor),
            "::",
            stringify!(wMinVoltage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_consumer_port_descriptor>())).wMaxVoltage as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_consumer_port_descriptor),
            "::",
            stringify!(wMaxVoltage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_consumer_port_descriptor>())).wReserved as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_consumer_port_descriptor),
            "::",
            stringify!(wReserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_consumer_port_descriptor>())).dwMaxOperatingPower
                as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_consumer_port_descriptor),
            "::",
            stringify!(dwMaxOperatingPower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_consumer_port_descriptor>())).dwMaxPeakPower
                as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_consumer_port_descriptor),
            "::",
            stringify!(dwMaxPeakPower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_consumer_port_descriptor>())).dwMaxPeakPowerTime
                as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_consumer_port_descriptor),
            "::",
            stringify!(dwMaxPeakPowerTime)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug)]
pub struct usb_pd_cap_provider_port_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDevCapabilityType: __u8,
    pub bReserved1: __u8,
    pub bmCapabilities: __u8,
    pub bNumOfPDObjects: __u8,
    pub bReserved2: __u8,
    pub wPowerDataObject: __IncompleteArrayField<__le32>,
}
#[test]
fn bindgen_test_layout_usb_pd_cap_provider_port_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_pd_cap_provider_port_descriptor>(),
        7usize,
        concat!("Size of: ", stringify!(usb_pd_cap_provider_port_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_pd_cap_provider_port_descriptor>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_pd_cap_provider_port_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_provider_port_descriptor>())).bLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_provider_port_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_provider_port_descriptor>())).bDescriptorType
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_provider_port_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_provider_port_descriptor>())).bDevCapabilityType
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_provider_port_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_provider_port_descriptor>())).bReserved1 as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_provider_port_descriptor),
            "::",
            stringify!(bReserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_provider_port_descriptor>())).bmCapabilities
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_provider_port_descriptor),
            "::",
            stringify!(bmCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_provider_port_descriptor>())).bNumOfPDObjects
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_provider_port_descriptor),
            "::",
            stringify!(bNumOfPDObjects)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_provider_port_descriptor>())).bReserved2 as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_provider_port_descriptor),
            "::",
            stringify!(bReserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_pd_cap_provider_port_descriptor>())).wPowerDataObject
                as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_pd_cap_provider_port_descriptor),
            "::",
            stringify!(wPowerDataObject)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ptm_cap_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bDevCapabilityType: __u8,
}
#[test]
fn bindgen_test_layout_usb_ptm_cap_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_ptm_cap_descriptor>(),
        3usize,
        concat!("Size of: ", stringify!(usb_ptm_cap_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ptm_cap_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ptm_cap_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ptm_cap_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ptm_cap_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ptm_cap_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ptm_cap_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ptm_cap_descriptor>())).bDevCapabilityType as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ptm_cap_descriptor),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_wireless_ep_comp_descriptor {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bMaxBurst: __u8,
    pub bMaxSequence: __u8,
    pub wMaxStreamDelay: __le16,
    pub wOverTheAirPacketSize: __le16,
    pub bOverTheAirInterval: __u8,
    pub bmCompAttributes: __u8,
}
#[test]
fn bindgen_test_layout_usb_wireless_ep_comp_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<usb_wireless_ep_comp_descriptor>(),
        10usize,
        concat!("Size of: ", stringify!(usb_wireless_ep_comp_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_wireless_ep_comp_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_wireless_ep_comp_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_ep_comp_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_ep_comp_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_ep_comp_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_ep_comp_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_ep_comp_descriptor>())).bMaxBurst as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_ep_comp_descriptor),
            "::",
            stringify!(bMaxBurst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_ep_comp_descriptor>())).bMaxSequence as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_ep_comp_descriptor),
            "::",
            stringify!(bMaxSequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_ep_comp_descriptor>())).wMaxStreamDelay as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_ep_comp_descriptor),
            "::",
            stringify!(wMaxStreamDelay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_ep_comp_descriptor>())).wOverTheAirPacketSize
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_ep_comp_descriptor),
            "::",
            stringify!(wOverTheAirPacketSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_ep_comp_descriptor>())).bOverTheAirInterval
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_ep_comp_descriptor),
            "::",
            stringify!(bOverTheAirInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_wireless_ep_comp_descriptor>())).bmCompAttributes as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_wireless_ep_comp_descriptor),
            "::",
            stringify!(bmCompAttributes)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_handshake {
    pub bMessageNumber: __u8,
    pub bStatus: __u8,
    pub tTKID: [__u8; 3usize],
    pub bReserved: __u8,
    pub CDID: [__u8; 16usize],
    pub nonce: [__u8; 16usize],
    pub MIC: [__u8; 8usize],
}
#[test]
fn bindgen_test_layout_usb_handshake() {
    assert_eq!(
        ::std::mem::size_of::<usb_handshake>(),
        46usize,
        concat!("Size of: ", stringify!(usb_handshake))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_handshake>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_handshake))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_handshake>())).bMessageNumber as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_handshake),
            "::",
            stringify!(bMessageNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_handshake>())).bStatus as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_handshake),
            "::",
            stringify!(bStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_handshake>())).tTKID as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_handshake),
            "::",
            stringify!(tTKID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_handshake>())).bReserved as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_handshake),
            "::",
            stringify!(bReserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_handshake>())).CDID as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_handshake),
            "::",
            stringify!(CDID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_handshake>())).nonce as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_handshake),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_handshake>())).MIC as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_handshake),
            "::",
            stringify!(MIC)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_connection_context {
    pub CHID: [__u8; 16usize],
    pub CDID: [__u8; 16usize],
    pub CK: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_usb_connection_context() {
    assert_eq!(
        ::std::mem::size_of::<usb_connection_context>(),
        48usize,
        concat!("Size of: ", stringify!(usb_connection_context))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_connection_context>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_connection_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_connection_context>())).CHID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_connection_context),
            "::",
            stringify!(CHID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_connection_context>())).CDID as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_connection_context),
            "::",
            stringify!(CDID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_connection_context>())).CK as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_connection_context),
            "::",
            stringify!(CK)
        )
    );
}
pub const usb_device_speed_USB_SPEED_UNKNOWN: usb_device_speed = 0;
pub const usb_device_speed_USB_SPEED_LOW: usb_device_speed = 1;
pub const usb_device_speed_USB_SPEED_FULL: usb_device_speed = 2;
pub const usb_device_speed_USB_SPEED_HIGH: usb_device_speed = 3;
pub const usb_device_speed_USB_SPEED_WIRELESS: usb_device_speed = 4;
pub const usb_device_speed_USB_SPEED_SUPER: usb_device_speed = 5;
pub const usb_device_speed_USB_SPEED_SUPER_PLUS: usb_device_speed = 6;
pub type usb_device_speed = ::std::os::raw::c_uint;
pub const usb_device_state_USB_STATE_NOTATTACHED: usb_device_state = 0;
pub const usb_device_state_USB_STATE_ATTACHED: usb_device_state = 1;
pub const usb_device_state_USB_STATE_POWERED: usb_device_state = 2;
pub const usb_device_state_USB_STATE_RECONNECTING: usb_device_state = 3;
pub const usb_device_state_USB_STATE_UNAUTHENTICATED: usb_device_state = 4;
pub const usb_device_state_USB_STATE_DEFAULT: usb_device_state = 5;
pub const usb_device_state_USB_STATE_ADDRESS: usb_device_state = 6;
pub const usb_device_state_USB_STATE_CONFIGURED: usb_device_state = 7;
pub const usb_device_state_USB_STATE_SUSPENDED: usb_device_state = 8;
pub type usb_device_state = ::std::os::raw::c_uint;
pub const usb3_link_state_USB3_LPM_U0: usb3_link_state = 0;
pub const usb3_link_state_USB3_LPM_U1: usb3_link_state = 1;
pub const usb3_link_state_USB3_LPM_U2: usb3_link_state = 2;
pub const usb3_link_state_USB3_LPM_U3: usb3_link_state = 3;
pub type usb3_link_state = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_set_sel_req {
    pub u1_sel: __u8,
    pub u1_pel: __u8,
    pub u2_sel: __le16,
    pub u2_pel: __le16,
}
#[test]
fn bindgen_test_layout_usb_set_sel_req() {
    assert_eq!(
        ::std::mem::size_of::<usb_set_sel_req>(),
        6usize,
        concat!("Size of: ", stringify!(usb_set_sel_req))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_set_sel_req>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_set_sel_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_set_sel_req>())).u1_sel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_set_sel_req),
            "::",
            stringify!(u1_sel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_set_sel_req>())).u1_pel as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_set_sel_req),
            "::",
            stringify!(u1_pel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_set_sel_req>())).u2_sel as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_set_sel_req),
            "::",
            stringify!(u2_sel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_set_sel_req>())).u2_pel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_set_sel_req),
            "::",
            stringify!(u2_pel)
        )
    );
}
pub const FUNCTIONFS_DESCRIPTORS_MAGIC: ::std::os::raw::c_uint = 1;
pub const FUNCTIONFS_STRINGS_MAGIC: ::std::os::raw::c_uint = 2;
pub const FUNCTIONFS_DESCRIPTORS_MAGIC_V2: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const functionfs_flags_FUNCTIONFS_HAS_FS_DESC: functionfs_flags = 1;
pub const functionfs_flags_FUNCTIONFS_HAS_HS_DESC: functionfs_flags = 2;
pub const functionfs_flags_FUNCTIONFS_HAS_SS_DESC: functionfs_flags = 4;
pub const functionfs_flags_FUNCTIONFS_HAS_MS_OS_DESC: functionfs_flags = 8;
pub const functionfs_flags_FUNCTIONFS_VIRTUAL_ADDR: functionfs_flags = 16;
pub const functionfs_flags_FUNCTIONFS_EVENTFD: functionfs_flags = 32;
pub const functionfs_flags_FUNCTIONFS_ALL_CTRL_RECIP: functionfs_flags = 64;
pub const functionfs_flags_FUNCTIONFS_CONFIG0_SETUP: functionfs_flags = 128;
pub type functionfs_flags = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_endpoint_descriptor_no_audio {
    pub bLength: __u8,
    pub bDescriptorType: __u8,
    pub bEndpointAddress: __u8,
    pub bmAttributes: __u8,
    pub wMaxPacketSize: __le16,
    pub bInterval: __u8,
}
#[test]
fn bindgen_test_layout_usb_endpoint_descriptor_no_audio() {
    assert_eq!(
        ::std::mem::size_of::<usb_endpoint_descriptor_no_audio>(),
        7usize,
        concat!("Size of: ", stringify!(usb_endpoint_descriptor_no_audio))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_endpoint_descriptor_no_audio>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_endpoint_descriptor_no_audio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor_no_audio>())).bLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor_no_audio),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor_no_audio>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor_no_audio),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor_no_audio>())).bEndpointAddress
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor_no_audio),
            "::",
            stringify!(bEndpointAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor_no_audio>())).bmAttributes as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor_no_audio),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor_no_audio>())).wMaxPacketSize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor_no_audio),
            "::",
            stringify!(wMaxPacketSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_endpoint_descriptor_no_audio>())).bInterval as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor_no_audio),
            "::",
            stringify!(bInterval)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_functionfs_descs_head_v2 {
    pub magic: __le32,
    pub length: __le32,
    pub flags: __le32,
}
#[test]
fn bindgen_test_layout_usb_functionfs_descs_head_v2() {
    assert_eq!(
        ::std::mem::size_of::<usb_functionfs_descs_head_v2>(),
        12usize,
        concat!("Size of: ", stringify!(usb_functionfs_descs_head_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_functionfs_descs_head_v2>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_functionfs_descs_head_v2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_functionfs_descs_head_v2>())).magic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_descs_head_v2),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_functionfs_descs_head_v2>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_descs_head_v2),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_functionfs_descs_head_v2>())).flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_descs_head_v2),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_functionfs_descs_head {
    pub magic: __le32,
    pub length: __le32,
    pub fs_count: __le32,
    pub hs_count: __le32,
}
#[test]
fn bindgen_test_layout_usb_functionfs_descs_head() {
    assert_eq!(
        ::std::mem::size_of::<usb_functionfs_descs_head>(),
        16usize,
        concat!("Size of: ", stringify!(usb_functionfs_descs_head))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_functionfs_descs_head>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_functionfs_descs_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_functionfs_descs_head>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_descs_head),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_functionfs_descs_head>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_descs_head),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_functionfs_descs_head>())).fs_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_descs_head),
            "::",
            stringify!(fs_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_functionfs_descs_head>())).hs_count as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_descs_head),
            "::",
            stringify!(hs_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct usb_os_desc_header {
    pub interface: __u8,
    pub dwLength: __le32,
    pub bcdVersion: __le16,
    pub wIndex: __le16,
    pub __bindgen_anon_1: usb_os_desc_header__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union usb_os_desc_header__bindgen_ty_1 {
    pub __bindgen_anon_1: usb_os_desc_header__bindgen_ty_1__bindgen_ty_1,
    pub wCount: __le16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_os_desc_header__bindgen_ty_1__bindgen_ty_1 {
    pub bCount: __u8,
    pub Reserved: __u8,
}
#[test]
fn bindgen_test_layout_usb_os_desc_header__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<usb_os_desc_header__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(usb_os_desc_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<usb_os_desc_header__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_os_desc_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_os_desc_header__bindgen_ty_1__bindgen_ty_1>())).bCount
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_os_desc_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_os_desc_header__bindgen_ty_1__bindgen_ty_1>())).Reserved
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_os_desc_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_os_desc_header__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<usb_os_desc_header__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(usb_os_desc_header__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_os_desc_header__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(usb_os_desc_header__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_os_desc_header__bindgen_ty_1>())).wCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_os_desc_header__bindgen_ty_1),
            "::",
            stringify!(wCount)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_os_desc_header() {
    assert_eq!(
        ::std::mem::size_of::<usb_os_desc_header>(),
        11usize,
        concat!("Size of: ", stringify!(usb_os_desc_header))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_os_desc_header>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_os_desc_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_os_desc_header>())).interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_os_desc_header),
            "::",
            stringify!(interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_os_desc_header>())).dwLength as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_os_desc_header),
            "::",
            stringify!(dwLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_os_desc_header>())).bcdVersion as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_os_desc_header),
            "::",
            stringify!(bcdVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_os_desc_header>())).wIndex as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_os_desc_header),
            "::",
            stringify!(wIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ext_compat_desc {
    pub bFirstInterfaceNumber: __u8,
    pub Reserved1: __u8,
    pub CompatibleID: [__u8; 8usize],
    pub SubCompatibleID: [__u8; 8usize],
    pub Reserved2: [__u8; 6usize],
}
#[test]
fn bindgen_test_layout_usb_ext_compat_desc() {
    assert_eq!(
        ::std::mem::size_of::<usb_ext_compat_desc>(),
        24usize,
        concat!("Size of: ", stringify!(usb_ext_compat_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ext_compat_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ext_compat_desc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ext_compat_desc>())).bFirstInterfaceNumber as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_compat_desc),
            "::",
            stringify!(bFirstInterfaceNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ext_compat_desc>())).Reserved1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_compat_desc),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ext_compat_desc>())).CompatibleID as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_compat_desc),
            "::",
            stringify!(CompatibleID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ext_compat_desc>())).SubCompatibleID as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_compat_desc),
            "::",
            stringify!(SubCompatibleID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ext_compat_desc>())).Reserved2 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_compat_desc),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ext_prop_desc {
    pub dwSize: __le32,
    pub dwPropertyDataType: __le32,
    pub wPropertyNameLength: __le16,
}
#[test]
fn bindgen_test_layout_usb_ext_prop_desc() {
    assert_eq!(
        ::std::mem::size_of::<usb_ext_prop_desc>(),
        10usize,
        concat!("Size of: ", stringify!(usb_ext_prop_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_ext_prop_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ext_prop_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_ext_prop_desc>())).dwSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_prop_desc),
            "::",
            stringify!(dwSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ext_prop_desc>())).dwPropertyDataType as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_prop_desc),
            "::",
            stringify!(dwPropertyDataType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_ext_prop_desc>())).wPropertyNameLength as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ext_prop_desc),
            "::",
            stringify!(wPropertyNameLength)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_functionfs_strings_head {
    pub magic: __le32,
    pub length: __le32,
    pub str_count: __le32,
    pub lang_count: __le32,
}
#[test]
fn bindgen_test_layout_usb_functionfs_strings_head() {
    assert_eq!(
        ::std::mem::size_of::<usb_functionfs_strings_head>(),
        16usize,
        concat!("Size of: ", stringify!(usb_functionfs_strings_head))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_functionfs_strings_head>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_functionfs_strings_head))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_functionfs_strings_head>())).magic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_strings_head),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_functionfs_strings_head>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_strings_head),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_functionfs_strings_head>())).str_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_strings_head),
            "::",
            stringify!(str_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_functionfs_strings_head>())).lang_count as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_strings_head),
            "::",
            stringify!(lang_count)
        )
    );
}
pub const usb_functionfs_event_type_FUNCTIONFS_BIND: usb_functionfs_event_type = 0;
pub const usb_functionfs_event_type_FUNCTIONFS_UNBIND: usb_functionfs_event_type = 1;
pub const usb_functionfs_event_type_FUNCTIONFS_ENABLE: usb_functionfs_event_type = 2;
pub const usb_functionfs_event_type_FUNCTIONFS_DISABLE: usb_functionfs_event_type = 3;
pub const usb_functionfs_event_type_FUNCTIONFS_SETUP: usb_functionfs_event_type = 4;
pub const usb_functionfs_event_type_FUNCTIONFS_SUSPEND: usb_functionfs_event_type = 5;
pub const usb_functionfs_event_type_FUNCTIONFS_RESUME: usb_functionfs_event_type = 6;
pub type usb_functionfs_event_type = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct usb_functionfs_event {
    pub u: usb_functionfs_event__bindgen_ty_1,
    pub type_: __u8,
    pub _pad: [__u8; 3usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union usb_functionfs_event__bindgen_ty_1 {
    pub setup: usb_ctrlrequest,
}
#[test]
fn bindgen_test_layout_usb_functionfs_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<usb_functionfs_event__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(usb_functionfs_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_functionfs_event__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_functionfs_event__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usb_functionfs_event__bindgen_ty_1>())).setup as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_event__bindgen_ty_1),
            "::",
            stringify!(setup)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_functionfs_event() {
    assert_eq!(
        ::std::mem::size_of::<usb_functionfs_event>(),
        12usize,
        concat!("Size of: ", stringify!(usb_functionfs_event))
    );
    assert_eq!(
        ::std::mem::align_of::<usb_functionfs_event>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_functionfs_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_functionfs_event>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_event),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_functionfs_event>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usb_functionfs_event>()))._pad as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_functionfs_event),
            "::",
            stringify!(_pad)
        )
    );
}
